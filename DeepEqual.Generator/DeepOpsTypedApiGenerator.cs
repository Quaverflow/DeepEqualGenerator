// <auto-generated/>
#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DeepEqual.Generator
{
    [Generator(LanguageNames.CSharp)]
    public sealed class DeepOpsTypedApiGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Discover owned roots via attribute
            var attrRoots =
                context.SyntaxProvider.ForAttributeWithMetadataName(
                        GenCommon.DeepComparableAttributeMetadataName,
                        static (node, _) => node is TypeDeclarationSyntax,
                        static (gasc, ct) =>
                        {
                            if (gasc.TargetSymbol is not INamedTypeSymbol typeSymbol) return (INamedTypeSymbol?)null;
                            return typeSymbol;
                        })
                    .Where(static r => r is not null)
                    .Select(static (r, _) => r!);

            // External roots via assembly marker
            var external = context.CompilationProvider.Select((comp, _) =>
            {
                var asm = comp.Assembly;
                var extRoots = new List<INamedTypeSymbol>();
                foreach (var a in asm.GetAttributes())
                {
                    var name = a.AttributeClass?.ToDisplayString();
                    if (name == GenCommon.ExternalDeepComparableMetadataName && a.ConstructorArguments.Length == 1)
                    {
                        if (a.ConstructorArguments[0].Value is INamedTypeSymbol rootTs) extRoots.Add(rootTs);
                    }
                }
                return (comp, extRoots);
            });

            var inputs = attrRoots.Collect().Combine(external);
            context.RegisterSourceOutput(inputs, (spc, all) =>
            {
                var (ownedTypes, (compilation, extRoots)) = all;

                // Parse fluent config for additional/adopted roots and per-root flags
                var model = ConfigParser.Parse(compilation, spc.CancellationToken, d => spc.ReportDiagnostic(d));

                // Merge
                var rootSet = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
                foreach (var t in ownedTypes) rootSet.Add(t);
                foreach (var t in extRoots) rootSet.Add(t);
                foreach (var t in model.Roots.Keys) rootSet.Add(t);

                // Build per-root flags
                var roots = new List<(INamedTypeSymbol Type, bool GenDiff, bool GenDelta)>();
                foreach (var t in rootSet)
                {
                    var hasFluent = model.Roots.TryGetValue(t, out var rc);
                    var genDiff = hasFluent ? (rc!.GenerateDiff ?? false) : true;    // default to true for owned/external
                    var genDelta = hasFluent ? (rc!.GenerateDelta ?? false) : true;  // default to true for owned/external

                    roots.Add((t, genDiff, genDelta));
                }

                new DeepOpsTypedApisEmitter().Emit(spc, roots.ToArray());
                new DeepOpsExtensionsEmitter().Emit(spc, roots.ToArray());
            });
        }
    }
}