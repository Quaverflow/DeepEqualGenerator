// <auto-generated/>
#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DeepEqual.Generator
{
    internal static class ConfigParser
    {
        private const string BuilderType = "DeepEqual.DeepOpsBuilder";
        private const string RootBuilderType = "DeepEqual.RootBuilder";
        private const string ExternalBuilderType = "DeepEqual.ExternalBuilder";

        public static ConfigModel Parse(Compilation compilation, CancellationToken ct, Action<Diagnostic> report)
        {
            var model = new ConfigModel();
            var cfgType = compilation.GetTypeByMetadataName("DeepEqual.DeepOpsConfig");
            if (cfgType is null) return model;

            var builderTs = compilation.GetTypeByMetadataName(BuilderType);
            var rootBuilderTs = compilation.GetTypeByMetadataName(RootBuilderType);

            // Find Configure method
            foreach (var m in cfgType.GetMembers().OfType<IMethodSymbol>())
            {
                if (m.Name != "Configure" || !m.IsStatic || m.Parameters.Length != 1) continue;
                if (m.Parameters[0].Type.ToDisplayString() != BuilderType) continue;

                foreach (var sref in m.DeclaringSyntaxReferences)
                {
                    var methodSyntax = sref.GetSyntax(ct) as MethodDeclarationSyntax;
                    if (methodSyntax is null) continue;
                    var tree = methodSyntax.SyntaxTree;
                    var sm = compilation.GetSemanticModel(tree);

                    // Traverse all invocations inside method body
                    foreach (var inv in methodSyntax.DescendantNodes().OfType<InvocationExpressionSyntax>())
                    {
                        ct.ThrowIfCancellationRequested();

                        var symbol = sm.GetSymbolInfo(inv).Symbol as IMethodSymbol;
                        if (symbol is null) continue;

                        var containing = symbol.ContainingType?.ToDisplayString();
                        var name = symbol.Name;

                        // Global knobs: b.StableMemberIndices(...), etc.
                        if (containing == BuilderType)
                        {
                            if (name == "StableMemberIndices")
                                model.Global.StableMemberIndices = TryGetBoolArg(sm, inv);
                            else if (name == "StringComparison")
                            {
                                // capture presence only; generator will honor ComparisonOptions at runtime
                            }
                            else if (name == "FloatEpsilon")
                                model.Global.FloatEpsilon = TryGetDoubleArg(sm, inv);
                            else if (name == "DecimalEpsilon")
                                model.Global.DecimalEpsilon = TryGetDecimalArg(sm, inv);
                            else if (name == "TreatNaNEqual")
                                model.Global.TreatNaNEqual = TryGetBoolArg(sm, inv);
                        }

                        // b.ForRoot<TRoot>(...)
                        if (containing == BuilderType && name == "ForRoot" && symbol.IsGenericMethod && symbol.TypeArguments.Length == 1)
                        {
                            var root = symbol.TypeArguments[0] as INamedTypeSymbol;
                            if (root is null) continue;
                            var rc = model.GetOrCreateRoot(root);
                            // Capture chained calls
                            CaptureRootChain(rc, sm, inv);
                        }

                        // External roots (minimal support: adopt as root)
                        if (containing == BuilderType && name == "ForExternal" && symbol.IsGenericMethod && symbol.TypeArguments.Length == 1)
                        {
                            var root = symbol.TypeArguments[0] as INamedTypeSymbol;
                            if (root is null) continue;
                            var rc = model.GetOrCreateRoot(root);
                            rc.GenerateDelta ??= true;
                            rc.GenerateDiff ??= true;
                        }
                    }
                }
            }

            return model;
        }

        private static void CaptureRootChain(RootConfig rc, SemanticModel sm, InvocationExpressionSyntax forRootCall)
        {
            // The parent of ForRoot(...) is usually a member-access chain.
            // We walk the chain upward collecting subsequent calls until we hit a statement boundary.
            var current = forRootCall.Parent;
            while (current is MemberAccessExpressionSyntax or InvocationExpressionSyntax)
            {
                if (current is InvocationExpressionSyntax inv)
                {
                    var sym = sm.GetSymbolInfo(inv).Symbol as IMethodSymbol;
                    if (sym is null) break;
                    var name = sym.Name;

                    switch (name)
                    {
                        case "GenerateDelta":
                            rc.GenerateDelta = TryGetBoolArg(sm, inv) ?? true;
                            break;
                        case "GenerateDiff":
                            rc.GenerateDiff = TryGetBoolArg(sm, inv) ?? true;
                            break;
                        case "IncludeInternals":
                            rc.IncludeInternals = TryGetBoolArg(sm, inv) ?? true;
                            break;
                        case "OrderInsensitiveFor":
                            if (sym.IsGenericMethod && sym.TypeArguments.Length == 1)
                            {
                                var te = sym.TypeArguments[0];
                                rc.OrderInsensitiveFor[te] = TryGetBoolArg(sm, inv) ?? true;
                            }
                            break;
                        case "KeyFor":
                            if (sym.IsGenericMethod && sym.TypeArguments.Length == 1)
                            {
                                var te = sym.TypeArguments[0];
                                var member = TryGetLambdaMemberName(sm, inv);
                                if (!string.IsNullOrEmpty(member))
                                {
                                    if (!rc.KeysFor.TryGetValue(te, out var list))
                                        rc.KeysFor[te] = list = new List<string>(1);
                                    list.Add(member!);
                                }
                            }
                            break;
                        case "ShallowFor":
                            if (sym.IsGenericMethod && sym.TypeArguments.Length == 1)
                            {
                                var t = sym.TypeArguments[0];
                                GetTypeOverride(rc, t).Kind = TryGetBoolArg(sm, inv) != false ? CompareKind.Shallow : (CompareKind?)null;
                            }
                            break;
                        case "ReferenceFor":
                            if (sym.IsGenericMethod && sym.TypeArguments.Length == 1)
                            {
                                var t = sym.TypeArguments[0];
                                GetTypeOverride(rc, t).Kind = TryGetBoolArg(sm, inv) != false ? CompareKind.Reference : (CompareKind?)null;
                            }
                            break;
                        case "Skip":
                            if (sym.IsGenericMethod && sym.TypeArguments.Length == 1)
                            {
                                var t = sym.TypeArguments[0];
                                var member = TryGetLambdaMemberName(sm, inv);
                                if (!string.IsNullOrEmpty(member))
                                {
                                    rc.MemberOverrides[(t, member!)] = new MemberOverride { Kind = CompareKind.Skip };
                                }
                            }
                            break;
                        case "Comparer":
                            if (sym.IsGenericMethod && sym.TypeArguments.Length == 1)
                            {
                                var t = sym.TypeArguments[0];
                                var comparerType = TryGetComparerType(sm, inv);
                                if (comparerType is INamedTypeSymbol nts)
                                {
                                    GetTypeOverride(rc, t).ComparerType = nts;
                                }
                            }
                            break;
                        case "TrackMutations":
                            rc.TrackMutations = TryGetBoolArg(sm, inv) ?? true;
                            break;
                    }

                    current = inv.Parent;
                }
                else
                {
                    current = current?.Parent;
                }
            }
        }

        private static TypeOverride GetTypeOverride(RootConfig rc, ITypeSymbol t)
        {
            if (!rc.TypeOverrides.TryGetValue(t, out var to))
            {
                to = new TypeOverride();
                rc.TypeOverrides[t] = to;
            }
            return to;
        }

        private static bool? TryGetBoolArg(SemanticModel sm, InvocationExpressionSyntax inv)
        {
            if (inv.ArgumentList is null || inv.ArgumentList.Arguments.Count == 0) return null;
            var expr = inv.ArgumentList.Arguments[0].Expression;
            var c = sm.GetConstantValue(expr);
            if (c.HasValue && c.Value is bool b) return b;
            return null;
        }

        private static double? TryGetDoubleArg(SemanticModel sm, InvocationExpressionSyntax inv)
        {
            if (inv.ArgumentList is null || inv.ArgumentList.Arguments.Count == 0) return null;
            var expr = inv.ArgumentList.Arguments[0].Expression;
            var c = sm.GetConstantValue(expr);
            if (c.HasValue)
            {
                try { return Convert.ToDouble(c.Value); } catch { }
            }
            return null;
        }

        private static decimal? TryGetDecimalArg(SemanticModel sm, InvocationExpressionSyntax inv)
        {
            if (inv.ArgumentList is null || inv.ArgumentList.Arguments.Count == 0) return null;
            var expr = inv.ArgumentList.Arguments[0].Expression;
            var c = sm.GetConstantValue(expr);
            if (c.HasValue)
            {
                try { return Convert.ToDecimal(c.Value); } catch { }
            }
            return null;
        }

        private static string? TryGetLambdaMemberName(SemanticModel sm, InvocationExpressionSyntax inv)
        {
            if (inv.ArgumentList is null || inv.ArgumentList.Arguments.Count == 0) return null;
            var expr = inv.ArgumentList.Arguments[0].Expression;

            // Handle "x => x.Prop" or "x => (object?)x.Prop"
            var lambda = expr as SimpleLambdaExpressionSyntax;
            if (lambda is null) return null;

            ExpressionSyntax body = lambda.Body as ExpressionSyntax ?? lambda.ExpressionBody!;

            if (body is ParenthesizedExpressionSyntax paren) body = paren.Expression;

            if (body is MemberAccessExpressionSyntax ma)
            {
                return ma.Name.Identifier.Text;
            }

            return null;
        }

        private static ITypeSymbol? TryGetComparerType(SemanticModel sm, InvocationExpressionSyntax inv)
        {
            if (inv.ArgumentList is null || inv.ArgumentList.Arguments.Count == 0) return null;
            var expr = inv.ArgumentList.Arguments[0].Expression;
            var type = sm.GetTypeInfo(expr).Type;
            return type as INamedTypeSymbol;
        }
    }
}