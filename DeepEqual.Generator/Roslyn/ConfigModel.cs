// <auto-generated/>
#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;

namespace DeepEqual.Generator
{
    internal sealed class GlobalConfig
    {
        public bool? StableMemberIndices { get; set; }
        public StringComparison? StringComparison { get; set; }
        public double? FloatEpsilon { get; set; }
        public decimal? DecimalEpsilon { get; set; }
        public bool? TreatNaNEqual { get; set; }
    }

    internal sealed class TypeOverride
    {
        public CompareKind? Kind { get; set; } // Shallow / Reference (Deep is default)
        public bool? OrderInsensitive { get; set; }
        public INamedTypeSymbol? ComparerType { get; set; }
    }

    internal sealed class MemberOverride
    {
        public CompareKind? Kind { get; set; } // Skip / Shallow / Reference
        public bool? OrderInsensitive { get; set; }
        public string? KeyMember { get; set; }
    }

    internal sealed class RootConfig
    {
        public INamedTypeSymbol RootType { get; }
        public bool? GenerateDelta { get; set; }
        public bool? GenerateDiff { get; set; }
        public bool? IncludeInternals { get; set; }
        public bool? TrackMutations { get; set; } // maps to [DeltaTrack]

        // Type-level overrides
        public Dictionary<ITypeSymbol, TypeOverride> TypeOverrides { get; } = new(SymbolEqualityComparer.Default);
        // Member-level overrides (type, memberName) -> rule
        public Dictionary<(ITypeSymbol Type, string Member), MemberOverride> MemberOverrides { get; } =
            new(new MemberKeyComparer());

        // Root-level element settings (unordered + keys)
        public Dictionary<ITypeSymbol, bool> OrderInsensitiveFor { get; } = new(SymbolEqualityComparer.Default);
        public Dictionary<ITypeSymbol, List<string>> KeysFor { get; } = new(SymbolEqualityComparer.Default);

        public RootConfig(INamedTypeSymbol root) => RootType = root;

        private sealed class MemberKeyComparer : IEqualityComparer<(ITypeSymbol, string)>
        {
            public bool Equals((ITypeSymbol, string) x, (ITypeSymbol, string) y) =>
                SymbolEqualityComparer.Default.Equals(x.Item1, y.Item1) &&
                StringComparer.Ordinal.Equals(x.Item2, y.Item2);

            public int GetHashCode((ITypeSymbol, string) obj)
            {
                unchecked
                {
                    var h1 = SymbolEqualityComparer.Default.GetHashCode(obj.Item1);
                    var h2 = StringComparer.Ordinal.GetHashCode(obj.Item2);
                    return (h1 * 397) ^ h2;
                }
            }
        }
    }

    internal sealed class ConfigModel
    {
        public GlobalConfig Global { get; } = new();
        public Dictionary<INamedTypeSymbol, RootConfig> Roots { get; } = new(SymbolEqualityComparer.Default);

        public RootConfig GetOrCreateRoot(INamedTypeSymbol t)
        {
            if (!Roots.TryGetValue(t, out var rc))
            {
                rc = new RootConfig(t);
                Roots[t] = rc;
            }
            return rc;
        }
    }
}