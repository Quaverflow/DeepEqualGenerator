// <auto-generated/>
#nullable enable
using DeepEqual.Generator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;

namespace DeepEqual.Generator;

internal static class GenCommon
{
    internal const string DeepComparableAttributeMetadataName = "DeepEqual.Generator.Shared.DeepComparableAttribute";
    internal const string DeepCompareAttributeMetadataName = "DeepEqual.Generator.Shared.DeepCompareAttribute";
    internal const string ExternalDeepComparableMetadataName = "DeepEqual.Generator.Shared.ExternalDeepComparableAttribute";
    internal const string ExternalDeepCompareMetadataName = "DeepEqual.Generator.Shared.ExternalDeepCompareAttribute";

    internal static string BuildMetadataName(INamedTypeSymbol symbol)
    {
        var sb = new StringBuilder();
        var containing = symbol.ContainingType;
        if (containing is not null)
        {
            sb.Append(BuildMetadataName(containing));
            sb.Append('+');
            sb.Append(symbol.MetadataName);
        }
        else
        {
            var ns = symbol.ContainingNamespace?.ToDisplayString() ?? "";
            if (!string.IsNullOrEmpty(ns))
            {
                sb.Append(ns);
                sb.Append('.');
            }
            sb.Append(symbol.MetadataName);
        }
        return sb.ToString();
    }

    internal static string SanitizeFileName(string value)
    {
        var invalid = Path.GetInvalidFileNameChars();
        var arr = value.Select(ch => invalid.Contains(ch) ? '_' : ch).ToArray();
        return new string(arr);
    }

    internal static string SanitizeIdentifier(string s)
    {
        var sb = new StringBuilder(s.Length);
        foreach (var ch in s)
        {
            sb.Append(char.IsLetterOrDigit(ch) ? ch : '_');
        }

        return sb.ToString();
    }
}


[Generator(LanguageNames.CSharp)]
public sealed class DeepOpsGenerator : IIncrementalGenerator
{
    private readonly record struct RootRequest(
        string MetadataName,
        string QualifiedDisplayName,
        bool IncludeInternals,
        bool OrderInsensitiveCollections,
        bool EqCycleTrackingEnabled,
        bool DdCycleTrackingEnabled,
        bool IncludeBaseMembers,
        bool GenerateDiff,
        bool GenerateDelta,
        StableMemberIndexMode StableMemberIndexMode,
        Location? AttributeLocation
    );

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Owned [DeepComparable] attributes → RootRequest
        var ownedRequests =
            context.SyntaxProvider.ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: GenCommon.DeepComparableAttributeMetadataName,
                predicate: static (node, _) => node is TypeDeclarationSyntax,
                transform: static (gasc, ct) =>
                {
                    if (gasc.TargetSymbol is not INamedTypeSymbol typeSymbol) return (RootRequest?)null;

                    var attr = gasc.Attributes.FirstOrDefault(a =>
                        a.AttributeClass?.ToDisplayString() == GenCommon.DeepComparableAttributeMetadataName);
                    if (attr is null) return (RootRequest?)null;

                    static bool HasNamedTrue(AttributeData a, string name) =>
                        a.NamedArguments.Any(kv => kv.Key == name && kv.Value.Value is true);

                    static bool? GetNamedBool(AttributeData a, string name)
                    {
                        var has = a.NamedArguments.FirstOrDefault(kv => kv.Key == name);
                        return has.Value.Value is bool b ? b : (bool?)null;
                    }

                    static int GetEnumValue(AttributeData a, string name)
                    {
                        var arg = a.NamedArguments.FirstOrDefault(kv => kv.Key == name).Value;
                        return arg.Kind == TypedConstantKind.Enum && arg.Value is int i ? i : 0;
                    }

                    bool includeInternals = HasNamedTrue(attr, "IncludeInternals");
                    bool orderInsensitive = HasNamedTrue(attr, "OrderInsensitiveCollections");
                    bool includeBase = HasNamedTrue(attr, "IncludeBaseMembers");
                    bool genDiff = HasNamedTrue(attr, "GenerateDiff");
                    bool genDelta = HasNamedTrue(attr, "GenerateDelta");

                    bool? cycleSpecified = GetNamedBool(attr, "CycleTracking");
                    bool eqCycle = cycleSpecified ?? true;   // equality default TRUE
                    bool ddCycle = cycleSpecified ?? false;  // diff/delta default FALSE

                    var stableMode = (StableMemberIndexMode)GetEnumValue(attr, "StableMemberIndex");
                    var attrLoc = attr.ApplicationSyntaxReference?.GetSyntax(ct)?.GetLocation();

                    var metadataName = GenCommon.BuildMetadataName(typeSymbol);
                    var fqn = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                    return new RootRequest(
                        metadataName, fqn,
                        includeInternals, orderInsensitive,
                        eqCycle, ddCycle, includeBase,
                        genDiff, genDelta, stableMode, attrLoc);
                })
            .Where(static r => r is not null)
            .Select(static (r, _) => r!.Value);

        // External assembly-scoped annotations
        var external = context.CompilationProvider.Select((comp, _) =>
        {
            var asm = comp.Assembly;
            var extRoots = new List<(INamedTypeSymbol Root, AttributeData Attr)>();
            var extMember = new List<(INamedTypeSymbol Root, string Path, AttributeData Attr)>();
            foreach (var a in asm.GetAttributes())
            {
                var name = a.AttributeClass?.ToDisplayString();
                if (name == GenCommon.ExternalDeepComparableMetadataName && a.ConstructorArguments.Length == 1)
                {
                    if (a.ConstructorArguments[0].Value is INamedTypeSymbol rootTs)
                        extRoots.Add((rootTs, a));
                }
                else if (name == GenCommon.ExternalDeepCompareMetadataName && a.ConstructorArguments.Length == 2)
                {
                    if (a.ConstructorArguments[0].Value is INamedTypeSymbol rootTs &&
                        a.ConstructorArguments[1].Value is string path)
                        extMember.Add((rootTs, path, a));
                }
            }
            return (comp, extRoots, extMember);
        });

        // Combine & emit once
        var inputs = ownedRequests.Collect().Combine(external);
        context.RegisterSourceOutput(inputs, (spc, all) =>
        {
            var (ownedList, (compilation, extRoots, extMembers)) = all;

            // Validate external per-member paths once (diagnostics only)
            foreach (var (rootType, path, attr) in extMembers)
            {
                try
                {
                    var (_, member, _) = ExternalPathResolver.ResolveMemberPath(
                        compilation,
                        rootType,
                        path,
                        includeInternals: false,
                        includeBase: true,
                        report: (loc, msg, kind) =>
                        {
                            var diag = kind switch
                            {
                                ExternalPathResolver.PathDiag.DictionarySideInvalid => Diagnostics.EX002,
                                ExternalPathResolver.PathDiag.AmbiguousEnumerable => Diagnostics.EX003,
                                _ => Diagnostics.EX001
                            };
                            spc.ReportDiagnostic(Diagnostic.Create(diag, loc, msg));
                        },
                        attrLocation: attr.ApplicationSyntaxReference?.GetSyntax()?.GetLocation());
                    _ = member;
                }
                catch
                {
                    // errors already reported via report(...)
                }
            }

            // Union of owned + external (owned wins)
            var roots = new Dictionary<INamedTypeSymbol, (bool incInt, bool ordIns, bool eqCycle, bool ddCycle, bool incBase, bool genDiff, bool genDelta, StableMemberIndexMode stableMode, Location? loc)>(SymbolEqualityComparer.Default);

            foreach (var req in ownedList)
            {
                var t = compilation.GetTypeByMetadataName(req.MetadataName);
                if (t is null) continue;
                if (!roots.ContainsKey(t))
                    roots[t] = (req.IncludeInternals, req.OrderInsensitiveCollections, req.EqCycleTrackingEnabled, req.DdCycleTrackingEnabled, req.IncludeBaseMembers, req.GenerateDiff, req.GenerateDelta, req.StableMemberIndexMode, req.AttributeLocation);
            }

            static bool HasNamedTrue(AttributeData a, string name) =>
                a.NamedArguments.Any(kv => kv.Key == name && kv.Value.Value is true);
            static (bool? val, bool present) GetNamedBool(AttributeData a, string name)
            {
                var entry = a.NamedArguments.FirstOrDefault(kv => kv.Key == name);
                return (entry.Value.Value is bool b ? b : (bool?)null, entry.Value.Value is bool);
            }
            static int GetEnumValue(AttributeData a, string name)
            {
                var arg = a.NamedArguments.FirstOrDefault(kv => kv.Key == name).Value;
                return arg.Kind == TypedConstantKind.Enum && arg.Value is int i ? i : 0;
            }

            foreach (var (extType, attr) in extRoots)
            {
                if (extType is null || roots.ContainsKey(extType)) continue;

                bool incInt = HasNamedTrue(attr, "IncludeInternals");
                bool ordIns = HasNamedTrue(attr, "OrderInsensitiveCollections");
                bool incBase = HasNamedTrue(attr, "IncludeBaseMembers");
                bool genDiff = HasNamedTrue(attr, "GenerateDiff");
                bool genDelta = HasNamedTrue(attr, "GenerateDelta");
                var (cycleVal, present) = GetNamedBool(attr, "CycleTracking");
                bool eqCycle = present ? (cycleVal ?? true) : true;
                bool ddCycle = present ? (cycleVal ?? false) : false;
                var stableMode = (StableMemberIndexMode)GetEnumValue(attr, "StableMemberIndex");
                var loc = attr.ApplicationSyntaxReference?.GetSyntax()?.GetLocation();

                roots[extType] = (incInt, ordIns, eqCycle, ddCycle, incBase, genDiff, genDelta, stableMode, loc);
            }

            var eqEmitter = new EqualityEmitter(compilation);
            var ddEmitter = new DiffDeltaEmitter(compilation);
            var seenHints = new HashSet<string>(StringComparer.Ordinal);

            foreach (var kvp in roots)
            {
                var type = kvp.Key;
                var (incInt, ordIns, eqCycle, ddCycle, incBase, genDiff, genDelta, stableMode, loc) = kvp.Value;

                Diagnostics.DiagnosticPass(spc, type);

                // Equality helper (always)
                {
                    var hint = GenCommon.SanitizeFileName(type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) + "_DeepEqual.g.cs");
                    if (seenHints.Add(hint))
                    {
                        eqEmitter.EmitForRoot(
                            spc,
                            new EqualityEmitter.Target(type, incInt, ordIns, eqCycle, incBase),
                            hintOverride: hint);
                    }
                }

                // Diff/Delta helpers (conditional)
                if (genDiff || genDelta)
                {
                    if (genDelta && stableMode == StableMemberIndexMode.Off && loc is not null)
                        spc.ReportDiagnostic(Diagnostic.Create(Diagnostics.DL001, loc));

                    var hint = GenCommon.SanitizeFileName(type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) + "_DeepOps.g.cs");
                    if (seenHints.Add(hint))
                    {
                        ddEmitter.EmitForRoot(
                            spc,
                            new DiffDeltaEmitter.Target(type, incInt, ordIns, ddCycle, incBase, genDiff, genDelta),
                            hintOverride: hint);
                    }
                }
            }
        });
    }
}

internal sealed class EqualityEmitter
{
    private readonly Compilation _compilation;

    public EqualityEmitter(Compilation compilation) => _compilation = compilation;


    private const string DeepComparableAttributeName = GenCommon.DeepComparableAttributeMetadataName;
    private const string DeepCompareAttributeName = GenCommon.DeepCompareAttributeMetadataName;

    internal readonly record struct Target(
        INamedTypeSymbol Type,
        bool IncludeInternals,
        bool OrderInsensitiveCollections,
        bool CycleTrackingEnabled,
        bool IncludeBaseMembers);

    private readonly record struct MemberSymbol(string Name, ITypeSymbol Type, ISymbol Symbol);

    private sealed record TypeSchema(IReadOnlyList<string> IncludeMembers, IReadOnlyList<string> IgnoreMembers);

    private enum EffectiveKind
    {
        Deep = 0,
        Shallow = 1,
        Reference = 2,
        Skip = 3
    }

    /// <summary>
    /// Per-emission caches (ephemeral only).
    /// No static/threadstatic persistence. Keys are symbols from the current emission only.
    /// </summary>
    private sealed class RuntimeCache
    {
        internal readonly Dictionary<ITypeSymbol, bool> UserObject = new(SymbolEqualityComparer.Default);
        internal readonly Dictionary<ITypeSymbol, ITypeSymbol?> EnumerableElement = new(SymbolEqualityComparer.Default);

        internal readonly Dictionary<ITypeSymbol, (ITypeSymbol Key, ITypeSymbol Val)?> DictionaryKv =
            new(SymbolEqualityComparer.Default);

        internal readonly Dictionary<ITypeSymbol, ITypeSymbol?> MemoryElement = new(SymbolEqualityComparer.Default);
        internal readonly Dictionary<INamedTypeSymbol, TypeSchema> SchemaCache = new(SymbolEqualityComparer.Default);

        internal readonly Dictionary<(INamedTypeSymbol type, bool allowInternals, bool includeBase), MemberSymbol[]>
            MemberCache = new(MemberKeyComparer.Instance);

        private sealed class MemberKeyComparer : IEqualityComparer<(INamedTypeSymbol type, bool allowInternals, bool includeBase)>
        {
            public static readonly MemberKeyComparer Instance = new();

            public bool Equals((INamedTypeSymbol type, bool allowInternals, bool includeBase) x,
                (INamedTypeSymbol type, bool allowInternals, bool includeBase) y)
            {
                return SymbolEqualityComparer.Default.Equals(x.type, y.type) && x.allowInternals == y.allowInternals &&
                       x.includeBase == y.includeBase;
            }

            public int GetHashCode((INamedTypeSymbol type, bool allowInternals, bool includeBase) obj)
            {
                unchecked
                {
                    var h1 = SymbolEqualityComparer.Default.GetHashCode(obj.type);
                    var h2 = obj.allowInternals ? 1 : 0;
                    var h3 = obj.includeBase ? 1 : 0;
                    return (((h1 * 397) ^ h2) * 397) ^ h3;
                }
            }
        }
    }

    private readonly RuntimeCache _cache = new();

    public void EmitForRoot(SourceProductionContext spc, Target root, string? hintOverride = null)
    {
        var ns = root.Type.ContainingNamespace.IsGlobalNamespace
            ? null
            : root.Type.ContainingNamespace.ToDisplayString();
        var rootFqn = root.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var helperClass = root.Type.Name + "DeepEqual";
        var hintName = hintOverride ?? GenCommon.SanitizeFileName(rootFqn + "_DeepEqual.g.cs");

        var reachable = BuildReachableTypeClosure(root);
        var trackCycles = root.CycleTrackingEnabled;
        var accessibility = root.IncludeInternals || root.Type.DeclaredAccessibility != Accessibility.Public
            ? "internal"
            : "public";
        var typeParams = root.Type.Arity > 0
            ? "<" + string.Join(",", root.Type.TypeArguments.Select(a => a.Name)) + ">"
            : "";

        var w = new CodeWriter();
        w.Line("// <auto-generated/>");
        w.Line("#pragma warning disable");
        w.Line("using System;");
        w.Line("using System.Collections;");
        w.Line("using System.Collections.Generic;");
        w.Line("using DeepEqual.Generator.Shared;");
        w.Line();

        if (ns is not null)
        {
            w.Open("namespace " + ns);
        }

        w.Open(accessibility + " static class " + helperClass + typeParams);

        w.Open("static " + helperClass + "()");
        foreach (var t in reachable.Where(t => IsTypeAccessibleFromRoot(t, root))
                     .OrderBy(t => t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), StringComparer.Ordinal))
        {
            var fqn = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var helper = GetHelperMethodName(t);
            w.Line("GeneratedHelperRegistry.RegisterComparer<" + fqn + ">((l, r, c) => " + helper + "(l, r, c));");
        }
        w.Close();
        w.Line();

        if (root.Type.IsValueType)
        {
            w.Open(accessibility + " static bool AreDeepEqual(" + rootFqn + " left, " + rootFqn + " right)");
        }
        else
        {
            w.Open(accessibility + " static bool AreDeepEqual(" + rootFqn + "? left, " + rootFqn + "? right)");
        }

        if (!root.Type.IsValueType)
        {
            w.Open("if (object.ReferenceEquals(left, right))");
            w.Line("return true;");
            w.Close();
            w.Open("if (left is null || right is null)");
            w.Line("return false;");
            w.Close();
        }

        w.Line("var context = " +
               (trackCycles
                   ? "new DeepEqual.Generator.Shared.ComparisonContext()"
                   : "DeepEqual.Generator.Shared.ComparisonContext.NoTracking") + ";");
        w.Line("return " + GetHelperMethodName(root.Type) + "(left, right, context);");
        w.Close();
        w.Line();

        if (root.Type.IsValueType)
        {
            w.Open(accessibility + " static bool AreDeepEqual(" + rootFqn + " left, " + rootFqn +
                   " right, DeepEqual.Generator.Shared.ComparisonOptions options)");
        }
        else
        {
            w.Open(accessibility + " static bool AreDeepEqual(" + rootFqn + "? left, " + rootFqn +
                   "? right, DeepEqual.Generator.Shared.ComparisonOptions options)");
        }

        if (!root.Type.IsValueType)
        {
            w.Open("if (object.ReferenceEquals(left, right))");
            w.Line("return true;");
            w.Close();
            w.Open("if (left is null || right is null)");
            w.Line("return false;");
            w.Close();
        }

        w.Line("var context = new DeepEqual.Generator.Shared.ComparisonContext(options);");
        w.Line("return " + GetHelperMethodName(root.Type) + "(left, right, context);");
        w.Close();
        w.Line();

        if (root.Type.IsValueType)
        {
            w.Open(accessibility + " static bool AreDeepEqual(" + rootFqn + " left, " + rootFqn +
                   " right, DeepEqual.Generator.Shared.ComparisonContext context)");
        }
        else
        {
            w.Open(accessibility + " static bool AreDeepEqual(" + rootFqn + "? left, " + rootFqn +
                   "? right, DeepEqual.Generator.Shared.ComparisonContext context)");
        }

        if (!root.Type.IsValueType)
        {
            w.Open("if (object.ReferenceEquals(left, right))");
            w.Line("return true;");
            w.Close();
            w.Open("if (left is null || right is null)");
            w.Line("return false;");
            w.Close();
        }

        w.Line("return " + GetHelperMethodName(root.Type) + "(left, right, context);");
        w.Close();
        w.Line();

        var emittedComparers = new HashSet<string>(StringComparer.Ordinal);
        var comparerDeclarations = new List<string[]>();

        foreach (var t in reachable.OrderBy(t => t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                     StringComparer.Ordinal))
        {
            EmitHelperForType(w, t, root, trackCycles, emittedComparers, comparerDeclarations, spc);
        }

        if (comparerDeclarations.Count > 0)
        {
            foreach (var block in comparerDeclarations)
            {
                foreach (var line in block)
                {
                    w.Line(line);
                }
            }
        }

        w.Close();

        if (ns is not null)
        {
            w.Close();
        }

        spc.AddSource(hintName, w.ToString());
    }

    private void EmitHelperForType(CodeWriter w, INamedTypeSymbol type, Target root, bool trackCycles,
        HashSet<string> emittedComparers, List<string[]> comparerDeclarations, SourceProductionContext spc)
    {
        var fqn = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var helper = GetHelperMethodName(type);
        w.Open("private static bool " + helper + "(" + fqn + " left, " + fqn +
               " right, DeepEqual.Generator.Shared.ComparisonContext context)");

        if (!type.IsValueType)
        {
            w.Open("if (object.ReferenceEquals(left, right))");
            w.Line("return true;");
            w.Close();
            w.Open("if (left is null || right is null)");
            w.Line("return false;");
            w.Close();

            if (trackCycles)
            {
                w.Open("if (!context.Enter(left, right))");
                w.Line("return true;");
                w.Close();
                w.Open("try");
            }
        }

        var schema = GetTypeSchema(type);
        var __inc = schema.IncludeMembers;
        var __ign = schema.IgnoreMembers;
        if (__inc.Count > 0 && __ign.Count > 0)
        {
            for (int __i = 0; __i < __inc.Count; __i++)
            {
                var __name = __inc[__i];
                if (__ign.Contains(__name, System.StringComparer.Ordinal))
                {
                    var __attr = type.GetAttributes().FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);
                    var __loc = __attr?.ApplicationSyntaxReference?.GetSyntax(spc.CancellationToken)?.GetLocation() ?? type.Locations.FirstOrDefault();
                    if (__loc is not null)
                        spc.ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic.Create(Diagnostics.EQ001, __loc, __name));
                    break;
                }
            }
        }
        if (__inc.Count > 0 && __ign.Count > 0)
        {
            for (int __i = 0; __i < __inc.Count; __i++)
            {
                var __name = __inc[__i];
                if (__ign.Contains(__name, System.StringComparer.Ordinal))
                {
                    var __attr = type.GetAttributes().FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);
                    var __loc = __attr?.ApplicationSyntaxReference?.GetSyntax(spc.CancellationToken)?.GetLocation() ?? type.Locations.FirstOrDefault();
                    if (__loc is not null)
                        spc.ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic.Create(Diagnostics.EQ001, __loc, __name));
                    break;
                }
            }
        }

        foreach (var member in OrderMembers(EnumerateMembers(type, root.IncludeInternals, root.IncludeBaseMembers, schema)))
        {
            EmitMember(w, type, member, root, emittedComparers, comparerDeclarations, spc);
        }

        w.Line("return true;");
        if (!type.IsValueType && trackCycles)
        {
            w.Close();
            w.Open("finally");
            w.Line("context.Exit(left, right);");
            w.Close();
        }

        w.Close();
        w.Line();
    }

    private void EmitMember(CodeWriter w, INamedTypeSymbol owner, MemberSymbol member, Target root,
        HashSet<string> emittedComparers, List<string[]> comparerDeclarations, SourceProductionContext spc)
    {
        var leftExpr = "left." + member.Name;
        var rightExpr = "right." + member.Name;
        var deepAttr = GetDeepCompareAttribute(member.Symbol);
        var kind = GetEffectiveKind(member.Type, deepAttr);
        {
            var __all = member.Symbol.GetAttributes().Where(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName).ToArray();
            if (__all.Length > 1)
            {
                var __loc = __all[0].ApplicationSyntaxReference?.GetSyntax(spc.CancellationToken)?.GetLocation() ?? member.Symbol.Locations.FirstOrDefault();
                if (__loc is not null)
                    spc.ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic.Create(Diagnostics.EQ001, __loc, member.Name));
            }
            if (kind == EffectiveKind.Deep)
            {
                var __t = member.Type;
                if (__t is INamedTypeSymbol __n && IsUserObjectType(__n) && !IsTypeAccessibleFromRoot(__n, root))
                {
                    var __attr = __all.FirstOrDefault();
                    var __loc2 = __attr?.ApplicationSyntaxReference?.GetSyntax(spc.CancellationToken)?.GetLocation() ?? member.Symbol.Locations.FirstOrDefault();
                    if (__loc2 is not null)
                        spc.ReportDiagnostic(Microsoft.CodeAnalysis.Diagnostic.Create(Diagnostics.EQ002, __loc2, __n.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)));
                }
            }
        }

        if (kind == EffectiveKind.Skip)
        {
            w.Line();
            return;
        }

        if (!member.Type.IsValueType)
        {
            w.Open("if (!object.ReferenceEquals(" + leftExpr + ", " + rightExpr + "))");
            w.Open("if (" + leftExpr + " is null || " + rightExpr + " is null)");
            w.Line("return false;");
            w.Close();
            w.Close();
        }

        if (kind == EffectiveKind.Reference)
        {
            w.Open("if (!object.ReferenceEquals(" + leftExpr + ", " + rightExpr + "))");
            w.Line("return false;");
            w.Close();
            w.Line();
            return;
        }

        var directCustomCmp = GetEffectiveComparerType(member.Type, deepAttr);
        if (directCustomCmp is not null)
        {
            var cmpFqn = directCustomCmp.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var tFqn = member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var customVar = "__cmp_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
            w.Line("var " + customVar + " = (System.Collections.Generic.IEqualityComparer<" + tFqn +
                   ">)System.Activator.CreateInstance(typeof(" + cmpFqn + "))!;");
            w.Open("if (!" + customVar + ".Equals(" + leftExpr + ", " + rightExpr + "))");
            w.Line("return false;");
            w.Close();
            w.Line();
            return;
        }

        if (kind == EffectiveKind.Shallow)
        {
            w.Open("if (!object.Equals(" + leftExpr + ", " + rightExpr + "))");
            w.Line("return false;");
            w.Close();
            w.Line();
            return;
        }

        if (member.Type is INamedTypeSymbol nnt0 && nnt0.OriginalDefinition.ToDisplayString() == "System.Nullable<T>")
        {
            var valueT = nnt0.TypeArguments[0];
            var customCmpT = GetEffectiveComparerType(valueT, deepAttr);
            string? customVar = null;
            if (customCmpT is not null)
            {
                var cmpFqn = customCmpT.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var elFqn2 = valueT.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                customVar = "__cmp_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
                w.Line("var " + customVar + " = (System.Collections.Generic.IEqualityComparer<" + elFqn2 +
                       ">)System.Activator.CreateInstance(typeof(" + cmpFqn + "))!;");
            }

            w.Open("if (" + leftExpr + ".HasValue != " + rightExpr + ".HasValue)");
            w.Line("return false;");
            w.Close();
            w.Open("if (" + leftExpr + ".HasValue)");
            if (customVar is not null)
            {
                w.Open("if (!" + customVar + ".Equals(" + leftExpr + ".Value, " + rightExpr + ".Value))");
                w.Line("return false;");
                w.Close();
            }
            else
            {
                EmitNullableValueCompare_NoCustom(w, leftExpr, rightExpr, valueT);
            }

            w.Close();
            w.Line();
            return;
        }

        if (TryEmitWellKnownStructCompare(w, leftExpr, rightExpr, member.Type))
        {
            w.Line();
            return;
        }

        if (member.Type.SpecialType == SpecialType.System_String)
        {
            w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualStrings(" + leftExpr + ", " + rightExpr +
                   ", context))");
            w.Line("return false;");
            w.Close();
            w.Line();
            return;
        }

        if (member.Type.TypeKind == TypeKind.Enum)
        {
            var enumFqn = member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualEnum<" + enumFqn + ">(" + leftExpr +
                   ", " + rightExpr + "))");
            w.Line("return false;");
            w.Close();
            w.Line();
            return;
        }

        if (IsNumericWithTolerance(member.Type))
        {
            var call = GetNumericCall(member.Type, leftExpr, rightExpr, "context");
            w.Open("if (!" + call + ")");
            w.Line("return false;");
            w.Close();
            w.Line();
            return;
        }

        if (TryGetReadOnlyMemory(member.Type, out var romEl))
        {
            var elFqn = romEl!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var elKind = GetEffectiveKind(romEl, null);
            var elemCustomCmpT = GetEffectiveComparerType(romEl, deepAttr);
            string? elemCustomVar = null;
            if (elemCustomCmpT is not null)
            {
                var cmpFqn = elemCustomCmpT.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                elemCustomVar = "__cmpE_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
                w.Line("var " + elemCustomVar + " = (System.Collections.Generic.IEqualityComparer<" + elFqn +
                       ">)System.Activator.CreateInstance(typeof(" + cmpFqn + "))!;");
            }

            var cmpName = EnsureComparerStruct(emittedComparers, comparerDeclarations, romEl, elKind,
                "M_" + GenCommon.SanitizeIdentifier(owner.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)) + "_" +
                member.Name, elemCustomVar);
            w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualReadOnlyMemory<" + elFqn + ", " +
                   cmpName + ">(" + leftExpr + ", " + rightExpr + ", new " + cmpName + "(" + (elemCustomVar ?? "") +
                   "), context))");
            w.Line("return false;");
            w.Close();
            w.Line();
            return;
        }

        if (TryGetMemory(member.Type, out var memEl))
        {
            var elFqn = memEl!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var elKind = GetEffectiveKind(memEl, null);
            var elemCustomCmpT = GetEffectiveComparerType(memEl, deepAttr);
            string? elemCustomVar = null;
            if (elemCustomCmpT is not null)
            {
                var cmpFqn = elemCustomCmpT.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                elemCustomVar = "__cmpE_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
                w.Line("var " + elemCustomVar + " = (System.Collections.Generic.IEqualityComparer<" + elFqn +
                       ">)System.Activator.CreateInstance(typeof(" + cmpFqn + "))!;");
            }

            var cmpName = EnsureComparerStruct(emittedComparers, comparerDeclarations, memEl, elKind,
                "M_" + GenCommon.SanitizeIdentifier(owner.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)) + "_" +
                member.Name, elemCustomVar);
            w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualMemory<" + elFqn + ", " + cmpName + ">(" +
                   leftExpr + ", " + rightExpr + ", new " + cmpName + "(" + (elemCustomVar ?? "") + "), context))");
            w.Line("return false;");
            w.Close();
            w.Line();
            return;
        }

        if (member.Type.IsValueType && member.Type.SpecialType != SpecialType.None)
        {
            w.Open("if (!" + leftExpr + ".Equals(" + rightExpr + "))");
            w.Line("return false;");
            w.Close();
            w.Line();
            return;
        }

        if (member.Type is IArrayTypeSymbol arr)
        {
            var el = arr.ElementType;
            var elFqn = el.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var unordered = arr.Rank == 1 && ResolveOrderInsensitive(root, deepAttr, el, owner);
            var elKind = GetEffectiveKind(el, null);

            var elemCustomCmpT = GetEffectiveComparerType(el, deepAttr);
            string? elemCustomVar = null;
            if (elemCustomCmpT is not null)
            {
                var cmpFqn = elemCustomCmpT.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                elemCustomVar = "__cmpE_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
                w.Line("var " + elemCustomVar + " = (System.Collections.Generic.IEqualityComparer<" + elFqn +
                       ">)System.Activator.CreateInstance(typeof(" + cmpFqn + "))!;");
            }

            var cmpName = EnsureComparerStruct(emittedComparers, comparerDeclarations, el, elKind,
                "M_" + GenCommon.SanitizeIdentifier(owner.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)) + "_" +
                member.Name, elemCustomVar);

            if (unordered && TryGetKeySpec(el, deepAttr, root, out var keyTypeFqn,
                    out var keyExprFmt))
            {
                var listA = "__listA_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
                var listB = "__listB_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
                var dictA = "__ka_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
                var dictB = "__kb_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
                var tmpA = "__eA_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
                var tmpB = "__eB_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);

                w.Line("var " + listA + " = " + leftExpr + " as System.Collections.Generic.IReadOnlyList<" + elFqn +
                       ">;");
                w.Line("var " + listB + " = " + rightExpr + " as System.Collections.Generic.IReadOnlyList<" + elFqn +
                       ">;");

                w.Open("if (!object.ReferenceEquals(" + listA + ", " + listB + "))");
                w.Open("if (" + listA + " is null || " + listB + " is null)");
                w.Line("return false;");
                w.Close();

                w.Line("var " + dictA + " = new System.Collections.Generic.Dictionary<" + keyTypeFqn +
                       ", System.Collections.Generic.List<" + elFqn + ">>();");
                w.Line("var " + dictB + " = new System.Collections.Generic.Dictionary<" + keyTypeFqn +
                       ", System.Collections.Generic.List<" + elFqn + ">>();");

                w.Open("for (int __i = 0; __i < " + listA + ".Count; __i++)");
                w.Line("var " + tmpA + " = " + listA + "[__i];");
                w.Line("var __k = " + string.Format(keyExprFmt, tmpA) + ";");
                w.Open("if (!" + dictA + ".TryGetValue(__k, out var __lst))");
                w.Line("__lst = " + dictA + "[__k] = new System.Collections.Generic.List<" + elFqn + ">();");
                w.Close();
                w.Line("__lst.Add(" + tmpA + ");");
                w.Close();
                w.Open("for (int __j = 0; __j < " + listB + ".Count; __j++)");
                w.Line("var " + tmpB + " = " + listB + "[__j];");
                w.Line("var __k = " + string.Format(keyExprFmt, tmpB) + ";");
                w.Open("if (!" + dictB + ".TryGetValue(__k, out var __lst))");
                w.Line("__lst = " + dictB + "[__k] = new System.Collections.Generic.List<" + elFqn + ">();");
                w.Close();
                w.Line("__lst.Add(" + tmpB + ");");
                w.Close();
                w.Line("if (" + dictA + ".Count != " + dictB + ".Count) return false;");
                w.Open("foreach (var __kv in " + dictA + ")");
                w.Open("if (!" + dictB + ".TryGetValue(__kv.Key, out var __lstB)) return false;");
                w.Line("if (__kv.Value.Count != __lstB.Count) return false;");
                w.Line("var __m = new bool[__lstB.Count];");
                w.Line("var __cmp = new " + cmpName + "(" + (elemCustomVar ?? "") + ");");
                w.Open("for (int __x = 0; __x < __kv.Value.Count; __x++)");
                w.Line("bool __f = false;");
                w.Open("for (int __y = 0; __y < __lstB.Count; __y++)");
                w.Open("if (!__m[__y])");
                w.Open("if (__cmp.Invoke(__kv.Value[__x], __lstB[__y], context))");
                w.Line("__m[__y] = (__f = true);");
                w.Close();
                w.Close();
                w.Close();
                w.Open("if (!__f)");
                w.Line("return false;");
                w.Close();
                w.Close();
                w.Close();
                w.Close();
            }
            else if (unordered && IsHashFriendly(el))
            {
                var eqExpr = GetEqualityComparerExprForHash(el, "context", elemCustomVar);
                var la = leftExpr;
                var lb = rightExpr;

                w.Open("if (!object.ReferenceEquals(" + la + ", " + lb + "))");
                w.Open("if (" + la + " is null || " + lb + " is null)");
                w.Line("return false;");
                w.Close();
                w.Open("if (" + la + ".Length != " + lb + ".Length)");
                w.Line("return false;");
                w.Close();
                w.Line("var __ra = new System.Collections.Generic.List<" + elFqn + ">(" + la + ");");
                w.Line("var __rb = new System.Collections.Generic.List<" + elFqn + ">(" + lb + ");");
                w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualSequencesUnorderedHash(__ra, __rb, " +
                       eqExpr + "))");
                w.Line("return false;");
                w.Close();
                w.Close();
            }
            else
            {
                if (unordered)
                {
                    w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualArrayUnordered<" + elFqn + ", " +
                           cmpName + ">((Array?)" + leftExpr + ", (Array?)" + rightExpr + ", new " + cmpName + "(" +
                           (elemCustomVar ?? "") + "), context))");
                    w.Line("return false;");
                    w.Close();
                }
                else
                {
                    if (arr.Rank == 1)
                    {
                        w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualArrayRank1<" + elFqn + ", " +
                               cmpName + ">(" + leftExpr + " as " + elFqn + "[], " + rightExpr + " as " + elFqn +
                               "[], new " + cmpName + "(" + (elemCustomVar ?? "") + "), context))");
                        w.Line("return false;");
                        w.Close();
                    }
                    else
                    {
                        w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualArray<" + elFqn + ", " +
                               cmpName + ">((Array?)" + leftExpr + ", (Array?)" + rightExpr + ", new " + cmpName + "(" +
                               (elemCustomVar ?? "") + "), context))");
                        w.Line("return false;");
                        w.Close();
                    }
                }
            }

            w.Line();
            return;
        }

        if (TryGetDictionaryInterface(member.Type, out var keyT, out var valT))
        {
            var kFqn = keyT!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var vFqn = valT!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var vKind = GetEffectiveKind(valT, null);

            var valCustomCmpT = GetEffectiveComparerType(valT, deepAttr);
            string? valCustomVar = null;
            if (valCustomCmpT is not null)
            {
                var cmpFqn = valCustomCmpT.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                valCustomVar = "__cmpV_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
                w.Line("var " + valCustomVar + " = (System.Collections.Generic.IEqualityComparer<" + vFqn +
                       ">)System.Activator.CreateInstance(typeof(" + cmpFqn + "))!");
            }

            var lro = "__roMapA_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
            var rro = "__roMapB_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
            w.Line("var " + lro + " = " + leftExpr + " as global::System.Collections.Generic.IDictionary<" +
                   kFqn + ", " + vFqn + ">;");
            w.Line("var " + rro + " = " + rightExpr + " as global::System.Collections.Generic.IDictionary<" +
                   kFqn + ", " + vFqn + ">;");
            w.Open("if (" + lro + " is not null && " + rro + " is not null)");
            w.Open("if (" + lro + ".Count != " + rro + ".Count)");
            w.Line("return false;");
            w.Close();

            w.Open("foreach (var __kv in " + lro + ")");
            w.Open("if (!" + rro + ".TryGetValue(__kv.Key, out var __rv))");
            w.Line("return false;");
            w.Close();

            if (TryGetReadOnlyMemory(valT, out var romVal))
            {
                var elFqn = romVal!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var elKind = GetEffectiveKind(romVal, null);
                var cmpName = EnsureComparerStruct(emittedComparers, comparerDeclarations, romVal, elKind,
                    "M_" + GenCommon.SanitizeIdentifier(owner.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)) + "_" +
                    member.Name + "_Val", valCustomVar);
                w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualReadOnlyMemory<" + elFqn + ", " +
                       cmpName + ">(__kv.Value, __rv, new " + cmpName + "(" + (valCustomVar ?? "") + "), context))");
                w.Line("return false;");
                w.Close();
            }
            else if (TryGetMemory(valT, out var mVal))
            {
                var elFqn = mVal!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var elKind = GetEffectiveKind(mVal, null);
                var cmpName = EnsureComparerStruct(emittedComparers, comparerDeclarations, mVal, elKind,
                    "M_" + GenCommon.SanitizeIdentifier(owner.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)) + "_" +
                    member.Name + "_Val", valCustomVar);
                w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualMemory<" + elFqn + ", " + cmpName +
                       ">(__kv.Value, __rv, new " + cmpName + "(" + (valCustomVar ?? "") + "), context))");
                w.Line("return false;");
                w.Close();
            }
            else
            {
                var vExpr = BuildInlineCompareExpr("__kv.Value", "__rv", valT, vKind, "context", valCustomVar);
                w.Open("if (!(" + vExpr + "))");
                w.Line("return false;");
                w.Close();
            }

            w.Close();
            w.Line("return true;");
            w.Close();
            var lrw = "__rwMapA_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
            var rrw = "__rwMapB_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
            w.Line("var " + lrw + " = " + leftExpr + " as global::System.Collections.Generic.IDictionary<" + kFqn +
                   ", " + vFqn + ">;");
            w.Line("var " + rrw + " = " + rightExpr + " as global::System.Collections.Generic.IDictionary<" + kFqn +
                   ", " + vFqn + ">;");
            w.Open("if (" + lrw + " is not null && " + rrw + " is not null)");
            w.Open("if (" + lrw + ".Count != " + rrw + ".Count)");
            w.Line("return false;");
            w.Close();

            w.Open("foreach (var __kv in " + lrw + ")");
            w.Open("if (!" + rrw + ".TryGetValue(__kv.Key, out var __rv))");
            w.Line("return false;");
            w.Close();

            if (TryGetReadOnlyMemory(valT, out var romVal2))
            {
                var elFqn = romVal2!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var elKind = GetEffectiveKind(romVal2, null);
                var cmpName = EnsureComparerStruct(emittedComparers, comparerDeclarations, romVal2, elKind,
                    "M_" + GenCommon.SanitizeIdentifier(owner.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)) + "_" +
                    member.Name + "_Val", valCustomVar);
                w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualReadOnlyMemory<" + elFqn + ", " +
                       cmpName + ">(__kv.Value, __rv, new " + cmpName + "(" + (valCustomVar ?? "") + "), context))");
                w.Line("return false;");
                w.Close();
            }
            else if (TryGetMemory(valT, out var mVal2))
            {
                var elFqn = mVal2!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var elKind = GetEffectiveKind(mVal2, null);
                var cmpName = EnsureComparerStruct(emittedComparers, comparerDeclarations, mVal2, elKind,
                    "M_" + GenCommon.SanitizeIdentifier(owner.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)) + "_" +
                    member.Name + "_Val", valCustomVar);
                w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualMemory<" + elFqn + ", " + cmpName +
                       ">(__kv.Value, __rv, new " + cmpName + "(" + (valCustomVar ?? "") + "), context))");
                w.Line("return false;");
                w.Close();
            }
            else
            {
                var vExpr2 = BuildInlineCompareExpr("__kv.Value", "__rv", valT, vKind, "context", valCustomVar);
                w.Open("if (!(" + vExpr2 + "))");
                w.Line("return false;");
                w.Close();
            }

            w.Close();
            w.Line("return true;");
            w.Close();
            var cmpAny = EnsureComparerStruct(emittedComparers, comparerDeclarations, valT, vKind,
                "M_" + GenCommon.SanitizeIdentifier(owner.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)) + "_" +
                member.Name + "_Val", valCustomVar);
            w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualDictionariesAny<" + kFqn + ", " + vFqn +
                   ", " + cmpAny + ">(" + leftExpr + ", " + rightExpr + ", new " + cmpAny + "(" + (valCustomVar ?? "") +
                   "), context))");
            w.Line("return false;");
            w.Close();

            w.Line();
            return;
        }

        if (TryGetEnumerableInterface(member.Type, out var elT))
        {
            var elFqn = elT!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var elKind = GetEffectiveKind(elT, null);
            var unordered = ResolveOrderInsensitive(root, deepAttr, elT, owner);

            var elemCustomCmpT = GetEffectiveComparerType(elT, deepAttr);
            string? elemCustomVar = null;
            if (elemCustomCmpT is not null)
            {
                var cmpFqn = elemCustomCmpT.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                elemCustomVar = "__cmpE_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
                w.Line("var " + elemCustomVar + " = (System.Collections.Generic.IEqualityComparer<" + elFqn +
                       ">)System.Activator.CreateInstance(typeof(" + cmpFqn + "))!;");
            }

            if (unordered &&
                TryGetKeySpec(elT, deepAttr, root, out var keyTypeFqn2, out var keyExprFmt2) &&
                IsUserObjectType(elT))
            {
                var la = "__seqA_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
                var lb = "__seqB_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
                var da = "__dictA_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
                var db = "__dictB_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
                var tmpA = "__eA_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
                var tmpB = "__eB_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
                var cmpName = EnsureComparerStruct(
                    emittedComparers, comparerDeclarations, elT, elKind,
                    "M_" + GenCommon.SanitizeIdentifier(owner.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)) + "_" +
                    member.Name,
                    elemCustomVar);

                w.Line("var " + la + " = " + leftExpr + " as System.Collections.Generic.IEnumerable<" + elFqn + ">;");
                w.Line("var " + lb + " = " + rightExpr + " as System.Collections.Generic.IEnumerable<" + elFqn + ">;");

                w.Open("if (!object.ReferenceEquals(" + la + ", " + lb + "))");
                w.Open("if (" + la + " is null || " + lb + " is null)");
                w.Line("return false;");
                w.Close();

                w.Line("var " + da + " = new System.Collections.Generic.Dictionary<" + keyTypeFqn2 +
                       ", System.Collections.Generic.List<" + elFqn + ">>();");
                w.Line("var " + db + " = new System.Collections.Generic.Dictionary<" + keyTypeFqn2 +
                       ", System.Collections.Generic.List<" + elFqn + ">>();");

                w.Open("foreach (var " + tmpA + " in " + la + ")");
                w.Line("var __k = " + string.Format(keyExprFmt2, tmpA) + ";");
                w.Open("if (!" + da + ".TryGetValue(__k, out var __lst))");
                w.Line("__lst = " + da + "[__k] = new System.Collections.Generic.List<" + elFqn + ">();");
                w.Close();
                w.Line("__lst.Add(" + tmpA + ");");
                w.Close();
                w.Open("foreach (var " + tmpB + " in " + lb + ")");
                w.Line("var __k = " + string.Format(keyExprFmt2, tmpB) + ";");
                w.Open("if (!" + db + ".TryGetValue(__k, out var __lst))");
                w.Line("__lst = " + db + "[__k] = new System.Collections.Generic.List<" + elFqn + ">();");
                w.Close();
                w.Line("__lst.Add(" + tmpB + ");");
                w.Close();
                w.Line("if (" + da + ".Count != " + db + ".Count) return false;");
                w.Open("foreach (var __kv in " + da + ")");
                w.Open("if (!" + db + ".TryGetValue(__kv.Key, out var __lstB))");
                w.Line("return false;");
                w.Close();
                w.Line("if (__kv.Value.Count != __lstB.Count) return false;");
                w.Line("var __m = new bool[__lstB.Count];");
                w.Line("var __cmp = new " + cmpName + "(" + (elemCustomVar ?? "") + ");");

                w.Open("for (int __x = 0; __x < __kv.Value.Count; __x++)");
                w.Line("bool __f = false;");
                w.Open("for (int __y = 0; __y < __lstB.Count; __y++)");
                w.Open("if (!__m[__y])");
                w.Open("if (__cmp.Invoke(__kv.Value[__x], __lstB[__y], context))");
                w.Line("__m[__y] = (__f = true);");
                w.Close();
                w.Close();
                w.Close();
                w.Open("if (!__f)");
                w.Line("return false;");
                w.Close();
                w.Close();
                w.Close();
                w.Close();
                w.Line();
                return;
            }

            if (unordered && IsHashFriendly(elT))
            {
                var la = "__seqA_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
                var lb = "__seqB_" + GenCommon.SanitizeIdentifier(owner.Name) + "_" + GenCommon.SanitizeIdentifier(member.Name);
                var eqExpr = GetEqualityComparerExprForHash(elT, "context", elemCustomVar);

                w.Line("var " + la + " = " + leftExpr + " as System.Collections.Generic.IEnumerable<" + elFqn + ">;");
                w.Line("var " + lb + " = " + rightExpr + " as System.Collections.Generic.IEnumerable<" + elFqn + ">;");

                w.Open("if (!object.ReferenceEquals(" + la + ", " + lb + "))");
                w.Open("if (" + la + " is null || " + lb + " is null)");
                w.Line("return false;");
                w.Close();

                w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualSequencesUnorderedHash<" + elFqn +
                       ">(" + la + ", " + lb + ", " + eqExpr + "))");
                w.Line("return false;");
                w.Close();

                w.Close();
            }
            else
            {
                var cmpName = EnsureComparerStruct(emittedComparers, comparerDeclarations, elT, elKind,
                    "M_" + GenCommon.SanitizeIdentifier(owner.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)) + "_" +
                    member.Name, elemCustomVar);
                var api = unordered ? "AreEqualSequencesUnordered" : "AreEqualSequencesOrdered";
                w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers." + api + "<" + elFqn + ", " + cmpName +
                       ">(" + leftExpr + " as IEnumerable<" + elFqn + ">, " + rightExpr + " as IEnumerable<" + elFqn +
                       ">, new " + cmpName + "(" + (elemCustomVar ?? "") + "), context))");
                w.Line("return false;");
                w.Close();
            }

            w.Line();
            return;
        }

        if ((member.Type.TypeKind == TypeKind.Interface || member.Type is INamedTypeSymbol { IsAbstract: true })
            && !(TryGetDictionaryInterface(member.Type, out _, out _) || TryGetEnumerableInterface(member.Type, out _)))
        {
            var declFqn = member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic<" + declFqn + ">(" +
                   leftExpr + ", " + rightExpr + ", context))");
            w.Line("return false;");
            w.Close();
            w.Line();
            return;
        }

        if (member.Type.SpecialType == SpecialType.System_Object)
        {
            w.Open("if (!DeepEqual.Generator.Shared.DynamicDeepComparer.AreEqualDynamic(" + leftExpr + ", " +
                   rightExpr + ", context))");
            w.Line("return false;");
            w.Close();
            w.Line();
            return;
        }

        if (member.Type is INamedTypeSymbol nts && IsUserObjectType(nts))
        {
            var helperExpr = "DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic<" +
                             nts.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) + ">(" + leftExpr + ", " +
                             rightExpr + ", context)";
            w.Open("if (!(" + helperExpr + "))");
            w.Line("return false;");
            w.Close();
            w.Line();
            return;
        }

        w.Open("if (!object.Equals(" + leftExpr + ", " + rightExpr + "))");
        w.Line("return false;");
        w.Close();
        w.Line();
    }

    private void EmitNullableValueCompare_NoCustom(CodeWriter w, string leftExpr, string rightExpr, ITypeSymbol valueType)
    {
        if (TryEmitWellKnownStructCompare(w, leftExpr + ".Value", rightExpr + ".Value", valueType))
        {
            return;
        }

        if (valueType.TypeKind == TypeKind.Enum)
        {
            var enumFqn = valueType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualEnum<" + enumFqn + ">(" + leftExpr +
                   ".Value, " + rightExpr + ".Value))");
            w.Line("return false;");
            w.Close();
            return;
        }

        if (valueType.SpecialType == SpecialType.System_String)
        {
            w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualStrings(" + leftExpr + ".Value, " +
                   rightExpr + ".Value, context))");
            w.Line("return false;");
            w.Close();
            return;
        }

        if (IsNumericWithTolerance(valueType))
        {
            var call = GetNumericCall(valueType, leftExpr + ".Value", rightExpr + ".Value", "context");
            w.Open("if (!" + call + ")");
            w.Line("return false;");
            w.Close();
            return;
        }

        if (valueType.IsValueType && valueType.SpecialType != SpecialType.None)
        {
            w.Open("if (!" + leftExpr + ".Value.Equals(" + rightExpr + ".Value))");
            w.Line("return false;");
            w.Close();
            return;
        }

        if (valueType is INamedTypeSymbol namedTypeSymbol && IsUserObjectType(namedTypeSymbol))
        {
            var helperExpr = "DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic<" +
                             namedTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) + ">(" + leftExpr +
                             ".Value, " + rightExpr + ".Value, context)";
            w.Open("if (!(" + helperExpr + "))");
            w.Line("return false;");
            w.Close();
            return;
        }

        w.Open("if (!object.Equals(" + leftExpr + ".Value, " + rightExpr + ".Value))");
        w.Line("return false;");
        w.Close();
    }

    private bool TryEmitWellKnownStructCompare(CodeWriter w, string leftExpr, string rightExpr, ITypeSymbol type)
    {
        if (type.SpecialType == SpecialType.System_DateTime)
        {
            w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualDateTime(" + leftExpr + ", " + rightExpr +
                   "))");
            w.Line("return false;");
            w.Close();
            return true;
        }

        var fqn = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        if (fqn == "global::System.DateTimeOffset")
        {
            w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualDateTimeOffset(" + leftExpr + ", " +
                   rightExpr + "))");
            w.Line("return false;");
            w.Close();
            return true;
        }

        if (fqn == "global::System.TimeSpan")
        {
            w.Open("if (" + leftExpr + ".Ticks != " + rightExpr + ".Ticks)");
            w.Line("return false;");
            w.Close();
            return true;
        }

        if (fqn == "global::System.Guid")
        {
            w.Open("if (!" + leftExpr + ".Equals(" + rightExpr + "))");
            w.Line("return false;");
            w.Close();
            return true;
        }

        if (fqn == "global::System.DateOnly")
        {
            w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualDateOnly(" + leftExpr + ", " + rightExpr +
                   "))");
            w.Line("return false;");
            w.Close();
            return true;
        }

        if (fqn == "global::System.TimeOnly")
        {
            w.Open("if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualTimeOnly(" + leftExpr + ", " + rightExpr +
                   "))");
            w.Line("return false;");
            w.Close();
            return true;
        }

        return false;
    }

    private string EnsureComparerStruct(HashSet<string> emitted, List<string[]> declarations, ITypeSymbol elementType,
        EffectiveKind elementKind, string hint, string? customComparerVar = null)
    {
        var elFqn = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var cmpName = "__Cmp__" + GenCommon.SanitizeIdentifier(elFqn) + "__" + hint;
        if (!emitted.Add(cmpName))
        {
            return cmpName;
        }

        if (customComparerVar is not null)
        {
            var linesX = new List<string>
                {
                    "private readonly struct " + cmpName + " : DeepEqual.Generator.Shared.IElementComparer<" + elFqn + ">",
                    "{",
                    "    private readonly System.Collections.Generic.IEqualityComparer<" + elFqn + "> __c;",
                    "    public " + cmpName + "(System.Collections.Generic.IEqualityComparer<" + elFqn +
                    "> c) { __c = c; }",
                    "    public bool Invoke(" + elFqn + " l, " + elFqn +
                    " r, DeepEqual.Generator.Shared.ComparisonContext c) { return __c.Equals(l, r); }",
                    "}",
                    ""
                };
            declarations.Add(linesX.ToArray());
            return cmpName;
        }

        var expr = BuildInlineCompareExpr("l", "r", elementType, elementKind);
        var lines = new List<string>
            {
                "private readonly struct " + cmpName + " : DeepEqual.Generator.Shared.IElementComparer<" + elFqn + ">",
                "{",
                "    public " + cmpName + "(" + "System.Collections.Generic.IEqualityComparer<" + elFqn + "> _ = null) {}",
                "    [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining | System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]",
                "    public bool Invoke(" + elFqn + " l, " + elFqn + " r, DeepEqual.Generator.Shared.ComparisonContext c)",
                "    {",
                "        return " + expr + ";",
                "    }",
                "}",
                ""
            };
        declarations.Add(lines.ToArray());
        return cmpName;
    }

    private string BuildInlineCompareExpr(string l, string r, ITypeSymbol type, EffectiveKind kind,
        string ctxVar = "c", string? customEqVar = null)
    {
        if (customEqVar is not null)
        {
            return customEqVar + ".Equals(" + l + ", " + r + ")";
        }

        if (kind == EffectiveKind.Reference)
        {
            return "object.ReferenceEquals(" + l + ", " + r + ")";
        }

        if (kind == EffectiveKind.Shallow)
        {
            return "object.Equals(" + l + ", " + r + ")";
        }

        if (type is INamedTypeSymbol nt && nt.OriginalDefinition.ToDisplayString() == "System.Nullable<T>")
        {
            var tArg = nt.TypeArguments[0];
            var inner = BuildInlineCompareExpr(l + ".Value", r + ".Value", tArg, GetEffectiveKind(tArg, null), ctxVar, customEqVar);
            return "(" + l + ".HasValue == " + r + ".HasValue) && (!" + l + ".HasValue || (" + inner + "))";
        }

        if (type.SpecialType == SpecialType.System_String)
        {
            return "DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualStrings(" + l + ", " + r + ", " + ctxVar + ")";
        }

        if (type.TypeKind == TypeKind.Enum)
        {
            var enumFqn = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            return "DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualEnum<" + enumFqn + ">(" + l + ", " + r + ")";
        }

        if (type.SpecialType == SpecialType.System_DateTime)
        {
            return "DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualDateTime(" + l + ", " + r + ")";
        }

        var fqn = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        if (fqn == "global::System.DateTimeOffset")
        {
            return "DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualDateTimeOffset(" + l + ", " + r + ")";
        }

        if (fqn == "global::System.TimeSpan")
        {
            return l + ".Ticks == " + r + ".Ticks";
        }

        if (fqn == "global::System.Guid")
        {
            return l + ".Equals(" + r + ")";
        }

        if (fqn == "global::System.DateOnly")
        {
            return "DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualDateOnly(" + l + ", " + r + ")";
        }

        if (fqn == "global::System.TimeOnly")
        {
            return "DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualTimeOnly(" + l + ", " + r + ")";
        }

        if (type.SpecialType == SpecialType.System_Double)
        {
            return "DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualDouble(" + l + ", " + r + ", " + ctxVar + ")";
        }

        if (type.SpecialType == SpecialType.System_Single)
        {
            return "DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualSingle(" + l + ", " + r + ", " + ctxVar + ")";
        }

        if (type.SpecialType == SpecialType.System_Decimal)
        {
            return "DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualDecimal(" + l + ", " + r + ", " + ctxVar + ")";
        }

        if (type.SpecialType == SpecialType.System_Object)
        {
            return "DeepEqual.Generator.Shared.DynamicDeepComparer.AreEqualDynamic(" + l + ", " + r + ", " + ctxVar + ")";
        }

        if (type.IsValueType && type.SpecialType != SpecialType.None)
        {
            return l + ".Equals(" + r + ")";
        }

        if (type.TypeKind == TypeKind.Interface || type is INamedTypeSymbol { IsAbstract: true })
        {
            var ts = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            return "DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic<" + ts + ">(" + l + ", " + r +
                   ", " + ctxVar + ")";
        }

        if (type is INamedTypeSymbol nts && IsUserObjectType(nts))
        {
            var ts = nts.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            return "DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic<" + ts + ">(" + l + ", " + r +
                   ", " + ctxVar + ")";
        }

        return "object.Equals(" + l + ", " + r + ")";
    }

    private bool TryGetReadOnlyMemory(ITypeSymbol type, out ITypeSymbol? elementType)
    {
        if (_cache.MemoryElement.TryGetValue(type, out var cached) && cached is not null)
        {
            elementType = cached;
            return true;
        }

        elementType = null;
        if (type is INamedTypeSymbol named && named.OriginalDefinition.ToDisplayString() == "System.ReadOnlyMemory<T>")
        {
            elementType = named.TypeArguments[0];
            _cache.MemoryElement[type] = elementType;
            return true;
        }

        _cache.MemoryElement[type] = null;
        return false;
    }

    private bool TryGetMemory(ITypeSymbol type, out ITypeSymbol? elementType)
    {
        if (_cache.MemoryElement.TryGetValue(type, out var cached) && cached is not null)
        {
            elementType = cached;
            return true;
        }

        elementType = null;
        if (type is INamedTypeSymbol named && named.OriginalDefinition.ToDisplayString() == "System.Memory<T>")
        {
            elementType = named.TypeArguments[0];
            _cache.MemoryElement[type] = elementType;
            return true;
        }

        _cache.MemoryElement[type] = null;
        return false;
    }

    private static bool IsHashFriendly(ITypeSymbol type)
    {
        if (type.SpecialType == SpecialType.System_String)
        {
            return true;
        }

        if (type.TypeKind == TypeKind.Enum)
        {
            return true;
        }

        if (type.SpecialType is SpecialType.System_Single or SpecialType.System_Double or SpecialType.System_Decimal)
        {
            return false;
        }

        if (type.IsValueType && type.SpecialType != SpecialType.None)
        {
            return true;
        }

        var fqn = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        if (fqn is "global::System.DateTime" or "global::System.DateTimeOffset")
        {
            return true;
        }

        return false;
    }

    private static string GetNumericCall(ITypeSymbol type, string l, string r, string ctxVar)
    {
        return type.SpecialType switch
        {
            SpecialType.System_Single => "DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualSingle(" + l + ", " + r +
                                         ", " + ctxVar + ")",
            SpecialType.System_Double => "DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualDouble(" + l + ", " + r +
                                         ", " + ctxVar + ")",
            SpecialType.System_Decimal => "DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualDecimal(" + l + ", " +
                                          r + ", " + ctxVar + ")",
            _ => l + ".Equals(" + r + ")"
        };
    }

    private static bool IsNumericWithTolerance(ITypeSymbol type)
    {
        return type.SpecialType is SpecialType.System_Single or SpecialType.System_Double or SpecialType.System_Decimal;
    }

    private TypeSchema GetTypeSchema(INamedTypeSymbol type)
    {
        if (_cache.SchemaCache.TryGetValue(type, out var cached))
        {
            return cached;
        }

        var attr = type.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);
        if (attr is null)
        {
            var empty = new TypeSchema(Array.Empty<string>(), Array.Empty<string>());
            _cache.SchemaCache[type] = empty;
            return empty;
        }

        static string[] ReadStringArray(TypedConstant arg)
        {
            if (arg is { Kind: TypedConstantKind.Array, IsNull: false })
            {
                return arg.Values.Select(v => v.Value?.ToString() ?? string.Empty)
                    .Where(s => !string.IsNullOrWhiteSpace(s)).ToArray();
            }

            return Array.Empty<string>();
        }

        var include = Array.Empty<string>();
        var ignore = Array.Empty<string>();

        foreach (var kv in attr.NamedArguments)
        {
            if (kv.Key == "Members")
            {
                include = ReadStringArray(kv.Value);
            }
            else if (kv.Key == "IgnoreMembers")
            {
                ignore = ReadStringArray(kv.Value);
            }
        }

        var schema = new TypeSchema(include, ignore);
        _cache.SchemaCache[type] = schema;
        return schema;
    }

    private IEnumerable<MemberSymbol> EnumerateMembers(INamedTypeSymbol type, bool allowInternals,
        bool includeBase, TypeSchema schema)
    {
        if (schema.IncludeMembers.Count == 0 && schema.IgnoreMembers.Count == 0)
        {
            var key = (type, allowInternals, includeBase);
            if (!_cache.MemberCache.TryGetValue(key, out var cached))
            {
                cached = EnumerateMembersUncached(type, allowInternals, includeBase, schema).ToArray();
                _cache.MemberCache[key] = cached;
            }

            return cached;
        }

        return EnumerateMembersUncached(type, allowInternals, includeBase, schema);
    }

    private IEnumerable<MemberSymbol> EnumerateMembersUncached(INamedTypeSymbol ownerType, bool includeInternals,
        bool includeBase, TypeSchema schema)
    {
        static bool IsAccessible(ISymbol s, bool inclInternals, INamedTypeSymbol owner)
        {
            return s.DeclaredAccessibility switch
            {
                Accessibility.Public => true,
                Accessibility.Internal or Accessibility.ProtectedAndInternal => inclInternals &&
                    SymbolEqualityComparer.Default.Equals(s.ContainingAssembly, owner.ContainingAssembly),
                _ => false
            };
        }

        var hasInclude = schema.IncludeMembers.Count > 0;
        var includeSet = hasInclude ? new HashSet<string>(schema.IncludeMembers, StringComparer.Ordinal) : null;
        var ignoreSet = schema.IgnoreMembers.Count > 0
            ? new HashSet<string>(schema.IgnoreMembers, StringComparer.Ordinal)
            : null;

        var yielded = new HashSet<string>(StringComparer.Ordinal);
        for (var t = ownerType;
             t is not null && t.SpecialType != SpecialType.System_Object;
             t = includeBase ? t.BaseType : null)
        {
            foreach (var p in t.GetMembers().OfType<IPropertySymbol>())
            {
                if (p.IsStatic)
                {
                    continue;
                }

                if (p.Parameters.Length != 0)
                {
                    continue;
                }

                if (p.GetMethod is null)
                {
                    continue;
                }

                if (!IsAccessible(p, includeInternals, ownerType))
                {
                    continue;
                }

                if (yielded.Contains(p.Name))
                {
                    continue;
                }

                if (hasInclude && !includeSet!.Contains(p.Name))
                {
                    continue;
                }

                if (ignoreSet is not null && ignoreSet.Contains(p.Name))
                {
                    continue;
                }

                if (ownerType.IsValueType && SymbolEqualityComparer.Default.Equals(p.Type, ownerType) &&
                    !hasInclude)
                {
                    continue;
                }

                yielded.Add(p.Name);
                yield return new MemberSymbol(p.Name, p.Type, p);
            }

            foreach (var f in t.GetMembers().OfType<IFieldSymbol>())
            {
                if (f.IsStatic || f.IsConst || f.IsImplicitlyDeclared)
                {
                    continue;
                }

                if (f.AssociatedSymbol is not null)
                {
                    continue;
                }

                if (f.Name.StartsWith("<", StringComparison.Ordinal))
                {
                    continue;
                }

                if (!IsAccessible(f, includeInternals, ownerType))
                {
                    continue;
                }

                if (yielded.Contains(f.Name))
                {
                    continue;
                }

                if (hasInclude && !includeSet!.Contains(f.Name))
                {
                    continue;
                }

                if (ignoreSet is not null && ignoreSet.Contains(f.Name))
                {
                    continue;
                }

                if (ownerType.IsValueType && SymbolEqualityComparer.Default.Equals(f.Type, ownerType) &&
                    !hasInclude)
                {
                    continue;
                }

                yielded.Add(f.Name);
                yield return new MemberSymbol(f.Name, f.Type, f);
            }

            if (!includeBase)
            {
                break;
            }
        }
    }

    private IEnumerable<MemberSymbol> OrderMembers(IEnumerable<MemberSymbol> members)
    {
        return members.Select(m => (m, key: MemberCost(m))).OrderBy(t => t.key)
            .ThenBy(t => t.m.Name, StringComparer.Ordinal).Select(t => t.m);
    }

    private int MemberCost(MemberSymbol member)
    {
        var attr = GetDeepCompareAttribute(member.Symbol);
        var kind = GetEffectiveKind(member.Type, attr);
        if (kind == EffectiveKind.Skip)
        {
            return 99;
        }

        if (kind is EffectiveKind.Reference or EffectiveKind.Shallow)
        {
            return 0;
        }

        var t = member.Type;
        if (t is INamedTypeSymbol nnt && nnt.OriginalDefinition.ToDisplayString() == "System.Nullable<T>")
        {
            var inner = nnt.TypeArguments[0];
            if (inner.TypeKind == TypeKind.Enum)
            {
                return 2;
            }

            if (IsWellKnownStruct(inner) || (inner.IsValueType && inner.SpecialType != SpecialType.None))
            {
                return 3;
            }

            t = inner;
        }

        if (t.SpecialType == SpecialType.System_String)
        {
            return 1;
        }

        if (t.TypeKind == TypeKind.Enum)
        {
            return 2;
        }

        if (IsWellKnownStruct(t) || (t.IsValueType && t.SpecialType != SpecialType.None))
        {
            return 3;
        }

        if (t.SpecialType == SpecialType.System_Object)
        {
            return 6;
        }

        if (t is IArrayTypeSymbol)
        {
            return 9;
        }

        if (TryGetDictionaryInterface(t, out _, out _))
        {
            return 8;
        }

        if (TryGetEnumerableInterface(t, out _))
        {
            return 9;
        }

        if (TryGetReadOnlyMemory(t, out _))
        {
            return 3;
        }

        if (TryGetMemory(t, out _))
        {
            return 3;
        }

        if (t is INamedTypeSymbol nts && IsUserObjectType(nts))
        {
            return 7;
        }

        return 7;
    }

    private static bool IsWellKnownStruct(ITypeSymbol t)
    {
        if (t.SpecialType == SpecialType.System_DateTime)
        {
            return true;
        }

        var fqn = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        return fqn is "global::System.DateTimeOffset" or "global::System.TimeSpan" or "global::System.Guid" or "global::System.DateOnly" or "global::System.TimeOnly";
    }

    private static AttributeData? GetDeepCompareAttribute(ISymbol symbol)
    {
        return symbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);
    }

    private static EffectiveKind GetEffectiveKind(ITypeSymbol type, AttributeData? memberAttribute)
    {
        if (memberAttribute is not null)
        {
            var val = memberAttribute.NamedArguments.FirstOrDefault(p => p.Key == "Kind").Value.Value;
            if (val is int mk)
            {
                return (EffectiveKind)mk;
            }
        }

        var typeAttr = type.OriginalDefinition.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);
        if (typeAttr is not null)
        {
            var val = typeAttr.NamedArguments.FirstOrDefault(p => p.Key == "Kind").Value.Value;
            if (val is int tk)
            {
                return (EffectiveKind)tk;
            }
        }

        return EffectiveKind.Deep;
    }

    private static INamedTypeSymbol? GetEffectiveComparerType(ITypeSymbol comparedType, AttributeData? memberAttribute)
    {
        INamedTypeSymbol? fromMember = null;
        if (memberAttribute is not null)
        {
            foreach (var kv in memberAttribute.NamedArguments)
            {
                if (kv is { Key: "ComparerType", Value.Value: INamedTypeSymbol ts } &&
                    ImplementsIEqualityComparerFor(ts, comparedType))
                {
                    fromMember = ts;
                    break;
                }
            }
        }

        if (fromMember is not null)
        {
            return fromMember;
        }

        var typeAttr = comparedType.OriginalDefinition.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);
        if (typeAttr is not null)
        {
            foreach (var kv in typeAttr.NamedArguments)
            {
                if (kv is { Key: "ComparerType", Value.Value: INamedTypeSymbol ts2 } &&
                    ImplementsIEqualityComparerFor(ts2, comparedType))
                {
                    return ts2;
                }
            }
        }

        return null;
    }

    private static bool ImplementsIEqualityComparerFor(INamedTypeSymbol comparerType, ITypeSymbol argument)
    {
        foreach (var i in comparerType.AllInterfaces)
        {
            if (i.OriginalDefinition.ToDisplayString() == "System.Collections.Generic.IEqualityComparer<T>")
            {
                if (SymbolEqualityComparer.Default.Equals(i.TypeArguments[0], argument))
                {
                    return true;
                }
            }
        }

        return false;
    }

    private bool TryGetKeySpec(ITypeSymbol elementType, AttributeData? memberAttribute, Target root,
         out string keyTypeFqn, out string keyExprFormat)
    {
        var keys = new List<MemberSymbol>();
        keyTypeFqn = "";
        keyExprFormat = "{0}";
        var names = Array.Empty<string>();

        if (memberAttribute is not null)
        {
            foreach (var kv in memberAttribute.NamedArguments)
            {
                if (kv is { Key: "KeyMembers", Value.Values: { Length: > 0 } arr })
                {
                    names = arr.Select(v => v.Value?.ToString() ?? "").Where(s => s.Length > 0).ToArray();
                    break;
                }
            }
        }

        if (names.Length == 0)
        {
            var typeAttr = elementType.OriginalDefinition.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);
            if (typeAttr is not null)
            {
                foreach (var kv in typeAttr.NamedArguments)
                {
                    if (kv is { Key: "KeyMembers", Value.Values: { Length: > 0 } arr2 })
                    {
                        names = arr2.Select(v => v.Value?.ToString() ?? "").Where(s => s.Length > 0).ToArray();
                        break;
                    }
                }
            }
        }

        if (names.Length == 0)
        {
            return false;
        }

        foreach (var n in names)
        {
            var m = FindMemberOn(elementType, n, root.IncludeInternals, root.IncludeBaseMembers);
            if (m is not null)
            {
                keys.Add(m.Value);
            }
        }

        if (keys.Count == 0)
        {
            return false;
        }

        if (keys.Count == 1)
        {
            keyTypeFqn = keys[0].Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            keyExprFormat = "{0}." + keys[0].Name;
            return true;
        }

        if (keys.Count > 7)
        {
            return false;
        }

        keyTypeFqn = "global::System.ValueTuple<" + string.Join(",",
            keys.Select(k => k.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))) + ">";
        keyExprFormat = "(" + string.Join(",", keys.Select(k => "{0}." + k.Name)) + ")";
        return true;
    }

    private MemberSymbol? FindMemberOn(ITypeSymbol type, string name, bool includeInternals, bool includeBase)
    {
        for (var t = type;
             t is not null && t.SpecialType != SpecialType.System_Object;
             t = includeBase ? (t as INamedTypeSymbol)?.BaseType : null)
        {
            foreach (var p in t.GetMembers().OfType<IPropertySymbol>())
            {
                if (p.Name != name)
                {
                    continue;
                }

                if (p.IsStatic || p.Parameters.Length != 0 || p.GetMethod is null)
                {
                    continue;
                }

                if (!IsAccessibleForMember(p, includeInternals, type))
                {
                    continue;
                }

                return new MemberSymbol(p.Name, p.Type, p);
            }

            foreach (var f in t.GetMembers().OfType<IFieldSymbol>())
            {
                if (f.Name != name)
                {
                    continue;
                }

                if (f.IsStatic || f.IsConst || f.IsImplicitlyDeclared)
                {
                    continue;
                }

                if (!IsAccessibleForMember(f, includeInternals, type))
                {
                    continue;
                }

                return new MemberSymbol(f.Name, f.Type, f);
            }

            if (!includeBase)
            {
                break;
            }
        }

        return null;
    }

    private static bool IsAccessibleForMember(ISymbol s, bool inclInternals, ITypeSymbol owner)
    {
        return s.DeclaredAccessibility switch
        {
            Accessibility.Public => true,
            Accessibility.Internal or Accessibility.ProtectedAndInternal => inclInternals &&
                                                                            SymbolEqualityComparer.Default.Equals(
                                                                                s.ContainingAssembly,
                                                                                owner.ContainingAssembly),
            _ => false
        };
    }

    private static string GetEqualityComparerExprForHash(ITypeSymbol elType, string ctxVar, string? customVar)
    {
        if (customVar is not null)
        {
            return customVar;
        }

        if (elType.SpecialType == SpecialType.System_String)
        {
            return "DeepEqual.Generator.Shared.ComparisonHelpers.GetStringComparer(" + ctxVar + ")";
        }

        var fqn = elType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        if (fqn == "global::System.DateTime")
        {
            return "DeepEqual.Generator.Shared.ComparisonHelpers.StrictDateTimeComparer.Instance";
        }

        if (fqn == "global::System.DateTimeOffset")
        {
            return "DeepEqual.Generator.Shared.ComparisonHelpers.StrictDateTimeOffsetComparer.Instance";
        }

        return "System.Collections.Generic.EqualityComparer<" +
               elType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) + ">.Default";
    }

    private static bool ResolveOrderInsensitive(Target root, AttributeData? memberAttribute, ITypeSymbol elementType,
        INamedTypeSymbol? containingType)
    {
        if (memberAttribute is not null)
        {
            var opt = memberAttribute.NamedArguments.FirstOrDefault(a => a.Key == "OrderInsensitive").Value;
            if (opt.Value is bool b)
            {
                return b;
            }
        }

        var typeAttr = elementType.OriginalDefinition.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepComparableAttributeName);
        if (typeAttr is not null)
        {
            var opt = typeAttr.NamedArguments.FirstOrDefault(a => a.Key == "OrderInsensitiveCollections").Value;
            if (opt.Value is bool b)
            {
                return b;
            }
        }

        if (containingType is not null)
        {
            var containerAttr = containingType.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepComparableAttributeName);
            if (containerAttr is not null)
            {
                var opt = containerAttr.NamedArguments.FirstOrDefault(a => a.Key == "OrderInsensitiveCollections")
                    .Value;
                if (opt.Value is bool b)
                {
                    return b;
                }
            }
        }

        return root.OrderInsensitiveCollections;
    }

    private bool TryGetEnumerableInterface(ITypeSymbol type, out ITypeSymbol? elementType)
    {
        if (_cache.EnumerableElement.TryGetValue(type, out var cached))
        {
            elementType = cached;
            return cached is not null;
        }

        if (type is INamedTypeSymbol named &&
            named.OriginalDefinition.ToDisplayString() == "System.Collections.Generic.IEnumerable<T>")
        {
            elementType = named.TypeArguments[0];
            _cache.EnumerableElement[type] = elementType;
            return true;
        }

        foreach (var i in type.AllInterfaces)
        {
            if (i.OriginalDefinition.ToDisplayString() == "System.Collections.Generic.IEnumerable<T>")
            {
                elementType = i.TypeArguments[0];
                _cache.EnumerableElement[type] = elementType;
                return true;
            }
        }

        elementType = null;
        _cache.EnumerableElement[type] = null;
        return false;
    }

    private bool TryGetDictionaryInterface(ITypeSymbol type, out ITypeSymbol? keyType,
        out ITypeSymbol? valueType)
    {
        if (_cache.DictionaryKv.TryGetValue(type, out var cached))
        {
            if (cached is not null)
            {
                keyType = cached.Value.Key;
                valueType = cached.Value.Val;
                return true;
            }

            keyType = null;
            valueType = null;
            return false;
        }

        if (type is INamedTypeSymbol named)
        {
            var defSelf = named.OriginalDefinition.ToDisplayString();
            if (defSelf is "System.Collections.Generic.IDictionary<TKey, TValue>" or "System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>")
            {
                keyType = named.TypeArguments[0];
                valueType = named.TypeArguments[1];
                _cache.DictionaryKv[type] = (keyType, valueType);
                return true;
            }
        }

        foreach (var i in type.AllInterfaces)
        {
            var def = i.OriginalDefinition.ToDisplayString();
            if (def is "System.Collections.Generic.IDictionary<TKey, TValue>" or "System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>")
            {
                keyType = i.TypeArguments[0];
                valueType = i.TypeArguments[1];
                _cache.DictionaryKv[type] = (keyType, valueType);
                return true;
            }
        }

        keyType = null;
        valueType = null;
        _cache.DictionaryKv[type] = null;
        return false;
    }

    private bool IsUserObjectType(ITypeSymbol type)
    {
        if (_cache.UserObject.TryGetValue(type, out var cached))
        {
            return cached;
        }

        if (type is not INamedTypeSymbol n)
        {
            _cache.UserObject[type] = false;
            return false;
        }

        if (n.SpecialType != SpecialType.None)
        {
            _cache.UserObject[type] = false;
            return false;
        }

        var ns = n.ContainingNamespace?.ToDisplayString() ?? "";
        if (ns.StartsWith("System", StringComparison.Ordinal))
        {
            _cache.UserObject[type] = false;
            return false;
        }

        var asm = n.ContainingAssembly?.Name ?? "";
        if (asm is "mscorlib" or "System.Private.CoreLib" or "System.Runtime")
        {
            _cache.UserObject[type] = false;
            return false;
        }

        var ok = n.TypeKind is TypeKind.Class or TypeKind.Struct;
        _cache.UserObject[type] = ok;
        return ok;
    }

    private static bool IsTypeAccessibleFromRoot(INamedTypeSymbol t, Target root)
    {
        if (t.DeclaredAccessibility == Accessibility.Public)
        {
            var cur = t.ContainingType;
            while (cur is not null)
            {
                if (cur.DeclaredAccessibility != Accessibility.Public)
                {
                    return false;
                }

                cur = cur.ContainingType;
            }

            return true;
        }

        if (!root.IncludeInternals)
        {
            return false;
        }

        if (!SymbolEqualityComparer.Default.Equals(t.ContainingAssembly, root.Type.ContainingAssembly))
        {
            return false;
        }

        var c = t;
        while (c is not null)
        {
            if (c.DeclaredAccessibility is Accessibility.Public or Accessibility.Internal
                or Accessibility.ProtectedAndInternal)
            {
                c = c.ContainingType;
                continue;
            }

            return false;
        }

        return true;
    }

    private HashSet<INamedTypeSymbol> BuildReachableTypeClosure(Target root)
    {
        var set = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
        var queue = new Queue<INamedTypeSymbol>();
        set.Add(root.Type);
        queue.Enqueue(root.Type);

        while (queue.Count > 0)
        {
            var current = queue.Dequeue();
            var schema = GetTypeSchema(current);

            foreach (var member in EnumerateMembers(current, root.IncludeInternals, root.IncludeBaseMembers, schema))
            {
                var kind = GetEffectiveKind(member.Type, GetDeepCompareAttribute(member.Symbol));
                if (kind is EffectiveKind.Skip or EffectiveKind.Shallow or EffectiveKind.Reference)
                {
                    continue;
                }

                Accumulate(member.Type);
            }
        }

        return set;

        void Accumulate(ITypeSymbol t)
        {
            if (t is INamedTypeSymbol nnt && nnt.OriginalDefinition.ToDisplayString() == "System.Nullable<T>")
            {
                t = nnt.TypeArguments[0];
            }

            if (t is IArrayTypeSymbol at)
            {
                Accumulate(at.ElementType);
                return;
            }

            if (TryGetDictionaryInterface(t, out _, out var valT))
            {
                Accumulate(valT!);
                return;
            }

            if (TryGetEnumerableInterface(t, out var elT))
            {
                Accumulate(elT!);
                return;
            }

            if (TryGetReadOnlyMemory(t, out var rmT))
            {
                Accumulate(rmT!);
                return;
            }

            if (TryGetMemory(t, out var mT))
            {
                Accumulate(mT!);
                return;
            }

            if (t is INamedTypeSymbol n && IsUserObjectType(n) && IsTypeAccessibleFromRoot(n, root) && set.Add(n))
            {
                queue.Enqueue(n);
            }
        }
    }

    private static string GetHelperMethodName(INamedTypeSymbol type)
    {
        return "AreDeepEqual__" + GenCommon.SanitizeIdentifier(type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
    }

    // In GenCommon
    internal static string SanitizeIdentifier(string s)
    {
        var sb = new StringBuilder(s.Length);
        foreach (var ch in s)
        {
            sb.Append(char.IsLetterOrDigit(ch) ? ch : '_');
        }
        return sb.ToString();
    }

    // In CodeWriter
    internal sealed class CodeWriter
    {
        private readonly StringBuilder _buffer = new();
        private int _indent;

        public void Line(string text = "")
        {
            if (!string.IsNullOrEmpty(text))
            {
                _buffer.Append(' ', _indent * 4);
                _buffer.AppendLine(text);
            }
            else
            {
                _buffer.AppendLine();
            }
        }

        public void Open(string header)
        {
            Line(header);
            Line("{");
            _indent++;
        }

        public void Close()
        {
            _indent = Math.Max(0, _indent - 1);
            Line("}");
        }

        public override string ToString() => _buffer.ToString();
    }
}

internal sealed class DiffDeltaEmitter
{
    private readonly Compilation _compilation;

    public DiffDeltaEmitter(Compilation compilation) => _compilation = compilation;

    private const string DeepCompareAttributeName = GenCommon.DeepCompareAttributeMetadataName;

    internal readonly record struct Target(
        INamedTypeSymbol Type,
        bool IncludeInternals,
        bool OrderInsensitiveCollections,
        bool CycleTrackingEnabled,
        bool IncludeBaseMembers,
        bool GenerateDiff,
        bool GenerateDelta);

    private readonly record struct MemberSymbol(string Name, ITypeSymbol Type, ISymbol Symbol);

    private sealed record TypeSchema(
        IReadOnlyList<string> IncludeMembers,
        IReadOnlyList<string> IgnoreMembers,
        CompareKind DefaultKind,
        bool DefaultOrderInsensitive,
        bool DefaultDeltaShallow,
        bool DefaultDeltaSkip);

    public void EmitForRoot(SourceProductionContext spc, Target root, string? hintOverride = null)
    {
        Diagnostics.DiagnosticPass(spc, root.Type);

        var ns = root.Type.ContainingNamespace.IsGlobalNamespace
            ? null
            : root.Type.ContainingNamespace.ToDisplayString();

        var rootFqn = root.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var helperClass = root.Type.Name + "DeepOps";
        var hintName = hintOverride ?? GenCommon.SanitizeFileName(rootFqn + "_DeepOps.g.cs");

        var w = new CodeWriter();
        w.Line("// <auto-generated/>");
        w.Line("#pragma warning disable");
        w.Line("using System;");
        w.Line("using System.Collections;");
        w.Line("using System.Collections.Generic;");
        w.Line("using DeepEqual.Generator.Shared;");
        w.Line();

        if (ns is not null)
        {
            w.Open("namespace " + ns);
        }

        var accessibility = root.IncludeInternals || root.Type.DeclaredAccessibility != Accessibility.Public ? "internal" : "public";
        var typeParams = root.Type.Arity > 0 ? "<" + string.Join(",", root.Type.TypeArguments.Select(a => a.Name)) + ">" : "";

        // ----- helper class -----
        w.Open(accessibility + " static class " + helperClass + typeParams);

        // reachable closure and registrations (your existing code)
        var reachable = BuildReachableTypeClosure(root);

        w.Open("static " + helperClass + "()");
        foreach (var t in reachable.OrderBy(t => t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), StringComparer.Ordinal))
        {
            var fqn = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (root.GenerateDiff)
            {
                w.Line("GeneratedHelperRegistry.RegisterDiff<" + fqn + ">((l, r, c) => TryGetDiff__" + GenCommon.SanitizeIdentifier(fqn) + "(l, r, c));");
            }
            if (root.GenerateDelta)
            {
                w.Line("GeneratedHelperRegistry.RegisterDelta<" + fqn + ">(ComputeDelta__" + GenCommon.SanitizeIdentifier(fqn) + ", ApplyDelta__" + GenCommon.SanitizeIdentifier(fqn) + ");");
            }
        }
        w.Close(); // static ctor
        w.Line();

        // public root APIs
        EmitRootApis(w, root.Type, root.CycleTrackingEnabled, root.GenerateDiff, root.GenerateDelta);

        // per-type implementations
        foreach (var t in reachable.OrderBy(t => t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), StringComparer.Ordinal))
        {
            EmitImplementationsForType(w, t, root);
        }

        w.Close(); // close helper class

        // ----- module initializer at namespace scope (NOT nested) -----
        // Builds the open generic arity suffix: "<>", "<,>", "<,,>", ...
        string OpenGenericSuffix(int arity)
        {
            if (arity <= 0) return "";
            if (arity == 1) return "<>";
            return "<" + new string(',', arity - 1) + ">";
        }

        var openSuffix = OpenGenericSuffix(root.Type.Arity);

        // unique type name to avoid collisions across multiple roots
        var initTypeName = "__" + GenCommon.SanitizeIdentifier(helperClass) + "_ModuleInit_" +
                           Math.Abs(root.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).GetHashCode());

        w.Open("internal static class " + initTypeName);

        w.Line("[System.Runtime.CompilerServices.ModuleInitializer]");
        w.Open("internal static void Init()");
        // Force-run the helper's static constructor at module load
        w.Line("System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(typeof(" + helperClass + openSuffix + ").TypeHandle);");
        w.Close(); // Init
        w.Close(); // static class

        if (ns is not null) w.Close(); // namespace

        spc.AddSource(hintName, w.ToString());
    }

    private void EmitRootApis(CodeWriter w, INamedTypeSymbol rootType, bool trackCycles, bool genDiff, bool genDelta)
    {
        var rootFqn = rootType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var valOrRefNull = rootType.IsValueType ? "" : "?";

        if (genDiff)
        {
            // TryGetDiff
            w.Open("public static bool TryGetDiff(" + rootFqn + valOrRefNull + " left, " + rootFqn + valOrRefNull + " right, out DeepEqual.Generator.Shared.Diff<" + rootFqn + "> diff)");
            w.Line("var context = " + (trackCycles ? "new DeepEqual.Generator.Shared.ComparisonContext()" : "DeepEqual.Generator.Shared.ComparisonContext.NoTracking") + ";");
            w.Line("var t = TryGetDiff__" + GenCommon.SanitizeIdentifier(rootFqn) + "(left, right, context);");
            w.Open("if (t.hasDiff)");
            w.Line("diff = t.diff; return true;");
            w.Close();
            w.Line("diff = default!;"); // safe default; Diff.Empty<T> also fine if preferred
            w.Line("return false;");
            w.Close();
            w.Line();
        }

        if (genDelta)
        {
            // ComputeDelta
            w.Open("public static void ComputeDelta(" + rootFqn + valOrRefNull + " left, " + rootFqn + valOrRefNull + " right, ref DeepEqual.Generator.Shared.DeltaWriter writer)");
            w.Line("var context = " + (trackCycles ? "new DeepEqual.Generator.Shared.ComparisonContext()" : "DeepEqual.Generator.Shared.ComparisonContext.NoTracking") + ";");
            w.Line("ComputeDelta__" + GenCommon.SanitizeIdentifier(rootFqn) + "(left, right, context, ref writer);");
            w.Close();
            w.Line();

            // ApplyDelta
            w.Open("public static void ApplyDelta(ref " + rootFqn + valOrRefNull + " target, ref DeepEqual.Generator.Shared.DeltaReader reader)");
            w.Line("ApplyDelta__" + GenCommon.SanitizeIdentifier(rootFqn) + "(ref target, ref reader);");
            w.Close();
            w.Line();
        }
    }

    private void EmitImplementationsForType(CodeWriter w, INamedTypeSymbol type, Target root)
    {
        var fqn = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var id = GenCommon.SanitizeIdentifier(fqn);
        var valOrRefNull = type.IsValueType ? "" : "?";

        var schema = GetTypeSchema(type);

        // ----- TryGetDiff__T -----
        if (root.GenerateDiff)
        {
            w.Open("private static (bool hasDiff, DeepEqual.Generator.Shared.Diff<" + fqn + "> diff) TryGetDiff__" + id + "(" + fqn + valOrRefNull + " left, " + fqn + valOrRefNull + " right, DeepEqual.Generator.Shared.ComparisonContext context)");
            if (!type.IsValueType)
            {
                w.Open("if (object.ReferenceEquals(left, right))");
                w.Line("return (false, DeepEqual.Generator.Shared.Diff<" + fqn + ">.Empty);");
                w.Close();

                w.Open("if (left is null && right is not null)");
                w.Line("return (true, DeepEqual.Generator.Shared.Diff<" + fqn + ">.Replacement(right));");
                w.Close();

                w.Open("if (left is not null && right is null)");
                w.Line("return (true, DeepEqual.Generator.Shared.Diff<" + fqn + ">.Replacement(right));");
                w.Close();

                if (root.CycleTrackingEnabled)
                {
                    w.Open("if (!context.Enter(left!, right!))");
                    w.Line("return (false, DeepEqual.Generator.Shared.Diff<" + fqn + ">.Empty);");
                    w.Close();
                    w.Open("try");
                }
            }

            w.Line("var changes = new System.Collections.Generic.List<DeepEqual.Generator.Shared.MemberChange>();");

            foreach (var m in OrderMembers(EnumerateMembers(type, root.IncludeInternals, root.IncludeBaseMembers, schema)))
            {
                EmitMemberDiff(w, type, m, root);
            }

            w.Line("return changes.Count == 0 ? (false, DeepEqual.Generator.Shared.Diff<" + fqn + ">.Empty) : (true, DeepEqual.Generator.Shared.Diff<" + fqn + ">.Members(changes));");

            if (!type.IsValueType && root.CycleTrackingEnabled)
            {
                w.Close(); // try
                w.Open("finally");
                w.Line("context.Exit(left!, right!);");
                w.Close();
            }
            w.Close();
            w.Line();
        }

        // ----- ComputeDelta__T -----
        // ----- ComputeDelta__T -----
        if (root.GenerateDelta)
        {
            // NOTE: signature now accepts 'ComparisonContext context' and we no longer create a local NoTracking context.
            w.Open($"private static void ComputeDelta__{id}(" +
                   fqn + valOrRefNull + " left, " +
                   fqn + valOrRefNull + " right, " +
                   "DeepEqual.Generator.Shared.ComparisonContext context, " +
                   "ref DeepEqual.Generator.Shared.DeltaWriter writer)");

            if (!type.IsValueType)
            {
                // Reference fast paths
                w.Open("if (object.ReferenceEquals(left, right))");
                w.Line("return;");
                w.Close();

                w.Open("if (left is null && right is not null)");
                w.Line("writer.WriteReplaceObject(right); return;");
                w.Close();

                w.Open("if (left is not null && right is null)");
                w.Line("writer.WriteReplaceObject(right); return;");
                w.Close();

                // Cycle tracking: enter/exit like diff
                if (root.CycleTrackingEnabled)
                {
                    w.Open("if (!context.Enter(left!, right!))");
                    w.Line("return;"); // already visited pair → short-circuit
                    w.Close();
                    w.Open("try");
                }
            }

            // Per-member emission (uses the 'context' parameter now)
            foreach (var m in OrderMembers(EnumerateMembers(type, root.IncludeInternals, root.IncludeBaseMembers, schema)))
            {
                EmitMemberDelta(w, type, m, root);
            }

            if (!type.IsValueType && root.CycleTrackingEnabled)
            {
                w.Close(); // try
                w.Open("finally");
                w.Line("context.Exit(left!, right!);");
                w.Close();
            }

            w.Close(); // ComputeDelta__T
            w.Line();
        }

        // ----- ApplyDelta__T -----
        if (root.GenerateDelta)
        {
            w.Open($"private static void ApplyDelta__{id}(ref {fqn}{valOrRefNull} target, ref DeepEqual.Generator.Shared.DeltaReader reader)");

            // 1) replacement first
            w.Open("foreach (var op in reader.EnumerateAll())");
            w.Open("if (op.MemberIndex == -1 && op.Kind == DeepEqual.Generator.Shared.DeltaKind.ReplaceObject)");
            w.Line($"target = ({fqn}{valOrRefNull})op.Value; return;");
            w.Close();
            w.Close(); // foreach

            // 2) per-member
            foreach (var m in OrderMembers(EnumerateMembers(type, root.IncludeInternals, root.IncludeBaseMembers, schema)).Select((ms, idx) => (ms, idx)))
            {
                EmitMemberApplyDelta(w, type, m.ms, m.idx, root);
            }

            w.Close(); // ApplyDelta__T
            w.Line();
        }
    }
    private void EmitMemberDiff(CodeWriter w, INamedTypeSymbol owner, MemberSymbol member, Target root)
    {
        var idx = GetStableMemberIndex(owner, member);
        var left = "left." + member.Name;
        var right = "right." + member.Name;

        var (effKind, orderInsensitive, keyMembers, deltaShallow, deltaSkip) = ResolveEffectiveSettings(member);
        if (effKind == CompareKind.Skip || deltaSkip) return;

        // 1) Value-like (incl. Nullable<T>, enums, structs, string) — always shallow compare
        if (IsValueLike(member.Type))
        {
            var cmp = GetValueLikeEqualsInvocation(member.Type, left, right);
            w.Open($"if (!({cmp}))");
            w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            w.Close();
            return;
        }

        // 2) Reference compare: only meaningful for reference types
        if (effKind == CompareKind.Reference && member.Type.IsReferenceType)
        {
            w.Open($"if (!object.ReferenceEquals({left}, {right}))");
            w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            w.Close();
            return;
        }

        // 3) Shallow compare for reference types
        if (effKind == CompareKind.Shallow)
        {
            var tfqn = member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            w.Open($"if (!System.Collections.Generic.EqualityComparer<{tfqn}>.Default.Equals({left}, {right}))");
            w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            w.Close();
            return;
        }

        // 4) Collections/dicts → v1: Set on any difference
        if (IsEnumerable(member.Type) || IsDictionary(member.Type))
        {
            w.Open($"if (!DeepEqual.Generator.Shared.DynamicDeepComparer.AreEqualDynamic({left}, {right}, context))");
            w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            w.Close();
            return;
        }

        // 5) Reference-type user objects with deep semantics → runtime dispatch
        // (DeltaShallow forces Set)
        if (deltaShallow)
        {
            w.Open($"if (!DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic({left}, {right}, context))");
            w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            w.Close();
            return;
        }

        var ltmp = $"__l_{idx}";
        var rtmp = $"__r_{idx}";
        w.Line($"var {ltmp} = {left};");
        w.Line($"var {rtmp} = {right};");

        w.Open($"if (object.ReferenceEquals({ltmp}, {rtmp}))");
        w.Line("// no change");
        w.Close();

        w.Open($"else if ({ltmp} is null || {rtmp} is null)");
        w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
        w.Close();

        w.Line("else {");
        w.Line($"    var __tL = {ltmp}.GetType();");
        w.Line($"    var __tR = {rtmp}.GetType();");
        w.Open("    if (!object.ReferenceEquals(__tL, __tR))");
        w.Line($"    changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
        w.Close();
        w.Line("    else {");
        w.Line("        if (GeneratedHelperRegistry.TryGetDiffSameType(__tL, " + ltmp + ", " + rtmp + ", context, out var __idiff)) {");
        w.Line("            if (!__idiff.IsEmpty) changes.Add(new DeepEqual.Generator.Shared.MemberChange(" + idx + ", DeepEqual.Generator.Shared.MemberChangeKind.Nested, __idiff));");
        w.Line("            else changes.Add(new DeepEqual.Generator.Shared.MemberChange(" + idx + ", DeepEqual.Generator.Shared.MemberChangeKind.Set, " + right + "));");
        w.Line("        } else {");
        w.Line("            changes.Add(new DeepEqual.Generator.Shared.MemberChange(" + idx + ", DeepEqual.Generator.Shared.MemberChangeKind.Set, " + right + "));");
        w.Line("        }");

        w.Line("    }");
        w.Line("}");
    }

    private void EmitMemberDelta(CodeWriter w, INamedTypeSymbol owner, MemberSymbol member, Target root)
    {
        var idx = GetStableMemberIndex(owner, member);
        var left = "left." + member.Name;
        var right = "right." + member.Name;

        var (effKind, orderInsensitive, keyMembers, deltaShallow, deltaSkip) = ResolveEffectiveSettings(member);
        if (effKind == CompareKind.Skip || deltaSkip) return;

        // 1) Value-like (incl. Nullable<T>, structs, string) → SetMember if different
        if (IsValueLike(member.Type))
        {
            var cmp = GetValueLikeEqualsInvocation(member.Type, left, right);
            w.Open($"if (!({cmp}))");
            w.Line($"writer.WriteSetMember({idx}, {right});");
            w.Close();
            return;
        }

        // 2) Reference compare (only for reference types)
        if (effKind == CompareKind.Reference && member.Type.IsReferenceType)
        {
            w.Open($"if (!object.ReferenceEquals({left}, {right}))");
            w.Line($"writer.WriteSetMember({idx}, {right});");
            w.Close();
            return;
        }

        // 3) Shallow compare for reference types
        if (effKind == CompareKind.Shallow)
        {
            var tfqn = member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            w.Open($"if (!System.Collections.Generic.EqualityComparer<{tfqn}>.Default.Equals({left}, {right}))");
            w.Line($"writer.WriteSetMember({idx}, {right});");
            w.Close();
            return;
        }

        // 4) DeltaShallow override (MUST be before dict/array/list/user-object)
        if (deltaShallow)
        {
            w.Open($"if (!DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic({left}, {right}, context))");
            w.Line($"writer.WriteSetMember({idx}, {right});");
            w.Close();
            return;
        }

        // 5) Dictionaries
        if (TryGetDictionaryTypes(member.Type, out var keyT, out var valT))
        {
            // IReadOnlyDictionary<,> → fallback to SetMember if changed
            if (member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                .StartsWith("global::System.Collections.Generic.IReadOnlyDictionary<"))
            {
                w.Open($"if (!DeepEqual.Generator.Shared.DynamicDeepComparer.AreEqualDynamic({left}, {right}, context))");
                w.Line($"writer.WriteSetMember({idx}, {right});");
                w.Close();
                return;
            }

            // Mutable dict → granular ops
            var kFqn = keyT.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var vFqn = valT.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var nestedValues = !IsValueLike(valT);
            w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeDictDelta<{kFqn}, {vFqn}>({left}, {right}, {idx}, ref writer, {(nestedValues ? "true" : "false")}, context);");
            return;
        }

        // 6) Arrays → fallback to SetMember when different
        if (member.Type is IArrayTypeSymbol arrSym)
        {
            var elFqn = arrSym.ElementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            w.Open($"if (!DeepEqual.Generator.Shared.ComparisonHelpers.ArraysEqual<{elFqn}>({left}, {right}))");
            w.Line($"writer.WriteSetMember({idx}, {right});");
            w.Close();
            return;
        }

        // 7) Ordered collections (IList<T>) → granular list ops; otherwise fallback to SetMember
        if (TryGetEnumerableElement(member.Type, out var elem))
        {
            if (TryGetListInterface(member.Type, out _))
            {
                var elFqn = elem.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var cmpExpr = IsValueLike(elem)
                    ? $"new System.Func<{elFqn}, {elFqn}, bool>((a,b)=>System.Collections.Generic.EqualityComparer<{elFqn}>.Default.Equals(a,b))"
                    : $"new System.Func<{elFqn}, {elFqn}, bool>((a,b)=>DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic(a,b, context))";

                w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeListDelta<{elFqn}>({left}, {right}, {idx}, ref writer, {cmpExpr});");
            }
            else
            {
                // Non-mutable enumerable → fallback to SetMember when different
                w.Open($"if (!DeepEqual.Generator.Shared.DynamicDeepComparer.AreEqualDynamic({left}, {right}, context))");
                w.Line($"writer.WriteSetMember({idx}, {right});");
                w.Close();
            }
            return;
        }

        // 8) User object (deep, polymorphic-safe) with SetMember fallback if unregistered
        var ltmp = $"__l_{idx}";
        var rtmp = $"__r_{idx}";
        w.Line($"var {ltmp} = {left};");
        w.Line($"var {rtmp} = {right};");

        w.Open($"if (object.ReferenceEquals({ltmp}, {rtmp}))");
        w.Line("// identical");
        w.Close();

        w.Open($"else if ({ltmp} is null || {rtmp} is null)");
        w.Line($"writer.WriteSetMember({idx}, {right});");
        w.Close();

        w.Line("else {");
        w.Line($"    var __tL = {ltmp}.GetType();");
        w.Line($"    var __tR = {rtmp}.GetType();");
        w.Open("    if (!object.ReferenceEquals(__tL, __tR))");
        w.Line($"    writer.WriteSetMember({idx}, {right});");
        w.Close();
        w.Line("    else {");
        w.Line("        // compute structural equality first");
        w.Line($"        var __equal = DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic({ltmp}, {rtmp}, context);");
        w.Line("        if (!__equal) {");
        w.Line("            var __sub = new DeepEqual.Generator.Shared.DeltaDocument();");
        w.Line("            var __w   = new DeepEqual.Generator.Shared.DeltaWriter(__sub);");
        w.Line("            GeneratedHelperRegistry.ComputeDeltaSameType(__tL, " + ltmp + ", " + rtmp + ", context, ref __w);");
        w.Open("            if (!__sub.IsEmpty)");
        w.Line($"            writer.WriteNestedMember({idx}, __sub);");
        w.Close();
        w.Line("            else");
        w.Line($"            writer.WriteSetMember({idx}, {right}); // runtime type unregistered → fallback");
        w.Line("        }");
        w.Line("        // else equal → no op");
        w.Line("    }");
        w.Line("}");
    }

    private static bool TryGetEnumerableElement(ITypeSymbol t, out ITypeSymbol element)
    {
        element = null!;
        if (t is IArrayTypeSymbol at) { element = at.ElementType; return true; }

        foreach (var i in t.AllInterfaces)
        {
            if (i is INamedTypeSymbol ni &&
                ni.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                "global::System.Collections.Generic.IEnumerable<T>")
            {
                element = ni.TypeArguments[0];
                return true;
            }
        }
        if (t is INamedTypeSymbol nt &&
            nt.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
            "global::System.Collections.Generic.IEnumerable<T>")
        {
            element = nt.TypeArguments[0];
            return true;
        }
        return false;
    }

    private static bool TryGetListInterface(ITypeSymbol t, out ITypeSymbol element)
    {
        element = null!;
        foreach (var i in t.AllInterfaces)
        {
            if (i is INamedTypeSymbol ni &&
                ni.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                "global::System.Collections.Generic.IList<T>")
            {
                element = ni.TypeArguments[0];
                return true;
            }
        }
        // List<T> itself
        if (t is INamedTypeSymbol nt &&
            nt.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
            "global::System.Collections.Generic.List<T>")
        {
            element = nt.TypeArguments[0];
            return true;
        }
        return false;
    }

    private static bool TryGetDictionaryTypes(ITypeSymbol t, out ITypeSymbol key, out ITypeSymbol value)
    {
        key = value = null!;
        static bool IsDict(INamedTypeSymbol x) =>
            x.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                "global::System.Collections.Generic.IDictionary<TKey, TValue>" ||
            x.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                "global::System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>";

        foreach (var i in t.AllInterfaces)
        {
            if (i is INamedTypeSymbol ni && IsDict(ni))
            {
                key = ni.TypeArguments[0];
                value = ni.TypeArguments[1];
                return true;
            }
        }

        if (t is INamedTypeSymbol nt && IsDict(nt))
        {
            key = nt.TypeArguments[0];
            value = nt.TypeArguments[1];
            return true;
        }

        return false;
    }

    private void EmitMemberApplyDelta(CodeWriter w, INamedTypeSymbol owner, MemberSymbol member, int index, Target root)
    {
        var memberIdx = GetStableMemberIndex(owner, member);
        var propAccess = "target." + member.Name;
        var typeFqn = member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var nullableQ = member.Type.IsReferenceType ? "?" : "";

        w.Line("// apply for member #" + memberIdx + " " + member.Name);
        w.Open($"foreach (var op in reader.EnumerateMember({memberIdx}))");
        w.Open("switch (op.Kind)");

        // SetMember (always)
        w.Open("case DeepEqual.Generator.Shared.DeltaKind.SetMember:");
        w.Line($"{propAccess} = ({typeFqn})op.Value;");
        w.Line("break;");
        w.Close();

        // NestedMember: only for user objects (not value-like / lists / dicts)
        if (!IsValueLike(member.Type) && !TryGetEnumerableElement(member.Type, out _) && !TryGetDictionaryTypes(member.Type, out _, out _))
        {
            var nestedId = GenCommon.SanitizeIdentifier(member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
            w.Open("case DeepEqual.Generator.Shared.DeltaKind.NestedMember:");
            w.Line($"{typeFqn}{nullableQ} __tmp = {propAccess};");
            w.Line("var __obj = (object?)__tmp;");
            w.Line("var __subReader = new DeepEqual.Generator.Shared.DeltaReader(op.Nested!);");
            w.Open("if (__obj != null)");
            w.Line("var __t = __obj.GetType();");
            w.Line("GeneratedHelperRegistry.TryApplyDeltaSameType(__t, ref __obj, ref __subReader);");
            w.Close();
            w.Line($"{propAccess} = ({typeFqn})__obj;");
            w.Line("break;");
            w.Close();
        }

        // -------- Sequence granular ops (only when the member is IList<T>) --------
        if (TryGetListInterface(member.Type, out var elType))
        {
            var elFqn = elType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            w.Open("case DeepEqual.Generator.Shared.DeltaKind.SeqReplaceAt:");
            w.Open($"if ({propAccess} is System.Collections.Generic.IList<{elFqn}> __list_r)");
            w.Line($"__list_r[op.Index] = ({elFqn})op.Value!;");
            w.Close();
            w.Line("break;");
            w.Close();

            w.Open("case DeepEqual.Generator.Shared.DeltaKind.SeqAddAt:");
            w.Open($"if ({propAccess} is System.Collections.Generic.IList<{elFqn}> __list_a)");
            w.Line($"__list_a.Insert(op.Index, ({elFqn})op.Value!);");
            w.Close();
            w.Line("break;");
            w.Close();

            w.Open("case DeepEqual.Generator.Shared.DeltaKind.SeqRemoveAt:");
            w.Open($"if ({propAccess} is System.Collections.Generic.IList<{elFqn}> __list_d)");
            w.Line($"__list_d.RemoveAt(op.Index);");
            w.Close();
            w.Line("break;");
            w.Close();
        }
        else
        {
            // If not a mutable list, ignore (we only emit granular ops for lists; arrays fell back to SetMember)
            w.Open("case DeepEqual.Generator.Shared.DeltaKind.SeqReplaceAt:");
            w.Line("break;");
            w.Close();
            w.Open("case DeepEqual.Generator.Shared.DeltaKind.SeqAddAt:");
            w.Line("break;");
            w.Close();
            w.Open("case DeepEqual.Generator.Shared.DeltaKind.SeqRemoveAt:");
            w.Line("break;");
            w.Close();
        }

        // -------- Dictionary granular ops --------
        if (TryGetDictionaryTypes(member.Type, out var kType, out var vType))
        {
            var kFqn = kType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var vFqn = vType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            w.Open("case DeepEqual.Generator.Shared.DeltaKind.DictSet:");
            w.Open($"if ({propAccess} is System.Collections.Generic.IDictionary<{kFqn}, {vFqn}> __dict_s)");
            w.Line($"__dict_s[({kFqn})op.Key!] = ({vFqn})op.Value!;");
            w.Close();
            w.Line("break;");
            w.Close();

            w.Open("case DeepEqual.Generator.Shared.DeltaKind.DictRemove:");
            w.Open($"if ({propAccess} is System.Collections.Generic.IDictionary<{kFqn}, {vFqn}> __dict_r)");
            w.Line($"__dict_r.Remove(({kFqn})op.Key!);");
            w.Close();
            w.Line("break;");
            w.Close();

            w.Open("case DeepEqual.Generator.Shared.DeltaKind.DictNested:");
            w.Open($"if ({propAccess} is System.Collections.Generic.IDictionary<{kFqn}, {vFqn}> __dict_n)");
            w.Open($"if (__dict_n.TryGetValue(({kFqn})op.Key!, out var __old))");
            w.Line("object? __obj = __old;");
            w.Line("var __subReader = new DeepEqual.Generator.Shared.DeltaReader(op.Nested!);");
            w.Line("GeneratedHelperRegistry.TryApplyDeltaSameType(__obj!.GetType(), ref __obj, ref __subReader);");
            w.Line($"__dict_n[({kFqn})op.Key!] = ({vFqn})__obj!;");
            w.Close();
            w.Close();
            w.Line("break;");
            w.Close();
        }
        else
        {
            w.Open("case DeepEqual.Generator.Shared.DeltaKind.DictSet:"); w.Line("break;"); w.Close();
            w.Open("case DeepEqual.Generator.Shared.DeltaKind.DictRemove:"); w.Line("break;"); w.Close();
            w.Open("case DeepEqual.Generator.Shared.DeltaKind.DictNested:"); w.Line("break;"); w.Close();
        }

        // default
        w.Open("default:");
        w.Line("break;");
        w.Close();

        w.Close(); // switch
        w.Close(); // foreach

        w.Line();
    }

    private static IEnumerable<MemberSymbol> EnumerateMembers(INamedTypeSymbol type, bool includeInternals, bool includeBase, TypeSchema schema)
    {
        var flags = new[] { Accessibility.Public }.ToImmutableHashSet();
        if (includeInternals) flags.Add(Accessibility.Internal);

        var set = new List<MemberSymbol>();

        var t = type;
        while (t is not null)
        {
            foreach (var m in t.GetMembers())
            {
                if (m is IPropertySymbol p && !p.IsStatic && p.GetMethod is not null && p.GetMethod.DeclaredAccessibility is var acc1 && flags.Contains(acc1))
                {
                    if (p.SetMethod is null) continue;
                    set.Add(new MemberSymbol(p.Name, p.Type, p));
                }
                else if (m is IFieldSymbol f && !f.IsStatic && f.DeclaredAccessibility is var acc2 && flags.Contains(acc2))
                {
                    if (f.IsReadOnly) continue;
                    set.Add(new MemberSymbol(f.Name, f.Type, f));
                }
            }

            if (!includeBase) break;
            t = t.BaseType;
        }

        var includes = schema.IncludeMembers;
        var ignores = schema.IgnoreMembers;

        var filtered = set
            .Where(ms => includes.Count == 0 || includes.Contains(ms.Name, StringComparer.Ordinal))
            .Where(ms => !ignores.Contains(ms.Name, StringComparer.Ordinal));

        return filtered;
    }

    private static IEnumerable<MemberSymbol> OrderMembers(IEnumerable<MemberSymbol> members) =>
        members.OrderBy(m => m.Name, StringComparer.Ordinal);

    private TypeSchema GetTypeSchema(INamedTypeSymbol type)
    {
        CompareKind defKind = CompareKind.Deep;
        bool defOrderInsensitive = false;
        bool defDeltaShallow = false;
        bool defDeltaSkip = false;
        var includes = new List<string>();
        var ignores = new List<string>();

        foreach (var a in type.GetAttributes())
        {
            if (a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName)
            {
                foreach (var kv in a.NamedArguments)
                {
                    switch (kv.Key)
                    {
                        case "Kind": defKind = (CompareKind)kv.Value.Value!; break;
                        case "OrderInsensitive": defOrderInsensitive = (bool)kv.Value.Value!; break;
                        case "Members": includes.AddRange(kv.Value.Values.Select(v => (string)v.Value!)); break;
                        case "IgnoreMembers": ignores.AddRange(kv.Value.Values.Select(v => (string)v.Value!)); break;
                        case "DeltaShallow": defDeltaShallow = (bool)kv.Value.Value!; break;
                        case "DeltaSkip": defDeltaSkip = (bool)kv.Value.Value!; break;
                    }
                }
            }
        }

        return new TypeSchema(includes, ignores, defKind, defOrderInsensitive, defDeltaShallow, defDeltaSkip);
    }

    private (CompareKind kind, bool orderInsensitive, string[] keys, bool deltaShallow, bool deltaSkip) ResolveEffectiveSettings(MemberSymbol member)
    {
        CompareKind kind = CompareKind.Deep;
        bool orderInsensitive = false;
        bool deltaShallow = false;
        bool deltaSkip = false;
        string[] keys = Array.Empty<string>();

        foreach (var a in member.Symbol.GetAttributes())
        {
            if (a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName)
            {
                foreach (var kv in a.NamedArguments)
                {
                    switch (kv.Key)
                    {
                        case "Kind": kind = (CompareKind)kv.Value.Value!; break;
                        case "OrderInsensitive": orderInsensitive = (bool)kv.Value.Value!; break;
                        case "KeyMembers": keys = kv.Value.Values.Select(v => (string)v.Value!).ToArray(); break;
                        case "DeltaShallow": deltaShallow = (bool)kv.Value.Value!; break;
                        case "DeltaSkip": deltaSkip = (bool)kv.Value.Value!; break;
                    }
                }
            }
        }

        return (kind, orderInsensitive, keys, deltaShallow, deltaSkip);
    }

    private static bool IsValueLike(ITypeSymbol t)
    {
        if (t.SpecialType == SpecialType.System_String) return true;
        if (t.IsValueType) return true;

        if (t is INamedTypeSymbol nn && nn.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Nullable<T>")
            return true;

        return false;
    }

    private static readonly SymbolDisplayFormat Fqn = SymbolDisplayFormat.FullyQualifiedFormat;
    private static bool IsEnumerable(ITypeSymbol t)
    {
        // arrays
        if (t is IArrayTypeSymbol) return true;

        // IEnumerable<T> implemented?
        foreach (var i in t.AllInterfaces)
        {
            if (i is INamedTypeSymbol ni &&
                ni.OriginalDefinition.ToDisplayString(Fqn) == "global::System.Collections.Generic.IEnumerable<T>")
                return true;
        }

        // type itself is an IEnumerable<T> (rare, but be thorough)
        if (t is INamedTypeSymbol nt &&
            nt.OriginalDefinition.ToDisplayString(Fqn) == "global::System.Collections.Generic.IEnumerable<T>")
            return true;

        return false;
    }

    private static bool IsDictionary(ITypeSymbol t)
    {
        static bool IsDict(INamedTypeSymbol x) =>
            x.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
            "global::System.Collections.Generic.IDictionary<TKey, TValue>" ||
            x.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
            "global::System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>";

        // via interfaces
        foreach (var i in t.AllInterfaces)
            if (i is INamedTypeSymbol ni && IsDict(ni))
                return true;

        // type itself is a dict
        if (t is INamedTypeSymbol nt && IsDict(nt))
            return true;

        return false;
    }

    private static string GetValueLikeEqualsInvocation(ITypeSymbol t, string leftExpr, string rightExpr)
    {
        // strings & numerics with your helpers
        if (t.SpecialType == SpecialType.System_String)
            return $"DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualStrings({leftExpr}, {rightExpr}, context)";
        if (t.SpecialType == SpecialType.System_Double)
            return $"DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualDouble({leftExpr}, {rightExpr}, context)";
        if (t.SpecialType == SpecialType.System_Single)
            return $"DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualSingle({leftExpr}, {rightExpr}, context)";
        if (t.SpecialType == SpecialType.System_Decimal)
            return $"DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualDecimal({leftExpr}, {rightExpr}, context)";

        var tfqn = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        return $"System.Collections.Generic.EqualityComparer<{tfqn}>.Default.Equals({leftExpr}, {rightExpr})";
    }

    private static int GetStableMemberIndex(INamedTypeSymbol owner, MemberSymbol member)
    {
        unchecked
        {
            var h = 17;
            foreach (var ch in owner.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
                h = h * 31 + ch;
            foreach (var ch in member.Name)
                h = h * 31 + ch;
            return (h & 0x7FFFFFFF) % 1_000_000_007;
        }
    }

    private static string SanitizeIdentifier(string s)
    {
        var sb = new StringBuilder(s.Length);
        foreach (var ch in s) sb.Append(char.IsLetterOrDigit(ch) ? ch : '_');
        return sb.ToString();
    }

    private static HashSet<INamedTypeSymbol> BuildReachableTypeClosure(Target root)
    {
        var set = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default)
            {
                root.Type
            };
        var queue = new Queue<INamedTypeSymbol>();
        queue.Enqueue(root.Type);

        while (queue.Count > 0)
        {
            var cur = queue.Dequeue();

            foreach (var member in EnumerateMembers(cur, root.IncludeInternals, root.IncludeBaseMembers, new TypeSchema(Array.Empty<string>(), Array.Empty<string>(), CompareKind.Deep, false, false, false)))
            {
                Accumulate(member.Type);
            }
        }

        return set;

        void Accumulate(ITypeSymbol t)
        {
            if (t is INamedTypeSymbol nnt && nnt.OriginalDefinition.ToDisplayString() == "System.Nullable<T>")
            {
                t = nnt.TypeArguments[0];
            }

            if (t is IArrayTypeSymbol at)
            {
                Accumulate(at.ElementType);
                return;
            }

            if (t is INamedTypeSymbol nn)
            {
                foreach (var i in nn.AllInterfaces)
                {
                    if (i is INamedTypeSymbol ii && ii.OriginalDefinition.ToDisplayString() == "System.Collections.Generic.IEnumerable<T>")
                    {
                        Accumulate(ii.TypeArguments[0]);
                    }
                    if (i is INamedTypeSymbol di && (di.OriginalDefinition.ToDisplayString() == "System.Collections.Generic.IDictionary<TKey, TValue>" ||
                                                     di.OriginalDefinition.ToDisplayString() == "System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>"))
                    {
                        Accumulate(di.TypeArguments[0]);
                        Accumulate(di.TypeArguments[1]);
                    }
                }
            }

            if (t is INamedTypeSymbol user && user.ContainingNamespace?.ToDisplayString() is { Length: > 0 } ns
                && !ns.StartsWith("System", StringComparison.Ordinal)
                && set.Add(user))
            {
                queue.Enqueue(user);
            }
        }
    }
}
internal sealed class CodeWriter
{
    private readonly StringBuilder _buffer = new();
    private int _indent;

    public void Line(string text = "")
    {
        if (text.Length == 0)
        {
            _buffer.AppendLine();
            return;
        }

        _buffer.Append(' ', _indent * 4);
        _buffer.AppendLine(text);
    }

    public void Open(string header)
    {
        Line(header);
        Line("{");
        _indent++;
    }

    public void Close()
    {
        _indent = Math.Max(0, _indent - 1);
        Line("}");
    }

    public override string ToString() => _buffer.ToString();
}
internal enum StableMemberIndexMode { Auto = 0, On = 1, Off = 2 }

public enum CompareKind
{
    Deep,
    Shallow,
    Reference,
    Skip
}