// DeepEqual.Generator/DeepEqualGenerator.cs
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DeepEqual.Generator;

[Generator(LanguageNames.CSharp)]
public sealed class DeepEqualGenerator : IIncrementalGenerator
{
    private const string DeepComparableAttributeName = "DeepEqual.Generator.Shared.DeepComparableAttribute";
    private const string DeepCompareAttributeName = "DeepEqual.Generator.Shared.DeepCompareAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var roots = context.SyntaxProvider.CreateSyntaxProvider(
            static (node, _) => node is TypeDeclarationSyntax { AttributeLists.Count: > 0 },
            static (ctx, _) => GetRootTarget(ctx)
        ).Where(t => t is not null);

        context.RegisterSourceOutput(roots, static (spc, target) =>
        {
            if (target is null) { return; }
            EmitForRoot(spc, target.Value);
        });
    }

    private static Target? GetRootTarget(GeneratorSyntaxContext context)
    {
        if (context.Node is not TypeDeclarationSyntax tds) { return null; }
        if (context.SemanticModel.GetDeclaredSymbol(tds) is not INamedTypeSymbol typeSymbol) { return null; }

        var deepComparable = typeSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepComparableAttributeName);
        if (deepComparable is null) { return null; }

        // Fixed: use IncludeInternals (previously read a non-existent IncludePrivateMembers)
        bool includeInternals = GetNamedBool(deepComparable, "IncludeInternals");
        bool orderInsensitiveCollections = GetNamedBool(deepComparable, "OrderInsensitiveCollections");
        return new Target(typeSymbol, includeInternals, orderInsensitiveCollections);
    }

    private static bool GetNamedBool(AttributeData attribute, string name)
    {
        foreach (var kv in attribute.NamedArguments)
        {
            if (kv.Key == name && kv.Value.Value is true) { return true; }
        }
        return false;
    }

    private static void EmitForRoot(SourceProductionContext spc, Target root)
    {
        var ns = root.Type.ContainingNamespace.IsGlobalNamespace ? null : root.Type.ContainingNamespace.ToDisplayString();
        var rootFullName = root.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var rootName = root.Type.Name;
        var helperClassName = $"{rootName}DeepEqual";
        var hintName = SanitizeFileName($"{rootFullName}_DeepEqual.g.cs");

        var reachableTypes = BuildReachableTypeClosure(root);

        var code = new StringBuilder();
        code.AppendLine("// <auto-generated />");
        code.AppendLine("#nullable enable");
        code.AppendLine("using System;");
        code.AppendLine("using System.Collections.Generic;");
        code.AppendLine("using DeepEqual.Generator.Shared;");

        if (ns is not null)
        {
            code.AppendLine($"namespace {ns}");
            code.AppendLine("{");
        }

        code.AppendLine($"    public static class {helperClassName}");
        code.AppendLine("    {");
        code.AppendLine("        static " + helperClassName + "()");
        code.AppendLine("        {");
        foreach (var t in reachableTypes
                         .Where(t => IsTypeAccessibleFromRoot(t, root))
                         .OrderBy(t => t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), StringComparer.Ordinal))
        {
            var fqn = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var helper = GetHelperMethodName(t);
            code.AppendLine($"            GeneratedHelperRegistry.Register<{fqn}>((l, r, ctx) => {helper}(l, r, ctx));");
        }
        code.AppendLine("        }");
        code.AppendLine();

        code.AppendLine(root.Type.IsValueType
            ? $"        public static bool AreDeepEqual({rootFullName} left, {rootFullName} right)"
            : $"        public static bool AreDeepEqual({rootFullName}? left, {rootFullName}? right)");
        code.AppendLine("        {");
        if (!root.Type.IsValueType)
        {
            code.AppendLine("            if (object.ReferenceEquals(left, right)) { return true; }");
            code.AppendLine("            if (left is null || right is null) { return false; }");
        }
        code.AppendLine("            var comparisonContext = new ComparisonContext();");
        code.AppendLine($"            return {GetHelperMethodName(root.Type)}(left, right, comparisonContext);");
        code.AppendLine("        }");
        code.AppendLine();

        foreach (var type in reachableTypes.OrderBy(t => t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), StringComparer.Ordinal))
        {
            EmitHelperForType(code, type, root);
        }

        code.AppendLine("    }");

        // Ensure registration runs even if consumers only use the dynamic comparer.
        code.AppendLine();
        code.AppendLine($"    internal static class __DeepEqualInit_{SanitizeIdentifier(helperClassName)}");
        code.AppendLine("    {");
        code.AppendLine("        [System.Runtime.CompilerServices.ModuleInitializer]");
        code.AppendLine("        internal static void Init()");
        code.AppendLine("        {");
        code.AppendLine($"            _ = typeof({helperClassName}); // force static .cctor to run and register helpers");
        code.AppendLine("        }");
        code.AppendLine("    }");

        if (ns is not null)
        {
            code.AppendLine("}");
        }

        spc.AddSource(hintName, code.ToString());
    }

    private static void EmitHelperForType(StringBuilder code, INamedTypeSymbol type, Target root)
    {
        var fullName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var helperName = GetHelperMethodName(type);

        code.AppendLine($"        private static bool {helperName}({fullName} left, {fullName} right, ComparisonContext context)");
        code.AppendLine("        {");
        if (!type.IsValueType)
        {
            code.AppendLine("            if (object.ReferenceEquals(left, right)) { return true; }");
            code.AppendLine("            if (left is null || right is null) { return false; }");
            code.AppendLine("            if (!context.Enter(left, right)) { return true; }");
            code.AppendLine("            try");
            code.AppendLine("            {");
        }

        var schema = GetTypeSchema(type);
        foreach (var member in EnumerateComparableMembers(type, root.IncludeInternals, schema).OrderBy(m => m.Name, StringComparer.Ordinal))
        {
            EmitMemberComparison(code, member, root);
        }

        if (!type.IsValueType)
        {
            code.AppendLine("                return true;");
            code.AppendLine("            }");
            code.AppendLine("            finally { context.Exit(left, right); }");
            code.AppendLine("        }");
            code.AppendLine();
            return;
        }

        code.AppendLine("            return true;");
        code.AppendLine("        }");
        code.AppendLine();
    }

    private sealed record TypeSchema(IReadOnlyList<string> IncludeMembers, IReadOnlyList<string> IgnoreMembers);

    private static TypeSchema GetTypeSchema(INamedTypeSymbol type)
    {
        var attr = type.GetAttributes().FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);
        if (attr is null) { return new TypeSchema(Array.Empty<string>(), Array.Empty<string>()); }

        static string[] ReadStringArray(TypedConstant arg)
        {
            if (arg is { Kind: TypedConstantKind.Array, IsNull: false })
            {
                return arg.Values.Select(v => v.Value?.ToString() ?? string.Empty)
                                 .Where(s => !string.IsNullOrWhiteSpace(s))
                                 .ToArray();
            }
            return Array.Empty<string>();
        }

        string[] include = Array.Empty<string>();
        string[] ignore = Array.Empty<string>();
        foreach (var kv in attr.NamedArguments)
        {
            if (kv.Key == "Members") { include = ReadStringArray(kv.Value); }
            else if (kv.Key == "IgnoreMembers") { ignore = ReadStringArray(kv.Value); }
        }
        return new TypeSchema(include, ignore);
    }

    private static IEnumerable<MemberSymbol> EnumerateComparableMembers(INamedTypeSymbol type, bool assemblyLocalInternals, TypeSchema schema)
    {
        static bool IsAccessible(ISymbol s, bool inclInternals, INamedTypeSymbol owner)
        {
            return s.DeclaredAccessibility switch
            {
                Accessibility.Public => true,
                Accessibility.Internal or Accessibility.ProtectedAndInternal
                    => inclInternals && SymbolEqualityComparer.Default.Equals(s.ContainingAssembly, owner.ContainingAssembly),
                _ => false
            };
        }

        bool hasInclude = schema.IncludeMembers.Count > 0;
        var includeSet = hasInclude ? new HashSet<string>(schema.IncludeMembers, StringComparer.Ordinal) : null;
        var ignoreSet = schema.IgnoreMembers.Count > 0 ? new HashSet<string>(schema.IgnoreMembers, StringComparer.Ordinal) : null;

        foreach (var p in type.GetMembers().OfType<IPropertySymbol>())
        {
            if (p.IsStatic) { continue; }
            if (p.Parameters.Length != 0) { continue; }
            if (p.GetMethod is null) { continue; }
            if (!IsAccessible(p, assemblyLocalInternals, type)) { continue; }
            if (hasInclude && !includeSet!.Contains(p.Name)) { continue; }
            if (ignoreSet is not null && ignoreSet.Contains(p.Name)) { continue; }

            if (type.IsValueType && SymbolEqualityComparer.Default.Equals(p.Type, type) && !hasInclude) { continue; }

            yield return new MemberSymbol(p.Name, p.Type, p);
        }

        foreach (var f in type.GetMembers().OfType<IFieldSymbol>())
        {
            if (f.IsStatic) { continue; }
            if (f.IsConst) { continue; }
            if (f.IsImplicitlyDeclared) { continue; }
            if (f.AssociatedSymbol is not null) { continue; }
            if (f.Name.StartsWith("<", StringComparison.Ordinal)) { continue; }
            if (!IsAccessible(f, assemblyLocalInternals, type)) { continue; }
            if (hasInclude && !includeSet!.Contains(f.Name)) { continue; }
            if (ignoreSet is not null && ignoreSet.Contains(f.Name)) { continue; }

            if (type.IsValueType && SymbolEqualityComparer.Default.Equals(f.Type, type) && !hasInclude) { continue; }

            yield return new MemberSymbol(f.Name, f.Type, f);
        }
    }

    private static void EmitMemberComparison(StringBuilder code, MemberSymbol member, Target root)
    {
        var leftAccess = $"left.{member.Name}";
        var rightAccess = $"right.{member.Name}";
        var memberType = member.Type;

        var deepCompareAttr = GetDeepCompareAttribute(member.Symbol);
        var comparisonKind = GetEffectiveKind(memberType, deepCompareAttr);

        var localBase = $"member_{member.Name}";
        var leftLocal = $"{localBase}_left";
        var rightLocal = $"{localBase}_right";

        code.AppendLine($"            var {leftLocal} = {leftAccess};");
        code.AppendLine($"            var {rightLocal} = {rightAccess};");

        if (comparisonKind == EffectiveKind.Skip) { return; }

        if (!memberType.IsValueType)
        {
            code.AppendLine($"            if (!object.ReferenceEquals({leftLocal}, {rightLocal}))");
            code.AppendLine("            {");
            code.AppendLine($"                if ({leftLocal} is null || {rightLocal} is null) {{ return false; }}");
            code.AppendLine("            }");
        }

        if (comparisonKind == EffectiveKind.Reference)
        {
            if (memberType.IsReferenceType)
            {
                code.AppendLine($"            if (!object.ReferenceEquals({leftLocal}, {rightLocal})) {{ return false; }}");
            }
            else
            {
                code.AppendLine($"            if (!{leftLocal}.Equals({rightLocal})) {{ return false; }}");
            }
            return;
        }

        if (comparisonKind == EffectiveKind.Shallow)
        {
            if (TryEmitWellKnownStructCompare(code, leftLocal, rightLocal, memberType)) { return; }

            if (memberType.SpecialType == SpecialType.System_String)
            {
                code.AppendLine($"            if (!ComparisonHelpers.AreEqualStrings({leftLocal}, {rightLocal})) {{ return false; }}");
            }
            else if (memberType.IsValueType)
            {
                code.AppendLine($"            if (!{leftLocal}.Equals({rightLocal})) {{ return false; }}");
            }
            else
            {
                code.AppendLine($"            if (!object.Equals({leftLocal}, {rightLocal})) {{ return false; }}");
            }
            return;
        }

        // object-typed member → dynamic path
        if (memberType.SpecialType == SpecialType.System_Object)
        {
            code.AppendLine($"            if (!DynamicDeepComparer.AreEqualDynamic({leftLocal}, {rightLocal}, context)) {{ return false; }}");
            return;
        }

        if (memberType is INamedTypeSymbol nnt && nnt.OriginalDefinition.ToDisplayString() == "System.Nullable<T>")
        {
            var valueT = nnt.TypeArguments[0];
            code.AppendLine($"            if ({leftLocal}.HasValue != {rightLocal}.HasValue) {{ return false; }}");
            code.AppendLine($"            if ({leftLocal}.HasValue)");
            code.AppendLine("            {");
            EmitNullableValueCompare(code, leftLocal, rightLocal, valueT, root);
            code.AppendLine("            }");
            return;
        }

        if (TryEmitWellKnownStructCompare(code, leftLocal, rightLocal, memberType)) { return; }

        if (memberType.SpecialType == SpecialType.System_String)
        {
            code.AppendLine($"            if (!ComparisonHelpers.AreEqualStrings({leftLocal}, {rightLocal})) {{ return false; }}");
            return;
        }

        if (memberType.TypeKind == TypeKind.Enum)
        {
            code.AppendLine($"            if (!ComparisonHelpers.AreEqualEnum({leftLocal}, {rightLocal})) {{ return false; }}");
            return;
        }

        if (memberType.IsValueType && memberType.SpecialType != SpecialType.None)
        {
            code.AppendLine($"            if (!{leftLocal}.Equals({rightLocal})) {{ return false; }}");
            return;
        }

        if (memberType is IArrayTypeSymbol arrayType)
        {
            var elementType = arrayType.ElementType;
            var unordered = ResolveOrderInsensitive(root, deepCompareAttr, elementType);
            var elementKind = GetEffectiveKind(elementType, null);
            var elementLambda = BuildElementComparerLambda(elementType, elementKind, root);
            var elementFullName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            if (unordered)
            {
                code.AppendLine($"            if (!ComparisonHelpers.AreEqualArrayUnordered<{elementFullName}>((Array?){leftLocal}, (Array?){rightLocal}, {elementLambda}, context)) {{ return false; }}");
            }
            else
            {
                code.AppendLine($"            if (!ComparisonHelpers.AreEqualArray<{elementFullName}>((Array?){leftLocal}, (Array?){rightLocal}, {elementLambda}, context)) {{ return false; }}");
            }
            return;
        }

        // strongly-typed dictionaries (IDictionary<,> and IReadOnlyDictionary<,>)
        if (TryGetDictionaryInterface(memberType, out var keyType, out var valueType))
        {
            var keyFullName = keyType!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var valueFullName = valueType!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var valueKind = GetEffectiveKind(valueType, null);
            var valueLambda = BuildElementComparerLambda(valueType, valueKind, root);

            // Hand over all coercion to helpers (works for IDictionary<,> and IReadOnlyDictionary<,>)
            code.AppendLine($"            if (!ComparisonHelpers.AreEqualDictionaries<{keyFullName}, {valueFullName}>(");
            code.AppendLine($"                {leftLocal} as global::System.Collections.Generic.IEnumerable<global::System.Collections.Generic.KeyValuePair<{keyFullName}, {valueFullName}>>,");
            code.AppendLine($"                {rightLocal} as global::System.Collections.Generic.IEnumerable<global::System.Collections.Generic.KeyValuePair<{keyFullName}, {valueFullName}>>,");
            code.AppendLine($"                {valueLambda}, context)) {{ return false; }}");
            return;
        }

        // dynamic map path (Expando, non-generic IDictionary, IReadOnlyDictionary<string,*>)
        if (IsStringKeyedDictionary(memberType))
        {
            code.AppendLine($"            if (!DynamicDeepComparer.AreEqualDynamic({leftLocal}, {rightLocal}, context)) {{ return false; }}");
            return;
        }

        // IEnumerable<object> or object[] → dynamic element compare
        if (IsObjectEnumerable(memberType))
        {
            code.AppendLine($"            if (!ComparisonHelpers.AreEqualSequencesOrdered<object>(");
            code.AppendLine($"                {leftLocal} as System.Collections.Generic.IEnumerable<object>,");
            code.AppendLine($"                {rightLocal} as System.Collections.Generic.IEnumerable<object>,");
            code.AppendLine($"                (l, r, c) => DynamicDeepComparer.AreEqualDynamic(l, r, c), context)) {{ return false; }}");
            return;
        }

        if (TryGetEnumerableInterface(memberType, out var enumerableElementType))
        {
            var elementKind = GetEffectiveKind(enumerableElementType!, null);
            var unordered = ResolveOrderInsensitive(root, deepCompareAttr, enumerableElementType!);
            var elementLambda = BuildElementComparerLambda(enumerableElementType!, elementKind, root);
            var api = unordered ? "AreEqualSequencesUnordered" : "AreEqualSequencesOrdered";
            var elementFullName = enumerableElementType!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            code.AppendLine($"            if (!ComparisonHelpers.{api}<{elementFullName}>(");
            code.AppendLine($"                {leftLocal} as global::System.Collections.Generic.IEnumerable<{elementFullName}>,");
            code.AppendLine($"                {rightLocal} as global::System.Collections.Generic.IEnumerable<{elementFullName}>,");
            code.AppendLine($"                {elementLambda}, context)) {{ return false; }}");
            return;
        }

        if (memberType is INamedTypeSymbol namedType && IsUserObjectType(namedType))
        {
            if (IsTypeAccessibleFromRoot(namedType, root))
            {
                code.AppendLine($"            if (!{GetHelperMethodName(namedType)}({leftLocal}, {rightLocal}, context)) {{ return false; }}");
            }
            else
            {
                code.AppendLine($"            if (!object.Equals({leftLocal}, {rightLocal})) {{ return false; }}");
            }
            return;
        }

        code.AppendLine($"            if (!object.Equals({leftLocal}, {rightLocal})) {{ return false; }}");
    }

    private static bool TryEmitWellKnownStructCompare(StringBuilder code, string leftExpr, string rightExpr, ITypeSymbol t)
    {
        if (t.SpecialType == SpecialType.System_DateTime)
        {
            code.AppendLine($"            if (!ComparisonHelpers.AreEqualDateTime({leftExpr}, {rightExpr})) {{ return false; }}");
            return true;
        }

        var fqn = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        if (fqn == "global::System.DateTimeOffset")
        {
            code.AppendLine($"            if (!ComparisonHelpers.AreEqualDateTimeOffset({leftExpr}, {rightExpr})) {{ return false; }}");
            return true;
        }

        if (fqn == "global::System.TimeSpan")
        {
            code.AppendLine($"            if ({leftExpr}.Ticks != {rightExpr}.Ticks) {{ return false; }}");
            return true;
        }

        if (fqn == "global::System.Guid")
        {
            code.AppendLine($"            if (!{leftExpr}.Equals({rightExpr})) {{ return false; }}");
            return true;
        }

        // New: DateOnly / TimeOnly (net6+)
        if (fqn == "global::System.DateOnly")
        {
            code.AppendLine($"            if (!ComparisonHelpers.AreEqualDateOnly({leftExpr}, {rightExpr})) {{ return false; }}");
            return true;
        }
        if (fqn == "global::System.TimeOnly")
        {
            code.AppendLine($"            if (!ComparisonHelpers.AreEqualTimeOnly({leftExpr}, {rightExpr})) {{ return false; }}");
            return true;
        }

        // New: Memory<T> / ReadOnlyMemory<T> -> compare contents
        if (t is INamedTypeSymbol gn && gn.OriginalDefinition?.ToDisplayString() == "System.Memory<T>")
        {
            code.AppendLine($"            if (!ComparisonHelpers.AreEqualMemory({leftExpr}, {rightExpr})) {{ return false; }}");
            return true;
        }
        if (t is INamedTypeSymbol gr && gr.OriginalDefinition?.ToDisplayString() == "System.ReadOnlyMemory<T>")
        {
            code.AppendLine($"            if (!ComparisonHelpers.AreEqualReadOnlyMemory({leftExpr}, {rightExpr})) {{ return false; }}");
            return true;
        }

        return false;
    }

    private static void EmitNullableValueCompare(StringBuilder code, string leftLocal, string rightLocal, ITypeSymbol valueType, Target root)
    {
        if (TryEmitWellKnownStructCompare(code, $"{leftLocal}.Value", $"{rightLocal}.Value", valueType)) { return; }

        if (valueType.TypeKind == TypeKind.Enum)
        {
            code.AppendLine($"                if (!ComparisonHelpers.AreEqualEnum({leftLocal}.Value, {rightLocal}.Value)) {{ return false; }}");
            return;
        }

        if (valueType.IsValueType && valueType.SpecialType != SpecialType.None)
        {
            code.AppendLine($"                if (!{leftLocal}.Value.Equals({rightLocal}.Value)) {{ return false; }}");
            return;
        }

        if (valueType is INamedTypeSymbol vnts && IsUserObjectType(vnts))
        {
            if (IsTypeAccessibleFromRoot(vnts, root))
            {
                code.AppendLine($"                if (!{GetHelperMethodName(vnts)}({leftLocal}.Value, {rightLocal}.Value, context)) {{ return false; }}");
            }
            else
            {
                code.AppendLine($"                if (!object.Equals({leftLocal}.Value, {rightLocal}.Value)) {{ return false; }}");
            }
            return;
        }

        code.AppendLine($"                if (!object.Equals({leftLocal}.Value, {rightLocal}.Value)) {{ return false; }}");
    }

    private static string BuildElementComparerLambda(ITypeSymbol elementType, EffectiveKind elementKind, Target root)
    {
        // KeyValuePair<K,V>
        if (elementType is INamedTypeSymbol kvp &&
            kvp.ConstructedFrom?.ToDisplayString() == "System.Collections.Generic.KeyValuePair<TKey, TValue>")
        {
            var k = kvp.TypeArguments[0];
            var v = kvp.TypeArguments[1];

            var keyLambda = BuildElementComparerLambda(k, GetEffectiveKind(k, null), root);
            var valLambda = BuildElementComparerLambda(v, GetEffectiveKind(v, null), root);

            string keyCmp = keyLambda.Replace("(l,", "(l.Key,").Replace(", r,", ", r.Key,");
            string valCmp = valLambda.Replace("(l,", "(l.Value,").Replace(", r,", ", r.Value,");
            return $"(l, r, c) => {keyCmp} && {valCmp}";
        }

        if (elementType is INamedTypeSymbol nt && nt.OriginalDefinition.ToDisplayString() == "System.Nullable<T>")
        {
            var tArg = nt.TypeArguments[0];

            if (tArg.TypeKind == TypeKind.Enum)
            {
                return "(l, r, c) => (l.HasValue == r.HasValue) && (!l.HasValue || ComparisonHelpers.AreEqualEnum(l.Value, r.Value))";
            }

            if (tArg.SpecialType == SpecialType.System_DateTime)
            {
                return "(l, r, c) => (l.HasValue == r.HasValue) && (!l.HasValue || ComparisonHelpers.AreEqualDateTime(l.Value, r.Value))";
            }

            if (tArg.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.DateTimeOffset")
            {
                return "(l, r, c) => (l.HasValue == r.HasValue) && (!l.HasValue || ComparisonHelpers.AreEqualDateTimeOffset(l.Value, r.Value))";
            }

            // DateOnly / TimeOnly
            if (tArg.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.DateOnly")
            {
                return "(l, r, c) => (l.HasValue == r.HasValue) && (!l.HasValue || ComparisonHelpers.AreEqualDateOnly(l.Value, r.Value))";
            }
            if (tArg.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.TimeOnly")
            {
                return "(l, r, c) => (l.HasValue == r.HasValue) && (!l.HasValue || ComparisonHelpers.AreEqualTimeOnly(l.Value, r.Value))";
            }

            if (tArg.IsValueType && tArg.SpecialType != SpecialType.None)
            {
                return "(l, r, c) => (l.HasValue == r.HasValue) && (!l.HasValue || l.Value.Equals(r.Value))";
            }

            if (tArg is INamedTypeSymbol sArg && IsUserObjectType(sArg) && IsTypeAccessibleFromRoot(sArg, root))
            {
                var helper = GetHelperMethodName(sArg);
                return $"(l, r, c) => (l.HasValue == r.HasValue) && (!l.HasValue || {helper}(l.Value, r.Value, c))";
            }

            return "(l, r, c) => (l.HasValue == r.HasValue) && (!l.HasValue || object.Equals(l.Value, r.Value))";
        }

        if (elementType.TypeKind == TypeKind.Enum)
        {
            return "(l, r, c) => ComparisonHelpers.AreEqualEnum(l, r)";
        }

        if (elementType.SpecialType == SpecialType.System_DateTime)
        {
            return "(l, r, c) => ComparisonHelpers.AreEqualDateTime(l, r)";
        }

        if (elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.DateTimeOffset")
        {
            return "(l, r, c) => ComparisonHelpers.AreEqualDateTimeOffset(l, r)";
        }

        // DateOnly / TimeOnly
        if (elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.DateOnly")
        {
            return "(l, r, c) => ComparisonHelpers.AreEqualDateOnly(l, r)";
        }
        if (elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.TimeOnly")
        {
            return "(l, r, c) => ComparisonHelpers.AreEqualTimeOnly(l, r)";
        }

        if (elementType.IsValueType && elementType.SpecialType != SpecialType.None)
        {
            return "(l, r, c) => l.Equals(r)";
        }

        if (elementType.IsValueType && elementType is INamedTypeSymbol structType && IsUserObjectType(structType))
        {
            if (IsTypeAccessibleFromRoot(structType, root))
            {
                var helper = GetHelperMethodName(structType);
                return $"(l, r, c) => {helper}(l, r, c)";
            }
            return "(l, r, c) => l.Equals(r)";
        }

        if (elementType.SpecialType == SpecialType.System_String)
        {
            return "(l, r, c) => object.ReferenceEquals(l, r) ? true : (l is null || r is null ? false : ComparisonHelpers.AreEqualStrings(l, r))";
        }

        if (elementKind == EffectiveKind.Shallow)
        {
            return "(l, r, c) => object.Equals(l, r)";
        }

        if (elementKind == EffectiveKind.Reference)
        {
            return "(l, r, c) => object.ReferenceEquals(l, r)";
        }

        if (elementType is INamedTypeSymbol nts && IsUserObjectType(nts) && IsTypeAccessibleFromRoot(nts, root))
        {
            var helper = GetHelperMethodName(nts);
            return $"(l, r, c) => object.ReferenceEquals(l, r) ? true : (l is null || r is null ? false : {helper}(l, r, c))";
        }

        return "(l, r, c) => object.Equals(l, r)";
    }

    private static bool IsTypeAccessibleFromRoot(INamedTypeSymbol t, Target root)
    {
        // Public types with all public containers are always fine.
        if (t.DeclaredAccessibility == Accessibility.Public)
        {
            var cur = t.ContainingType;
            while (cur is not null)
            {
                if (cur.DeclaredAccessibility != Accessibility.Public) { return false; }
                cur = cur.ContainingType;
            }
            return true;
        }

        // Internal/protected-internal allowed only when IncludeInternals=true AND within same assembly,
        // and all container types are public or internal/protected-internal.
        if (!root.IncludeInternals) return false;
        if (!SymbolEqualityComparer.Default.Equals(t.ContainingAssembly, root.Type.ContainingAssembly)) return false;

        var c = t;
        while (c is not null)
        {
            var acc = c.DeclaredAccessibility;
            if (acc is Accessibility.Public or Accessibility.Internal or Accessibility.ProtectedAndInternal)
            {
                c = c.ContainingType;
                continue;
            }
            return false;
        }
        return true;
    }

    private static HashSet<INamedTypeSymbol> BuildReachableTypeClosure(Target root)
    {
        var set = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
        var queue = new Queue<INamedTypeSymbol>();

        set.Add(root.Type);
        queue.Enqueue(root.Type);

        while (queue.Count > 0)
        {
            var current = queue.Dequeue();
            var schema = GetTypeSchema(current);

            foreach (var member in EnumerateComparableMembers(current, root.IncludeInternals, schema))
            {
                var kind = GetEffectiveKind(member.Type, GetDeepCompareAttribute(member.Symbol));
                if (kind == EffectiveKind.Skip || kind == EffectiveKind.Shallow || kind == EffectiveKind.Reference) { continue; }
                Accumulate(member.Type);
            }
        }
        return set;

        void Accumulate(ITypeSymbol t)
        {
            if (t is IArrayTypeSymbol at) { Accumulate(at.ElementType); return; }
            if (TryGetDictionaryInterface(t, out _, out var valT)) { Accumulate(valT!); return; }
            if (TryGetEnumerableInterface(t, out var elT)) { Accumulate(elT!); return; }

            if (t is INamedTypeSymbol named && IsUserObjectType(named) && IsTypeAccessibleFromRoot(named, root) && set.Add(named))
            {
                queue.Enqueue(named);
            }
        }
    }

    private static bool TryGetEnumerableInterface(ITypeSymbol type, out ITypeSymbol? elementType)
    {
        foreach (var i in type.AllInterfaces)
        {
            if (i.OriginalDefinition.ToDisplayString() == "System.Collections.Generic.IEnumerable<T>")
            {
                elementType = i.TypeArguments[0];
                return true;
            }
        }
        elementType = null;
        return false;
    }

    private static bool TryGetDictionaryInterface(ITypeSymbol type, out ITypeSymbol? keyType, out ITypeSymbol? valueType)
    {
        foreach (var i in type.AllInterfaces)
        {
            var def = i.OriginalDefinition.ToDisplayString();
            if (def == "System.Collections.Generic.IDictionary<TKey, TValue>" ||
                def == "System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>")
            {
                keyType = i.TypeArguments[0];
                valueType = i.TypeArguments[1];
                return true;
            }
        }
        keyType = null; valueType = null; return false;
    }

    private static bool IsStringKeyedDictionary(ITypeSymbol t)
    {
        // ExpandoObject
        if (t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Dynamic.ExpandoObject")
        {
            return true;
        }

        // IDictionary<string, TValue> OR IReadOnlyDictionary<string, TValue>
        foreach (var i in t.AllInterfaces)
        {
            var def = i.OriginalDefinition.ToDisplayString();
            if ((def == "System.Collections.Generic.IDictionary<TKey, TValue>" ||
                 def == "System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>") &&
                i.TypeArguments[0].SpecialType == SpecialType.System_String)
            {
                return true;
            }
        }

        // Non-generic IDictionary
        return t.AllInterfaces.Any(x => x.ToDisplayString() == "System.Collections.IDictionary");
    }

    private static bool IsObjectEnumerable(ITypeSymbol t)
    {
        foreach (var i in t.AllInterfaces)
        {
            if (i.OriginalDefinition.ToDisplayString() == "System.Collections.Generic.IEnumerable<T>" &&
                i.TypeArguments[0].SpecialType == SpecialType.System_Object)
            {
                return true;
            }
        }
        return t is IArrayTypeSymbol at && at.ElementType.SpecialType == SpecialType.System_Object;
    }

    private static string GetHelperMethodName(INamedTypeSymbol type)
    {
        var fullName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        return $"AreDeepEqual__{SanitizeIdentifier(fullName)}";
    }

    private static string SanitizeIdentifier(string value)
    {
        var sb = new StringBuilder(value.Length + 8);
        foreach (var ch in value) { sb.Append(char.IsLetterOrDigit(ch) ? ch : '_'); }
        return sb.ToString();
    }

    private static string SanitizeFileName(string value)
    {
        var invalid = System.IO.Path.GetInvalidFileNameChars();
        var arr = value.Select(ch => invalid.Contains(ch) ? '_' : ch).ToArray();
        return new string(arr);
    }

    private static AttributeData? GetDeepCompareAttribute(ISymbol symbol)
    {
        return symbol.GetAttributes().FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);
    }

    private enum EffectiveKind { Deep = 0, Shallow = 1, Reference = 2, Skip = 3 }

    private static EffectiveKind GetEffectiveKind(ITypeSymbol type, AttributeData? memberAttribute)
    {
        if (memberAttribute is not null)
        {
            var val = memberAttribute.NamedArguments.FirstOrDefault(p => p.Key == "Kind").Value.Value;
            if (val is int mk) { return (EffectiveKind)mk; }
        }

        var typeAttr = type.OriginalDefinition.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);
        if (typeAttr is not null)
        {
            var val = typeAttr.NamedArguments.FirstOrDefault(p => p.Key == "Kind").Value.Value;
            if (val is int tk) { return (EffectiveKind)tk; }
        }

        return EffectiveKind.Deep;
    }

    private static bool ResolveOrderInsensitive(Target root, AttributeData? memberAttribute, ITypeSymbol elementType)
    {
        if (memberAttribute is not null)
        {
            var opt = memberAttribute.NamedArguments.FirstOrDefault(a => a.Key == "OrderInsensitive").Value;
            if (opt.Value is bool b) { return b; }
        }

        var typeAttr = elementType.OriginalDefinition.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);
        if (typeAttr is not null)
        {
            var opt = typeAttr.NamedArguments.FirstOrDefault(a => a.Key == "OrderInsensitive").Value;
            if (opt.Value is bool b) { return b; }
        }

        return root.OrderInsensitiveCollections;
    }

    private static bool IsUserObjectType(ITypeSymbol type)
    {
        return (type.TypeKind is TypeKind.Class or TypeKind.Struct)
               && type.SpecialType == SpecialType.None
               && type is not IArrayTypeSymbol;
    }

    private readonly record struct Target(INamedTypeSymbol Type, bool IncludeInternals, bool OrderInsensitiveCollections);
    private readonly record struct MemberSymbol(string Name, ITypeSymbol Type, ISymbol Symbol);
}
