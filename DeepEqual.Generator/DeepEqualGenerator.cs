// DeepEqual.Generator/DeepEqualGenerator.cs
// <auto-generated />
#nullable enable

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DeepEqual.Generator;

[Generator(LanguageNames.CSharp)]
public sealed class DeepEqualGenerator : IIncrementalGenerator
{
    private const string DeepComparableAttributeName = "DeepEqual.Generator.Shared.DeepComparableAttribute";
    private const string DeepCompareAttributeName = "DeepEqual.Generator.Shared.DeepCompareAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var roots = context.SyntaxProvider.CreateSyntaxProvider(
            static (node, _) => node is TypeDeclarationSyntax { AttributeLists.Count: > 0 },
            static (ctx, _) => GetRootTarget(ctx)
        ).Where(t => t is not null);

        context.RegisterSourceOutput(roots, static (spc, target) =>
        {
            if (target is null) return;
            EmitForRoot(spc, target.Value);
        });
    }

    // -------- model --------

    private readonly record struct Target(INamedTypeSymbol Type, bool IncludeInternals, bool OrderInsensitiveCollections);
    private readonly record struct MemberSymbol(string Name, ITypeSymbol Type, ISymbol Symbol);

    private sealed record TypeSchema(IReadOnlyList<string> IncludeMembers, IReadOnlyList<string> IgnoreMembers);

    private enum EffectiveKind { Deep = 0, Shallow = 1, Reference = 2, Skip = 3 }

    // -------- pipeline --------

    private static Target? GetRootTarget(GeneratorSyntaxContext context)
    {
        if (context.Node is not TypeDeclarationSyntax tds) return null;
        if (context.SemanticModel.GetDeclaredSymbol(tds) is not INamedTypeSymbol typeSymbol) return null;

        var deepComparable = typeSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepComparableAttributeName);
        if (deepComparable is null) return null;

        // NOTE: tolerate past typo "IncludePrivateMembers" for back-compat.
        bool includeInternals = GetNamedBool(deepComparable, "IncludeInternals") || GetNamedBool(deepComparable, "IncludePrivateMembers");
        bool orderInsensitive = GetNamedBool(deepComparable, "OrderInsensitiveCollections");

        return new Target(typeSymbol, includeInternals, orderInsensitive);
    }

    private static bool GetNamedBool(AttributeData attribute, string name)
        => attribute.NamedArguments.Any(kv => kv.Key == name && kv.Value.Value is true);

    private static void EmitForRoot(SourceProductionContext spc, Target root)
    {
        var ns = root.Type.ContainingNamespace.IsGlobalNamespace ? null : root.Type.ContainingNamespace.ToDisplayString();
        var rootFullName = root.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var rootName = root.Type.Name;
        var helperClass = $"{rootName}DeepEqual";
        var hintName = SanitizeFileName($"{rootFullName}_DeepEqual.g.cs");

        var reachable = BuildReachableTypeClosure(root);

        var cw = new CodeWriter();

        cw.Line("// <auto-generated /> DO NOT EDIT");
        cw.Line("using System;");
        cw.Line("using System.Collections;");
        cw.Line("using System.Collections.Generic;");
        cw.Line("using DeepEqual.Generator.Shared;");
        cw.Line();

        if (ns is not null)
        {
            cw.Open($"namespace {ns}");
        }

        var accessibility = root.IncludeInternals || root.Type.DeclaredAccessibility != Accessibility.Public ? "internal" : "public";
        var typeParameters = root.Type.Arity > 0 ? $"<{string.Join(",", root.Type.TypeArguments.Select(x => x.Name))}>" : "";
        cw.Open($"{accessibility} static class {helperClass}{typeParameters}");
        {
            // Registration static ctor
            cw.Open($"static {helperClass}()");
            foreach (var t in reachable
                     .Where(t => IsTypeAccessibleFromRoot(t, root))
                     .OrderBy(t => t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), StringComparer.Ordinal))
            {
                var fqn = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var helper = GetHelperMethodName(t);
                cw.Line($"GeneratedHelperRegistry.Register<{fqn}>((l, r, ctx) => {helper}(l, r, ctx));");
            }
            cw.Close(); // static ctor
            cw.Line();

            if (root.Type.IsValueType)
            {
                cw.Open($"{accessibility} static bool AreDeepEqual({rootFullName} left, {rootFullName} right)");
            }
            else
            {
                cw.Open($"{accessibility} static bool AreDeepEqual({rootFullName}? left, {rootFullName}? right)");
            }

            if (!root.Type.IsValueType)
            {
                cw.Open("if (object.ReferenceEquals(left, right))");
                cw.Line("return true;");
                cw.Close();

                cw.Open("if (left is null || right is null)");
                cw.Line("return false;");
                cw.Close();
            }
            cw.Line("var context = new DeepEqual.Generator.Shared.ComparisonContext();");
            cw.Line($"return {GetHelperMethodName(root.Type)}(left, right, context);");
            cw.Close(); // AreDeepEqual
            cw.Line();

            if (root.Type.IsValueType)
            {
                cw.Open($"{accessibility} static TraceResult DeepEqualWithTrace({rootFullName} left, {rootFullName} right)");
            }
            else
            {
                cw.Open($"{accessibility} static TraceResult DeepEqualWithTrace({rootFullName}? left, {rootFullName}? right)");
            }

            cw.Line("var diffs = new List<string>(capacity: 16);");
            cw.Line("var context = new DeepEqual.Generator.Shared.ComparisonContext();");

            if (!root.Type.IsValueType)
            {
                cw.Open("if (object.ReferenceEquals(left, right))");
                cw.Line("return new TraceResult(true, diffs);");
                cw.Close();

                cw.Open("if (left is null || right is null)");
                cw.Line("diffs.Add(\"(root): one is null and the other is not\");");
                cw.Line("return new TraceResult(false, diffs);");
                cw.Close();
            }

            cw.Line($"CollectDifferences__{SanitizeIdentifier(root.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))}(left, right, string.Empty, context, diffs);");
            cw.Line("return new TraceResult(diffs.Count == 0, diffs);");
            cw.Close(); // DeepEqualWithTrace
            cw.Line();

            // Helper: TraceResult + path util
            cw.Open($"{accessibility}  readonly struct TraceResult");
            cw.Line($"{accessibility}  bool AreEqual {{ get; }}");
            cw.Line($"{accessibility}  IReadOnlyList<string> Differences {{ get; }}");
            cw.Open($"{accessibility}  TraceResult(bool areEqual, IReadOnlyList<string> differences)");
            cw.Line("AreEqual = areEqual;");
            cw.Line("Differences = differences;");
            cw.Close();
            cw.Close(); // struct
            cw.Line();

            cw.Open("private static string AppendPath(string path, string segment)");
            cw.Line("return string.IsNullOrEmpty(path) ? segment : path + \".\" + segment;");
            cw.Close();
            cw.Line();

            // Emit fast-fail helpers (NOW ORDERED BY COST)
            foreach (var t in reachable.OrderBy(t => t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), StringComparer.Ordinal))
            {
                EmitHelperForType_Fast(cw, t, root);
            }

            // Emit trace helpers (NOW ORDERED BY COST)
            foreach (var t in reachable.OrderBy(t => t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), StringComparer.Ordinal))
            {
                EmitHelperForType_Trace(cw, t, root);
            }
        }
        cw.Close(); // class

        // Ensure registration runs even if only dynamic path is used.
        cw.Open($"static class __{SanitizeIdentifier(helperClass)}_ModuleInit");
        cw.Line("[System.Runtime.CompilerServices.ModuleInitializer]");
        cw.Open("internal static void Init()");
        var generic = root.Type.IsGenericType ? "<>" : "";
        cw.Line($"_ = typeof({helperClass}{generic});");
        cw.Close();
        cw.Close();

        if (ns is not null)
        {
            cw.Close();
        }

        spc.AddSource(hintName, cw.ToString());
    }

    // -------- fast-fail helpers --------

    private static void EmitHelperForType_Fast(CodeWriter cw, INamedTypeSymbol type, Target root)
    {
        var fullName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var helperName = GetHelperMethodName(type);

        cw.Open($"private static bool {helperName}({fullName} left, {fullName} right, DeepEqual.Generator.Shared.ComparisonContext context)");

        if (!type.IsValueType)
        {
            cw.Open("if (object.ReferenceEquals(left, right))");
            cw.Line("return true;");
            cw.Close();

            cw.Open("if (left is null || right is null)");
            cw.Line("return false;");
            cw.Close();

            cw.Open("if (!context.Enter(left, right))");
            cw.Line("// already visited pair; avoid cycles");
            cw.Line("return true;");
            cw.Close();

            cw.Open("try");
        }

        var schema = GetTypeSchema(type);
        foreach (var member in OrderMembersByCost(type, EnumerateComparableMembers(type, root.IncludeInternals, schema), root))
        {
            EmitMember_Fast(cw, type, member, root);
        }

        if (!type.IsValueType)
        {
            cw.Line("return true;");
            cw.Close(); // try
            cw.Open("finally");
            cw.Line("context.Exit(left, right);");
            cw.Close();
        }
        else
        {
            cw.Line("return true;");
        }

        cw.Close();
        cw.Line();
    }

    private static void EmitMember_Fast(CodeWriter cw, INamedTypeSymbol owner, MemberSymbol member, Target root)
    {
        var leftLocal = $"member_{member.Name}_left";
        var rightLocal = $"member_{member.Name}_right";
        var deepAttr = GetDeepCompareAttribute(member.Symbol);
        var kind = GetEffectiveKind(member.Type, deepAttr);

        cw.Line($"// -- Member: {member.Name} ({member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)})");
        cw.Line($"var {leftLocal} = left.{member.Name};");
        cw.Line($"var {rightLocal} = right.{member.Name};");

        if (kind == EffectiveKind.Skip)
        {
            cw.Line("// skipped");
            cw.Line();
            return;
        }

        if (!member.Type.IsValueType)
        {
            cw.Open($"if (!object.ReferenceEquals({leftLocal}, {rightLocal}))");
            cw.Open($"if ({leftLocal} is null || {rightLocal} is null)");
            cw.Line("return false;");
            cw.Close();
            cw.Close();
        }

        if (kind == EffectiveKind.Reference)
        {
            if (member.Type.IsReferenceType)
            {
                cw.Open($"if (!object.ReferenceEquals({leftLocal}, {rightLocal}))");
                cw.Line("return false;");
                cw.Close();
            }
            else
            {
                cw.Open($"if (!{leftLocal}.Equals({rightLocal}))");
                cw.Line("return false;");
                cw.Close();
            }
            cw.Line();
            return;
        }

        if (kind == EffectiveKind.Shallow)
        {
            if (TryEmitWellKnownStructCompare(cw, leftLocal, rightLocal, member.Type))
            {
                cw.Line();
                return;
            }

            if (member.Type.SpecialType == SpecialType.System_String)
            {
                cw.Open($"if (!ComparisonHelpers.AreEqualStrings({leftLocal}, {rightLocal}))");
                cw.Line("return false;");
                cw.Close();
            }
            else if (member.Type.IsValueType)
            {
                cw.Open($"if (!{leftLocal}.Equals({rightLocal}))");
                cw.Line("return false;");
                cw.Close();
            }
            else
            {
                cw.Open($"if (!object.Equals({leftLocal}, {rightLocal}))");
                cw.Line("return false;");
                cw.Close();
            }
            cw.Line();
            return;
        }

        // object-typed member → dynamic path
        if (member.Type.SpecialType == SpecialType.System_Object)
        {
            cw.Open($"if (!DynamicDeepComparer.AreEqualDynamic({leftLocal}, {rightLocal}, context))");
            cw.Line("return false;");
            cw.Close();
            cw.Line();
            return;
        }

        // Nullable<T>
        if (member.Type is INamedTypeSymbol nnt && nnt.OriginalDefinition.ToDisplayString() == "System.Nullable<T>")
        {
            var tArg = nnt.TypeArguments[0];
            cw.Open($"if ({leftLocal}.HasValue != {rightLocal}.HasValue)");
            cw.Line("return false;");
            cw.Close();
            cw.Open($"if ({leftLocal}.HasValue)");
            EmitNullableValueCompare_Fast(cw, leftLocal, rightLocal, tArg, root);
            cw.Close();
            cw.Line();
            return;
        }

        // Well-knowns
        if (TryEmitWellKnownStructCompare(cw, leftLocal, rightLocal, member.Type))
        {
            cw.Line();
            return;
        }

        if (member.Type.SpecialType == SpecialType.System_String)
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualStrings({leftLocal}, {rightLocal}))");
            cw.Line("return false;");
            cw.Close();
            cw.Line();
            return;
        }

        if (member.Type.TypeKind == TypeKind.Enum)
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualEnum({leftLocal}, {rightLocal}))");
            cw.Line("return false;");
            cw.Close();
            cw.Line();
            return;
        }

        if (member.Type.IsValueType && member.Type.SpecialType != SpecialType.None)
        {
            cw.Open($"if (!{leftLocal}.Equals({rightLocal}))");
            cw.Line("return false;");
            cw.Close();
            cw.Line();
            return;
        }

        // Arrays
        if (member.Type is IArrayTypeSymbol arr)
        {
            var el = arr.ElementType;
            var elFqn = el.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var unordered = ResolveOrderInsensitive(root, deepAttr, el);
            var elKind = GetEffectiveKind(el, null);
            var elCmp = BuildElementComparerSymbol(el, elKind, root); // method-group comparer (no lambda)

            if (unordered)
            {
                // unordered arrays: use general array path with multiset semantics
                cw.Open($"if (!ComparisonHelpers.AreEqualArrayUnordered<{elFqn}>((Array?){leftLocal}, (Array?){rightLocal}, {elCmp}, context))");
                cw.Line("return false;");
                cw.Close();
            }
            else
            {
                // ordered arrays: prefer rank-1 fast path
                if (arr.Rank == 1)
                {
                    cw.Open($"if (!ComparisonHelpers.AreEqualArrayRank1<{elFqn}>({leftLocal} as {elFqn}[], {rightLocal} as {elFqn}[], {elCmp}, context))");
                    cw.Line("return false;");
                    cw.Close();
                }
                else
                {
                    cw.Open($"if (!ComparisonHelpers.AreEqualArray<{elFqn}>((Array?){leftLocal}, (Array?){rightLocal}, {elCmp}, context))");
                    cw.Line("return false;");
                    cw.Close();
                }
            }

            cw.Line();
            return;
        }

        // IDictionary<,> / IReadOnlyDictionary<,>
        if (TryGetDictionaryInterface(member.Type, out var keyT, out var valT))
        {
            var kFqn = keyT!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var vFqn = valT!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var vKind = GetEffectiveKind(valT!, null);
            var vCmp = BuildElementComparerSymbol(valT!, vKind, root);

            cw.Line($"if (!ComparisonHelpers.AreEqualDictionaries<{kFqn}, {vFqn}>(");
            cw.Line($"    {leftLocal} as IEnumerable<KeyValuePair<{kFqn}, {vFqn}>> ,");
            cw.Line($"    {rightLocal} as IEnumerable<KeyValuePair<{kFqn}, {vFqn}>> ,");
            cw.Open($"    {vCmp}, context))");
            cw.Line("return false;");
            cw.Close();
            cw.Line();
            return;
        }

        // IEnumerable<T>
        if (TryGetEnumerableInterface(member.Type, out var elT))
        {
            var elFqn = elT!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var elKind = GetEffectiveKind(elT!, null);
            var unordered = ResolveOrderInsensitive(root, deepAttr, elT!);
            var elCmp = BuildElementComparerSymbol(elT!, elKind, root); // method-group comparer
            var api = unordered ? "AreEqualSequencesUnordered" : "AreEqualSequencesOrdered";

            cw.Line($"if (!ComparisonHelpers.{api}<{elFqn}>(");
            cw.Line($"    {leftLocal} as IEnumerable<{elFqn}>,");
            cw.Line($"    {rightLocal} as IEnumerable<{elFqn}>,");
            cw.Open($"    {elCmp}, context))");
            cw.Line("return false;");
            cw.Close();
            cw.Line();
            return;
        }

        // User object types
        if (member.Type is INamedTypeSymbol nts && IsUserObjectType(nts))
        {
            if (IsTypeAccessibleFromRoot(nts, root))
            {
                var helper = GetHelperMethodName(nts);
                cw.Open($"if (!{helper}({leftLocal}, {rightLocal}, context))");
                cw.Line("return false;");
                cw.Close();
            }
            else
            {
                cw.Open($"if (!object.Equals({leftLocal}, {rightLocal}))");
                cw.Line("return false;");
                cw.Close();
            }
            cw.Line();
            return;
        }

        // fallback
        cw.Open($"if (!object.Equals({leftLocal}, {rightLocal}))");
        cw.Line("return false;");
        cw.Close();
        cw.Line();
    }

    private static void EmitNullableValueCompare_Fast(CodeWriter cw, string l, string r, ITypeSymbol valueType, Target root)
    {
        if (TryEmitWellKnownStructCompare(cw, $"{l}.Value", $"{r}.Value", valueType)) return;

        if (valueType.TypeKind == TypeKind.Enum)
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualEnum({l}.Value, {r}.Value))");
            cw.Line("return false;");
            cw.Close();
            return;
        }

        if (valueType.SpecialType == SpecialType.System_DateTime)
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualDateTime({l}.Value, {r}.Value))");
            cw.Line("return false;");
            cw.Close();
            return;
        }

        var fqn = valueType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        if (fqn == "global::System.DateTimeOffset")
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualDateTimeOffset({l}.Value, {r}.Value))");
            cw.Line("return false;");
            cw.Close();
            return;
        }

        if (fqn == "global::System.DateOnly")
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualDateOnly({l}.Value, {r}.Value))");
            cw.Line("return false;");
            cw.Close();
            return;
        }

        if (fqn == "global::System.TimeOnly")
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualTimeOnly({l}.Value, {r}.Value))");
            cw.Line("return false;");
            cw.Close();
            return;
        }

        if (valueType.IsValueType && valueType.SpecialType != SpecialType.None)
        {
            cw.Open($"if (!{l}.Value.Equals({r}.Value))");
            cw.Line("return false;");
            cw.Close();
            return;
        }

        if (valueType is INamedTypeSymbol s && IsUserObjectType(s))
        {
            if (IsTypeAccessibleFromRoot(s, root))
            {
                var helper = GetHelperMethodName(s);
                cw.Open($"if (!{helper}({l}.Value, {r}.Value, context))");
                cw.Line("return false;");
                cw.Close();
            }
            else
            {
                cw.Open($"if (!object.Equals({l}.Value, {r}.Value))");
                cw.Line("return false;");
                cw.Close();
            }
            return;
        }

        cw.Open($"if (!object.Equals({l}.Value, {r}.Value))");
        cw.Line("return false;");
        cw.Close();
    }

    // -------- trace helpers --------

    private static void EmitHelperForType_Trace(CodeWriter cw, INamedTypeSymbol type, Target root)
    {
        var fullName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var name = $"CollectDifferences__{SanitizeIdentifier(type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))}";

        // Signature: collects differences into 'diffs'; never throws; uses cycle guards.
        cw.Open($"private static void {name}({fullName} left, {fullName} right, string path, DeepEqual.Generator.Shared.ComparisonContext context, List<string> diffs)");

        if (!type.IsValueType)
        {
            cw.Open("if (object.ReferenceEquals(left, right))");
            cw.Line("return;");
            cw.Close();

            cw.Open("if (left is null || right is null)");
            cw.Line("diffs.Add($\"{path}: one is null and the other is not\");");
            cw.Line("return;");
            cw.Close();

            cw.Open("if (!context.Enter(left, right))");
            cw.Line("// already visited this pair → avoid infinite cycle expansion");
            cw.Line("return;");
            cw.Close();

            cw.Open("try");
        }

        var schema = GetTypeSchema(type);
        foreach (var member in OrderMembersByCost(type, EnumerateComparableMembers(type, root.IncludeInternals, schema), root))
        {
            EmitMember_Trace(cw, type, member, root);
        }

        if (!type.IsValueType)
        {
            cw.Close(); // try
            cw.Open("finally");
            cw.Line("context.Exit(left, right);");
            cw.Close();
        }

        cw.Close();
        cw.Line();
    }

    private static void EmitMember_Trace(CodeWriter cw, INamedTypeSymbol owner, MemberSymbol member, Target root)
    {
        var l = $"left.{member.Name}";
        var r = $"right.{member.Name}";
        var deepAttr = GetDeepCompareAttribute(member.Symbol);
        var kind = GetEffectiveKind(member.Type, deepAttr);

        cw.Line($"// -- Trace Member: {member.Name} ({member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)})");
        cw.Line($"var __path_{member.Name} = AppendPath(path, \"{member.Name}\");");

        if (kind == EffectiveKind.Skip)
        {
            cw.Line("// skipped");
            cw.Line();
            return;
        }

        // Null asymmetry for refs
        if (!member.Type.IsValueType)
        {
            cw.Open($"if (!object.ReferenceEquals({l}, {r}))");
            cw.Open($"if ({l} is null || {r} is null)");
            cw.Line($"diffs.Add($\"{{__path_{member.Name}}}: one is null and the other is not\");");
            cw.Line("goto __after_" + member.Name + ";");
            cw.Close();
            cw.Close();
        }

        // Reference comparison
        if (kind == EffectiveKind.Reference)
        {
            if (member.Type.IsReferenceType)
            {
                cw.Open($"if (!object.ReferenceEquals({l}, {r}))");
                cw.Line($"diffs.Add($\"{{__path_{member.Name}}}: different references\");");
                cw.Close();
            }
            else
            {
                cw.Open($"if (!{l}.Equals({r}))");
                cw.Line($"diffs.Add($\"{{__path_{member.Name}}}: values differ\");");
                cw.Close();
            }
            if (!member.Type.IsValueType)
            {
                cw.Line("__after_" + member.Name + ": ;");
            }
            cw.Line();
            return;
        }

        // Shallow comparison
        if (kind == EffectiveKind.Shallow)
        {
            if (TryEmitWellKnownStructCompare_Trace(cw, l, r, $"__path_{member.Name}", member.Type))
            {
                if (!member.Type.IsValueType) cw.Line("__after_" + member.Name + ": ;");
                cw.Line();
                return;
            }

            if (member.Type.SpecialType == SpecialType.System_String)
            {
                cw.Open($"if (!ComparisonHelpers.AreEqualStrings({l}, {r}))");
                cw.Line($"diffs.Add($\"{{__path_{member.Name}}}: strings differ\");");
                cw.Close();
            }
            else if (member.Type.IsValueType)
            {
                cw.Open($"if (!{l}.Equals({r}))");
                cw.Line($"diffs.Add($\"{{__path_{member.Name}}}: values differ\");");
                cw.Close();
            }
            else
            {
                cw.Open($"if (!object.Equals({l}, {r}))");
                cw.Line($"diffs.Add($\"{{__path_{member.Name}}}: values differ\");");
                cw.Close();
            }
            if (!member.Type.IsValueType) cw.Line("__after_" + member.Name + ": ;");
            cw.Line();
            return;
        }

        // object-typed → dynamic
        if (member.Type.SpecialType == SpecialType.System_Object)
        {
            cw.Open($"if (!DynamicDeepComparer.AreEqualDynamic({l}, {r}, context))");
            cw.Line($"diffs.Add($\"{{__path_{member.Name}}}: dynamic objects differ\");");
            cw.Close();
            if (!member.Type.IsValueType) cw.Line("__after_" + member.Name + ": ;");
            cw.Line();
            return;
        }

        // Nullable<T>
        if (member.Type is INamedTypeSymbol nnt && nnt.OriginalDefinition.ToDisplayString() == "System.Nullable<T>")
        {
            var tArg = nnt.TypeArguments[0];
            cw.Open($"if ({l}.HasValue != {r}.HasValue)");
            cw.Line($"diffs.Add($\"{{__path_{member.Name}}}: one has value and the other does not\");");
            cw.Line($"goto __after_{member.Name};");
            cw.Close();

            cw.Open($"if ({l}.HasValue)");
            EmitNullableValueCompare_Trace(cw, l, r, tArg, $"__path_{member.Name}", root);
            cw.Close();

            cw.Line($"__after_{member.Name}: ;");
            cw.Line();
            return;
        }

        // Well-knowns
        if (TryEmitWellKnownStructCompare_Trace(cw, l, r, $"__path_{member.Name}", member.Type))
        {
            if (!member.Type.IsValueType) cw.Line("__after_" + member.Name + ": ;");
            cw.Line();
            return;
        }

        if (member.Type.SpecialType == SpecialType.System_String)
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualStrings({l}, {r}))");
            cw.Line($"diffs.Add($\"{{__path_{member.Name}}}: strings differ\");");
            cw.Close();
            if (!member.Type.IsValueType) cw.Line("__after_" + member.Name + ": ;");
            cw.Line();
            return;
        }

        if (member.Type.TypeKind == TypeKind.Enum)
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualEnum({l}, {r}))");
            cw.Line($"diffs.Add($\"{{__path_{member.Name}}}: enum values differ\");");
            cw.Close();
            if (!member.Type.IsValueType) cw.Line("__after_" + member.Name + ": ;");
            cw.Line();
            return;
        }

        if (member.Type.IsValueType && member.Type.SpecialType != SpecialType.None)
        {
            cw.Open($"if (!{l}.Equals({r}))");
            cw.Line($"diffs.Add($\"{{__path_{member.Name}}}: values differ\");");
            cw.Close();
            if (!member.Type.IsValueType) cw.Line("__after_" + member.Name + ": ;");
            cw.Line();
            return;
        }

        // Arrays
        if (member.Type is IArrayTypeSymbol arr)
        {
            var el = arr.ElementType;
            var elFqn = el.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var unordered = ResolveOrderInsensitive(root, deepAttr, el);
            var elKind = GetEffectiveKind(el, null);
            var elCmp = BuildElementComparerSymbol(el, elKind, root); // fast check

            if (unordered)
            {
                cw.Open($"if (!ComparisonHelpers.AreEqualArrayUnordered<{elFqn}>((Array?){l}, (Array?){r}, {elCmp}, context))");
                cw.Line($"diffs.Add($\"{{__path_{member.Name}}}: unordered array differs\");");
                cw.Close();
            }
            else
            {
                if (arr.Rank == 1)
                {
                    cw.Open($"if (!ComparisonHelpers.AreEqualArrayRank1<{elFqn}>({l} as {elFqn}[], {r} as {elFqn}[], {elCmp}, context))");
                }
                else
                {
                    cw.Open($"if (!ComparisonHelpers.AreEqualArray<{elFqn}>((Array?){l}, (Array?){r}, {elCmp}, context))");
                }
                cw.Line("// Walk ordered elements to report index-level differences");
                cw.Open($"if ((Array?){l} is null || (Array?){r} is null)");
                cw.Line($"diffs.Add($\"{{__path_{member.Name}}}: one is null and the other is not\");");
                cw.Line("goto __after_" + member.Name + ";");
                cw.Close();

                cw.Line("var __ea = ((IEnumerable)" + l + ").GetEnumerator();");
                cw.Line("var __eb = ((IEnumerable)" + r + ").GetEnumerator();");
                cw.Line("var __i = 0;");
                cw.Open("while (true)");
                cw.Line("bool __ma = __ea.MoveNext();");
                cw.Line("bool __mb = __eb.MoveNext();");
                cw.Line($"if (__ma != __mb) {{ diffs.Add($\"{{__path_{member.Name}}}: lengths differ\"); break; }}");
                cw.Line("if (!__ma) break;");

                if (el is INamedTypeSymbol elN && IsUserObjectType(elN) && IsTypeAccessibleFromRoot(elN, root))
                {
                    var helper = $"CollectDifferences__{SanitizeIdentifier(elN.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))}";
                    cw.Line($"var __elPath = AppendPath(__path_{member.Name}, \"[\" + __i.ToString() + \"]\");");
                    cw.Line($"{helper}(({elFqn})__ea.Current, ({elFqn})__eb.Current, __elPath, context, diffs);");
                }
                else
                {
                    var cmpExpr = BuildInlineCompareExpr("((" + elFqn + ")__ea.Current)", "(" + elFqn + ")__eb.Current", el, elKind, root);
                    cw.Open($"if (!({cmpExpr}))");
                    cw.Line($"diffs.Add($\"{{AppendPath(__path_{member.Name}, \"[\" + __i.ToString() + \"]\")}}: elements differ\");");
                    cw.Close();
                }
                cw.Line("__i++;");
                cw.Close(); // while
                cw.Close();
            }

            if (!member.Type.IsValueType) cw.Line("__after_" + member.Name + ": ;");
            cw.Line();
            return;
        }

        // IDictionary<,> / IReadOnlyDictionary<,>
        if (TryGetDictionaryInterface(member.Type, out var keyT, out var valT))
        {
            var kFqn = keyT!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var vFqn = valT!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var vKind = GetEffectiveKind(valT!, null);

            cw.Line($"var __leftDict  = {l} as IEnumerable<KeyValuePair<{kFqn}, {vFqn}>>;");
            cw.Line($"var __rightDict = {r} as IEnumerable<KeyValuePair<{kFqn}, {vFqn}>>;");
            cw.Open($"if (__leftDict is null || __rightDict is null)");
            cw.Line($"diffs.Add($\"{{__path_{member.Name}}}: dictionaries differ\");");
            cw.Line($"goto __after_{member.Name};");
            cw.Close();

            cw.Line($"var __rd = new Dictionary<{kFqn},{vFqn}>();");
            cw.Line("foreach (var kv in __rightDict) __rd[kv.Key] = kv.Value;");

            cw.Line("var __countLeft = 0;");
            cw.Open("foreach (var kv in __leftDict)");
            cw.Line("__countLeft++;");
            cw.Open("if (!__rd.TryGetValue(kv.Key, out var __rv))");
            cw.Line($"diffs.Add($\"{{__path_{member.Name}}}[missing key]: {{kv.Key}}\");");
            cw.Line("continue;");
            cw.Close();

            if (valT is INamedTypeSymbol vN && IsUserObjectType(vN) && IsTypeAccessibleFromRoot(vN, root))
            {
                var helper = $"CollectDifferences__{SanitizeIdentifier(vN.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))}";
                cw.Line($"var __kPath = AppendPath(__path_{member.Name}, \"[\" + kv.Key?.ToString() + \"]\");");
                cw.Line($"{helper}(kv.Value, __rv, __kPath, context, diffs);");
            }
            else
            {
                var cmp = BuildInlineCompareExpr("kv.Value", "__rv", valT!, vKind, root);
                cw.Open($"if (!({cmp}))");
                cw.Line($"diffs.Add($\"{{AppendPath(__path_{member.Name}, \"[\" + kv.Key?.ToString() + \"]\")}}: values differ\");");
                cw.Close();
            }
            cw.Close();

            cw.Line("var __countRight = 0;");
            cw.Line("foreach (var kv in __rightDict) __countRight++;");
            cw.Open("if (__countLeft != __countRight)");
            cw.Line($"diffs.Add($\"{{__path_{member.Name}}}: dictionary sizes differ\");");
            cw.Close();

            cw.Line($"__after_{member.Name}: ;");
            cw.Line();
            return;
        }

        // IEnumerable<T>
        if (TryGetEnumerableInterface(member.Type, out var elT))
        {
            var elFqn = elT!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var elKind = GetEffectiveKind(elT!, null);
            var unordered = ResolveOrderInsensitive(root, deepAttr, elT!);
            var elCmp = BuildElementComparerSymbol(elT!, elKind, root);

            if (unordered)
            {
                cw.Open($"if (!ComparisonHelpers.AreEqualSequencesUnordered<{elFqn}>({l} as IEnumerable<{elFqn}>, {r} as IEnumerable<{elFqn}>, {elCmp}, context))");
                cw.Line($"diffs.Add($\"{{__path_{member.Name}}}: unordered sequence differs\");");
                cw.Close();
            }
            else
            {
                cw.Open($"if (!ComparisonHelpers.AreEqualSequencesOrdered<{elFqn}>({l} as IEnumerable<{elFqn}>, {r} as IEnumerable<{elFqn}>, {elCmp}, context))");
                cw.Line($"var __elA = ({l} as IEnumerable<{elFqn}>)?.GetEnumerator();");
                cw.Line($"var __elB = ({r} as IEnumerable<{elFqn}>)?.GetEnumerator();");
                cw.Open("if (__elA is null || __elB is null)");
                cw.Line($"diffs.Add($\"{{__path_{member.Name}}}: one is null and the other is not\");");
                cw.Line("goto __after_" + member.Name + ";");
                cw.Close();

                cw.Line("var __i = 0;");
                cw.Open("while (true)");
                cw.Line("bool __ma = __elA.MoveNext();");
                cw.Line("bool __mb = __elB.MoveNext();");
                cw.Line($"if (__ma != __mb) {{ diffs.Add($\"{{__path_{member.Name}}}: lengths differ\"); break; }}");
                cw.Line("if (!__ma) break;");

                if (elT is INamedTypeSymbol elTN && IsUserObjectType(elTN) && IsTypeAccessibleFromRoot(elTN, root))
                {
                    var helper = $"CollectDifferences__{SanitizeIdentifier(elTN.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))}";
                    cw.Line($"var __elPath = AppendPath(__path_{member.Name}, \"[\" + __i.ToString() + \"]\");");
                    cw.Line($"{helper}(__elA.Current, __elB.Current, __elPath, context, diffs);");
                }
                else
                {
                    var cmp = BuildInlineCompareExpr("__elA.Current", "__elB.Current", elT!, elKind, root);
                    cw.Open($"if (!({cmp}))");
                    cw.Line($"diffs.Add($\"{{AppendPath(__path_{member.Name}, \"[\" + __i.ToString() + \"]\")}}: elements differ\");");
                    cw.Close();
                }

                cw.Line("__i++;");
                cw.Close(); // while
                cw.Close();
            }

            if (!member.Type.IsValueType) cw.Line("__after_" + member.Name + ": ;");
            cw.Line();
            return;
        }

        // User object types
        if (member.Type is INamedTypeSymbol nts && IsUserObjectType(nts))
        {
            if (IsTypeAccessibleFromRoot(nts, root))
            {
                var helper = $"CollectDifferences__{SanitizeIdentifier(nts.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))}";
                cw.Line($"{helper}({l}, {r}, __path_{member.Name}, context, diffs);");
            }
            else
            {
                cw.Open($"if (!object.Equals({l}, {r}))");
                cw.Line($"diffs.Add($\"{{__path_{member.Name}}}: values differ\");");
                cw.Close();
            }

            if (!member.Type.IsValueType) cw.Line("__after_" + member.Name + ": ;");
            cw.Line();
            return;
        }

        // fallback
        cw.Open($"if (!object.Equals({l}, {r}))");
        cw.Line($"diffs.Add($\"{{__path_{member.Name}}}: values differ\");");
        cw.Close();

        if (!member.Type.IsValueType) cw.Line($"__after_{member.Name}: ;");
        cw.Line();
    }

    private static void EmitNullableValueCompare_Trace(CodeWriter cw, string l, string r, ITypeSymbol valueType, string pathExpr, Target root)
    {
        if (TryEmitWellKnownStructCompare_Trace(cw, $"{l}.Value", $"{r}.Value", pathExpr, valueType))
        {
            return;
        }

        if (valueType.TypeKind == TypeKind.Enum)
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualEnum({l}.Value, {r}.Value))");
            cw.Line($"diffs.Add($\"{{{pathExpr}}}: enum values differ\");");
            cw.Close();
            return;
        }

        if (valueType.SpecialType == SpecialType.System_DateTime)
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualDateTime({l}.Value, {r}.Value))");
            cw.Line($"diffs.Add($\"{{{pathExpr}}}: DateTime differs\");");
            cw.Close();
            return;
        }

        var fqn = valueType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        if (fqn == "global::System.DateTimeOffset")
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualDateTimeOffset({l}.Value, {r}.Value))");
            cw.Line($"diffs.Add($\"{{{pathExpr}}}: DateTimeOffset differs\");");
            cw.Close();
            return;
        }

        if (fqn == "global::System.DateOnly")
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualDateOnly({l}.Value, {r}.Value))");
            cw.Line($"diffs.Add($\"{{{pathExpr}}}: DateOnly differs\");");
            cw.Close();
            return;
        }

        if (fqn == "global::System.TimeOnly")
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualTimeOnly({l}.Value, {r}.Value))");
            cw.Line($"diffs.Add($\"{{{pathExpr}}}: TimeOnly differs\");");
            cw.Close();
            return;
        }

        if (valueType.IsValueType && valueType.SpecialType != SpecialType.None)
        {
            cw.Open($"if (!{l}.Value.Equals({r}.Value))");
            cw.Line($"diffs.Add($\"{{{pathExpr}}}: values differ\");");
            cw.Close();
            return;
        }

        if (valueType is INamedTypeSymbol s && IsUserObjectType(s))
        {
            if (IsTypeAccessibleFromRoot(s, root))
            {
                var helper = $"CollectDifferences__{SanitizeIdentifier(s.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))}";
                cw.Line($"{helper}({l}.Value, {r}.Value, {pathExpr}, context, diffs);");
            }
            else
            {
                cw.Open($"if (!object.Equals({l}.Value, {r}.Value))");
                cw.Line($"diffs.Add($\"{{{pathExpr}}}: values differ\");");
                cw.Close();
            }
            return;
        }

        cw.Open($"if (!object.Equals({l}.Value, {r}.Value))");
        cw.Line($"diffs.Add($\"{{{pathExpr}}}: values differ\");");
        cw.Close();
    }

    // -------- shared emit helpers --------

    private static bool TryEmitWellKnownStructCompare(CodeWriter cw, string l, string r, ITypeSymbol t)
    {
        if (t.SpecialType == SpecialType.System_DateTime)
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualDateTime({l}, {r}))");
            cw.Line("return false;");
            cw.Close();
            return true;
        }

        var fqn = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        if (fqn == "global::System.DateTimeOffset")
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualDateTimeOffset({l}, {r}))");
            cw.Line("return false;");
            cw.Close();
            return true;
        }

        if (fqn == "global::System.TimeSpan")
        {
            cw.Open($"if ({l}.Ticks != {r}.Ticks)");
            cw.Line("return false;");
            cw.Close();
            return true;
        }

        if (fqn == "global::System.Guid")
        {
            cw.Open($"if (!{l}.Equals({r}))");
            cw.Line("return false;");
            cw.Close();
            return true;
        }

        if (fqn == "global::System.DateOnly")
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualDateOnly({l}, {r}))");
            cw.Line("return false;");
            cw.Close();
            return true;
        }

        if (fqn == "global::System.TimeOnly")
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualTimeOnly({l}, {r}))");
            cw.Line("return false;");
            cw.Close();
            return true;
        }

        return false;
    }

    private static bool TryEmitWellKnownStructCompare_Trace(CodeWriter cw, string l, string r, string pathExpr, ITypeSymbol t)
    {
        if (t.SpecialType == SpecialType.System_DateTime)
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualDateTime({l}, {r}))");
            cw.Line($"diffs.Add($\"{{{pathExpr}}}: DateTime differs\");");
            cw.Close();
            return true;
        }

        var fqn = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        if (fqn == "global::System.DateTimeOffset")
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualDateTimeOffset({l}, {r}))");
            cw.Line($"diffs.Add($\"{{{pathExpr}}}: DateTimeOffset differs\");");
            cw.Close();
            return true;
        }

        if (fqn == "global::System.TimeSpan")
        {
            cw.Open($"if ({l}.Ticks != {r}.Ticks)");
            cw.Line($"diffs.Add($\"{{{pathExpr}}}: TimeSpan differs\");");
            cw.Close();
            return true;
        }

        if (fqn == "global::System.Guid")
        {
            cw.Open($"if (!{l}.Equals({r}))");
            cw.Line($"diffs.Add($\"{{{pathExpr}}}: Guid differs\");");
            cw.Close();
            return true;
        }

        if (fqn == "global::System.DateOnly")
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualDateOnly({l}, {r}))");
            cw.Line($"diffs.Add($\"{{{pathExpr}}}: DateOnly differs\");");
            cw.Close();
            return true;
        }

        if (fqn == "global::System.TimeOnly")
        {
            cw.Open($"if (!ComparisonHelpers.AreEqualTimeOnly({l}, {r}))");
            cw.Line($"diffs.Add($\"{{{pathExpr}}}: TimeOnly differs\");");
            cw.Close();
            return true;
        }

        return false;
    }

    // Build a **method-group** comparer (avoids per-call lambda allocation) whenever possible.
    private static string BuildElementComparerSymbol(ITypeSymbol elementType, EffectiveKind elementKind, Target root)
    {
        // KeyValuePair<K,V> → a small inline lambda is still necessary
        if (elementType is INamedTypeSymbol kvp &&
            kvp.ConstructedFrom?.ToDisplayString() == "System.Collections.Generic.KeyValuePair<TKey, TValue>")
        {
            var k = kvp.TypeArguments[0];
            var v = kvp.TypeArguments[1];
            var keyExpr = BuildInlineCompareExpr("l.Key", "r.Key", k, GetEffectiveKind(k, null), root);
            var valExpr = BuildInlineCompareExpr("l.Value", "r.Value", v, GetEffectiveKind(v, null), root);
            return $"(l, r, c) => ({keyExpr}) && ({valExpr})";
        }

        // Nullable<T> → small inline lambda
        if (elementType is INamedTypeSymbol nt && nt.OriginalDefinition.ToDisplayString() == "System.Nullable<T>")
        {
            var tArg = nt.TypeArguments[0];
            var inner = BuildInlineCompareExpr("l.Value", "r.Value", tArg, GetEffectiveKind(tArg, null), root);
            return $"(l, r, c) => (l.HasValue == r.HasValue) && (!l.HasValue || ({inner}))";
        }

        // object
        if (elementType.SpecialType == SpecialType.System_Object)
        {
            return "DynamicDeepComparer.AreEqualDynamic";
        }

        // enums
        if (elementType.TypeKind == TypeKind.Enum)
        {
            var elFqn = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            return $"ComparisonHelpers.CompareEnumWithContext<{elFqn}>";
        }

        // strings
        if (elementType.SpecialType == SpecialType.System_String)
        {
            return "ComparisonHelpers.CompareStringsWithContext";
        }

        // Date/Time/Guid well-knowns
        if (elementType.SpecialType == SpecialType.System_DateTime) return "ComparisonHelpers.CompareDateTimeWithContext";
        {
            var fqn = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (fqn == "global::System.DateTimeOffset") return "ComparisonHelpers.CompareDateTimeOffsetWithContext";
            if (fqn == "global::System.Guid") return "ComparisonHelpers.CompareGuidWithContext";
            if (fqn == "global::System.TimeSpan") return "ComparisonHelpers.CompareTimeSpanWithContext";
            if (fqn == "global::System.DateOnly") return "ComparisonHelpers.CompareDateOnlyWithContext";
            if (fqn == "global::System.TimeOnly") return "ComparisonHelpers.CompareTimeOnlyWithContext";
        }

        // built-in value types
        if (elementType.IsValueType && elementType.SpecialType != SpecialType.None)
        {
            var elFqn = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            return $"ComparisonHelpers.CompareByEquals<{elFqn}>";
        }

        // user types
        if (elementType is INamedTypeSymbol nts && IsUserObjectType(nts))
        {
            if (IsTypeAccessibleFromRoot(nts, root))
            {
                return GetHelperMethodName(nts);
            }
            else
            {
                var elFqn = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                return $"ComparisonHelpers.CompareByObjectEquals<{elFqn}>";
            }
        }

        // fallback: object.Equals
        {
            var elFqn = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            return $"ComparisonHelpers.CompareByObjectEquals<{elFqn}>";
        }
    }

    // Returns a pure boolean expression to compare l and r (used by trace & KVP compose).
    private static string BuildInlineCompareExpr(string l, string r, ITypeSymbol type, EffectiveKind kind, Target root)
    {
        if (kind == EffectiveKind.Reference)
        {
            return type.IsReferenceType ? $"object.ReferenceEquals({l}, {r})" : $"{l}.Equals({r})";
        }

        if (kind == EffectiveKind.Shallow)
        {
            if (type.SpecialType == SpecialType.System_String) return $"ComparisonHelpers.AreEqualStrings({l}, {r})";
            if (type.SpecialType == SpecialType.System_DateTime) return $"ComparisonHelpers.AreEqualDateTime({l}, {r})";
            var fqn = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (fqn == "global::System.DateTimeOffset") return $"ComparisonHelpers.AreEqualDateTimeOffset({l}, {r})";
            if (fqn == "global::System.TimeSpan") return $"{l}.Ticks == {r}.Ticks";
            if (fqn == "global::System.Guid") return $"{l}.Equals({r})";
            if (fqn == "global::System.DateOnly") return $"ComparisonHelpers.AreEqualDateOnly({l}, {r})";
            if (fqn == "global::System.TimeOnly") return $"ComparisonHelpers.AreEqualTimeOnly({l}, {r})";
            if (type.IsValueType) return $"{l}.Equals({r})";
            return $"object.Equals({l}, {r})";
        }

        if (type.SpecialType == SpecialType.System_Object)
            return $"DynamicDeepComparer.AreEqualDynamic({l}, {r}, context)";

        // Nullable<T>
        if (type is INamedTypeSymbol nnt && nnt.OriginalDefinition.ToDisplayString() == "System.Nullable<T>")
        {
            var tArg = nnt.TypeArguments[0];
            var inner = BuildInlineCompareExpr($"{l}.Value", $"{r}.Value", tArg, GetEffectiveKind(tArg, null), root);
            return $"({l}.HasValue == {r}.HasValue) && (!{l}.HasValue || ({inner}))";
        }

        if (type.SpecialType == SpecialType.System_String) return $"ComparisonHelpers.AreEqualStrings({l}, {r})";
        if (type.TypeKind == TypeKind.Enum) return $"ComparisonHelpers.AreEqualEnum({l}, {r})";
        if (type.SpecialType == SpecialType.System_DateTime) return $"ComparisonHelpers.AreEqualDateTime({l}, {r})";
        {
            var fqn = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (fqn == "global::System.DateTimeOffset") return $"ComparisonHelpers.AreEqualDateTimeOffset({l}, {r})";
            if (fqn == "global::System.TimeSpan") return $"{l}.Ticks == {r}.Ticks";
            if (fqn == "global::System.Guid") return $"{l}.Equals({r})";
            if (fqn == "global::System.DateOnly") return $"ComparisonHelpers.AreEqualDateOnly({l}, {r})";
            if (fqn == "global::System.TimeOnly") return $"ComparisonHelpers.AreEqualTimeOnly({l}, {r})";
        }

        if (type.IsValueType && type.SpecialType != SpecialType.None)
            return $"{l}.Equals({r})";

        if (type is INamedTypeSymbol nts && IsUserObjectType(nts))
        {
            if (IsTypeAccessibleFromRoot(nts, root))
            {
                var helper = GetHelperMethodName(nts);
                if (nts.IsValueType)
                    return $"{helper}({l}, {r}, c)";
                else
                    return $"(object.ReferenceEquals({l}, {r}) ? true : ({l} is null || {r} is null ? false : {helper}({l}, {r}, c)))";
            }
            return $"object.Equals({l}, {r})";
        }

        return $"object.Equals({l}, {r})";
    }

    // -------- symbol helpers --------

    private static TypeSchema GetTypeSchema(INamedTypeSymbol type)
    {
        var attr = type.GetAttributes().FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);
        if (attr is null) return new TypeSchema(Array.Empty<string>(), Array.Empty<string>());

        static string[] ReadStringArray(TypedConstant arg)
        {
            if (arg is { Kind: TypedConstantKind.Array, IsNull: false })
                return arg.Values.Select(v => v.Value?.ToString() ?? string.Empty)
                                 .Where(s => !string.IsNullOrWhiteSpace(s))
                                 .ToArray();
            return Array.Empty<string>();
        }

        string[] include = Array.Empty<string>();
        string[] ignore = Array.Empty<string>();

        foreach (var kv in attr.NamedArguments)
        {
            if (kv.Key == "Members") include = ReadStringArray(kv.Value);
            else if (kv.Key == "IgnoreMembers") ignore = ReadStringArray(kv.Value);
        }
        return new TypeSchema(include, ignore);
    }

    private static IEnumerable<MemberSymbol> EnumerateComparableMembers(INamedTypeSymbol type, bool allowInternals, TypeSchema schema)
    {
        static bool IsAccessible(ISymbol s, bool inclInternals, INamedTypeSymbol owner)
        {
            return s.DeclaredAccessibility switch
            {
                Accessibility.Public => true,
                Accessibility.Internal or Accessibility.ProtectedAndInternal
                    => inclInternals && SymbolEqualityComparer.Default.Equals(s.ContainingAssembly, owner.ContainingAssembly),
                _ => false
            };
        }

        bool hasInclude = schema.IncludeMembers.Count > 0;
        var includeSet = hasInclude ? new HashSet<string>(schema.IncludeMembers, StringComparer.Ordinal) : null;
        var ignoreSet = schema.IgnoreMembers.Count > 0 ? new HashSet<string>(schema.IgnoreMembers, StringComparer.Ordinal) : null;

        foreach (var p in type.GetMembers().OfType<IPropertySymbol>())
        {
            if (p.IsStatic) continue;
            if (p.Parameters.Length != 0) continue;
            if (p.GetMethod is null) continue;
            if (!IsAccessible(p, allowInternals, type)) continue;
            if (hasInclude && !includeSet!.Contains(p.Name)) continue;
            if (ignoreSet is not null && ignoreSet.Contains(p.Name)) continue;

            if (type.IsValueType && SymbolEqualityComparer.Default.Equals(p.Type, type) && !hasInclude) continue;

            yield return new MemberSymbol(p.Name, p.Type, p);
        }

        foreach (var f in type.GetMembers().OfType<IFieldSymbol>())
        {
            if (f.IsStatic || f.IsConst || f.IsImplicitlyDeclared) continue;
            if (f.AssociatedSymbol is not null) continue;
            if (f.Name.StartsWith("<", StringComparison.Ordinal)) continue;
            if (!IsAccessible(f, allowInternals, type)) continue;
            if (hasInclude && !includeSet!.Contains(f.Name)) continue;
            if (ignoreSet is not null && ignoreSet.Contains(f.Name)) continue;

            if (type.IsValueType && SymbolEqualityComparer.Default.Equals(f.Type, type) && !hasInclude) continue;

            yield return new MemberSymbol(f.Name, f.Type, f);
        }
    }

    // NEW: cost-based ordering (cheap → expensive)
    private static IEnumerable<MemberSymbol> OrderMembersByCost(INamedTypeSymbol owner, IEnumerable<MemberSymbol> members, Target root)
        => members
            .Select(m => (m, key: GetMemberCostGroup(owner, m, root)))
            .OrderBy(t => t.key)
            .ThenBy(t => t.m.Name, StringComparer.Ordinal)
            .Select(t => t.m);

    private static int GetMemberCostGroup(INamedTypeSymbol owner, MemberSymbol member, Target root)
    {
        var attr = GetDeepCompareAttribute(member.Symbol);
        var kind = GetEffectiveKind(member.Type, attr);

        if (kind == EffectiveKind.Skip) return 99;
        if (kind == EffectiveKind.Reference || kind == EffectiveKind.Shallow) return 0;

        var t = member.Type;

        // Nullable<T> → consider inner type for cost
        if (t is INamedTypeSymbol nnt && nnt.OriginalDefinition.ToDisplayString() == "System.Nullable<T>")
        {
            var inner = nnt.TypeArguments[0];
            if (inner.TypeKind == TypeKind.Enum) return 2;
            if (IsWellKnownStruct(inner) || (inner.IsValueType && inner.SpecialType != SpecialType.None)) return 3;
            // Nullable of complex types → treat as complex
            t = inner;
        }

        if (t.SpecialType == SpecialType.System_String) return 1;
        if (t.TypeKind == TypeKind.Enum) return 2;
        if (IsWellKnownStruct(t) || (t.IsValueType && t.SpecialType != SpecialType.None)) return 3;
        if (t.SpecialType == SpecialType.System_Object) return 6;

        if (t is IArrayTypeSymbol) return 9;
        if (TryGetDictionaryInterface(t, out _, out _)) return 8;
        if (TryGetEnumerableInterface(t, out _)) return 9;

        if (t is INamedTypeSymbol nts && IsUserObjectType(nts)) return 7;

        return 7; // default to "complex"
    }

    private static bool IsWellKnownStruct(ITypeSymbol t)
    {
        if (t.SpecialType == SpecialType.System_DateTime) return true;
        var fqn = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        return fqn is "global::System.DateTimeOffset"
                 or "global::System.TimeSpan"
                 or "global::System.Guid"
                 or "global::System.DateOnly"
                 or "global::System.TimeOnly";
    }

    private static bool TryGetEnumerableInterface(ITypeSymbol type, out ITypeSymbol? elementType)
    {
        foreach (var i in type.AllInterfaces)
        {
            if (i.OriginalDefinition.ToDisplayString() == "System.Collections.Generic.IEnumerable<T>")
            {
                elementType = i.TypeArguments[0];
                return true;
            }
        }
        elementType = null;
        return false;
    }

    private static bool TryGetDictionaryInterface(ITypeSymbol type, out ITypeSymbol? keyType, out ITypeSymbol? valueType)
    {
        foreach (var i in type.AllInterfaces)
        {
            var def = i.OriginalDefinition.ToDisplayString();
            if (def == "System.Collections.Generic.IDictionary<TKey, TValue>" ||
                def == "System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>")
            {
                keyType = i.TypeArguments[0];
                valueType = i.TypeArguments[1];
                return true;
            }
        }
        keyType = null; valueType = null; return false;
    }

    private static bool IsUserObjectType(ITypeSymbol type)
        => (type.TypeKind is TypeKind.Class or TypeKind.Struct) && type.SpecialType == SpecialType.None && type is not IArrayTypeSymbol;

    private static bool IsTypeAccessibleFromRoot(INamedTypeSymbol t, Target root)
    {
        // Public with public containers
        if (t.DeclaredAccessibility == Accessibility.Public)
        {
            var cur = t.ContainingType;
            while (cur is not null)
            {
                if (cur.DeclaredAccessibility != Accessibility.Public) return false;
                cur = cur.ContainingType;
            }
            return true;
        }

        // Internal allowed when IncludeInternals and same assembly; containers must be public/internal.
        if (!root.IncludeInternals) return false;
        if (!SymbolEqualityComparer.Default.Equals(t.ContainingAssembly, root.Type.ContainingAssembly)) return false;

        var c = t;
        while (c is not null)
        {
            if (c.DeclaredAccessibility is Accessibility.Public or Accessibility.Internal or Accessibility.ProtectedAndInternal)
            {
                c = c.ContainingType;
                continue;
            }
            return false;
        }
        return true;
    }

    private static HashSet<INamedTypeSymbol> BuildReachableTypeClosure(Target root)
    {
        var set = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
        var queue = new Queue<INamedTypeSymbol>();

        set.Add(root.Type);
        queue.Enqueue(root.Type);

        while (queue.Count > 0)
        {
            var current = queue.Dequeue();
            var schema = GetTypeSchema(current);

            foreach (var member in EnumerateComparableMembers(current, root.IncludeInternals, schema))
            {
                var kind = GetEffectiveKind(member.Type, GetDeepCompareAttribute(member.Symbol));
                if (kind is EffectiveKind.Skip or EffectiveKind.Shallow or EffectiveKind.Reference) continue;
                Accumulate(member.Type);
            }
        }
        return set;

        void Accumulate(ITypeSymbol t)
        {
            if (t is IArrayTypeSymbol at) { Accumulate(at.ElementType); return; }
            if (TryGetDictionaryInterface(t, out _, out var valT)) { Accumulate(valT!); return; }
            if (TryGetEnumerableInterface(t, out var elT)) { Accumulate(elT!); return; }

            if (t is INamedTypeSymbol n && IsUserObjectType(n) && IsTypeAccessibleFromRoot(n, root) && set.Add(n))
            {
                queue.Enqueue(n);
            }
        }
    }

    private static AttributeData? GetDeepCompareAttribute(ISymbol symbol)
        => symbol.GetAttributes().FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);

    private static EffectiveKind GetEffectiveKind(ITypeSymbol type, AttributeData? memberAttribute)
    {
        if (memberAttribute is not null)
        {
            var val = memberAttribute.NamedArguments.FirstOrDefault(p => p.Key == "Kind").Value.Value;
            if (val is int mk) return (EffectiveKind)mk;
        }

        var typeAttr = type.OriginalDefinition.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);
        if (typeAttr is not null)
        {
            var val = typeAttr.NamedArguments.FirstOrDefault(p => p.Key == "Kind").Value.Value;
            if (val is int tk) return (EffectiveKind)tk;
        }

        return EffectiveKind.Deep;
    }

    private static bool ResolveOrderInsensitive(Target root, AttributeData? memberAttribute, ITypeSymbol elementType)
    {
        if (memberAttribute is not null)
        {
            var opt = memberAttribute.NamedArguments.FirstOrDefault(a => a.Key == "OrderInsensitive").Value;
            if (opt.Value is bool b) return b;
        }

        var typeAttr = elementType.OriginalDefinition.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);
        if (typeAttr is not null)
        {
            var opt = typeAttr.NamedArguments.FirstOrDefault(a => a.Key == "OrderInsensitive").Value;
            if (opt.Value is bool b) return b;
        }

        return root.OrderInsensitiveCollections;
    }

    private static string GetHelperMethodName(INamedTypeSymbol type)
        => $"AreDeepEqual__{SanitizeIdentifier(type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))}";

    private static string SanitizeIdentifier(string s)
    {
        var sb = new StringBuilder(s.Length);
        foreach (var ch in s) sb.Append(char.IsLetterOrDigit(ch) ? ch : '_');
        return sb.ToString();
    }

    private static string SanitizeFileName(string value)
    {
        var invalid = System.IO.Path.GetInvalidFileNameChars();
        var arr = value.Select(ch => invalid.Contains(ch) ? '_' : ch).ToArray();
        return new string(arr);
    }

    // -------- tiny code writer --------

    private sealed class CodeWriter
    {
        private readonly StringBuilder _sb = new();
        private int _indent;

        public void Line(string text = "")
        {
            if (text.Length == 0) { _sb.AppendLine(); return; }
            _sb.Append(' ', _indent * 4);
            _sb.AppendLine(text);
        }

        public void Open(string header)
        {
            Line(header);
            Line("{");
            _indent++;
        }

        public void Close()
        {
            _indent = Math.Max(0, _indent - 1);
            Line("}");
        }

        public override string ToString() => _sb.ToString();
    }
}
