// <auto-generated/>
#nullable enable
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DeepEqual.Generator;

[Generator(LanguageNames.CSharp)]
public sealed class DeepDiffDeltaGenerator : IIncrementalGenerator
{
    private const string DeepComparableAttributeMetadataName = "DeepEqual.Generator.Shared.DeepComparableAttribute";
    private const string DeepCompareAttributeMetadataName = "DeepEqual.Generator.Shared.DeepCompareAttribute";

    private readonly record struct RootRequest(
        string MetadataName,
        string QualifiedDisplayName,
        string HintName,
        bool IncludeInternals,
        bool OrderInsensitiveCollections,
        bool CycleTrackingEnabled,
        bool IncludeBaseMembers,
        bool GenerateDiff,
        bool GenerateDelta
    );

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var requests =
            context.SyntaxProvider.ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: DeepComparableAttributeMetadataName,
                predicate: static (node, _) => node is TypeDeclarationSyntax,
                transform: static (gasc, ct) =>
                {
                    if (gasc.TargetSymbol is not INamedTypeSymbol typeSymbol) return (RootRequest?)null;

                    var attr = gasc.Attributes.FirstOrDefault(a =>
                        a.AttributeClass?.ToDisplayString() == DeepComparableAttributeMetadataName);
                    if (attr is null) return (RootRequest?)null;

                    static bool HasNamedTrue(AttributeData a, string name) =>
                        a.NamedArguments.Any(kv => kv.Key == name && kv.Value.Value is true);

                    static bool? GetNamedBool(AttributeData a, string name)
                    {
                        foreach (var kv in a.NamedArguments)
                        {
                            if (kv.Key == name && kv.Value.Value is bool b) return b;
                        }
                        return null;
                    }

                    bool includeInternals = HasNamedTrue(attr, "IncludeInternals");
                    bool orderInsensitive = HasNamedTrue(attr, "OrderInsensitiveCollections");
                    bool cycleTracking = GetNamedBool(attr, "CycleTracking") ?? true;
                    bool includeBase = HasNamedTrue(attr, "IncludeBaseMembers");
                    bool genDiff = HasNamedTrue(attr, "GenerateDiff");
                    bool genDelta = HasNamedTrue(attr, "GenerateDelta");

                    var metadataName = BuildMetadataName(typeSymbol);
                    var fqn = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var hint = SanitizeFileName(fqn + "_DeepOps.g.cs");

                    return new RootRequest(metadataName, fqn, hint,
                        includeInternals, orderInsensitive, cycleTracking, includeBase, genDiff, genDelta);
                })
            .Where(static r => r is not null)
            .Select(static (r, _) => r!.Value)
            .Where(static r => r.GenerateDiff || r.GenerateDelta);

        var inputs = requests.Combine(context.CompilationProvider);

        context.RegisterSourceOutput(inputs, (spc, pair) =>
        {
            var req = pair.Left;
            var compilation = pair.Right;
            var resolved = compilation.GetTypeByMetadataName(req.MetadataName);
            if (resolved is null) return;

            var emitter = new Emitter(compilation);
            emitter.EmitForRoot(spc, new Emitter.Target(resolved, req.IncludeInternals, req.OrderInsensitiveCollections, req.CycleTrackingEnabled, req.IncludeBaseMembers, req.GenerateDiff, req.GenerateDelta),
                hintOverride: SanitizeFileName(resolved.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) + "_DeepOps.g.cs"));
        });
    }

    private static string BuildMetadataName(INamedTypeSymbol symbol)
    {
        var sb = new StringBuilder();
        var containing = symbol.ContainingType;
        if (containing is not null)
        {
            sb.Append(BuildMetadataName(containing));
            sb.Append('+');
            sb.Append(symbol.MetadataName);
        }
        else
        {
            var ns = symbol.ContainingNamespace?.ToDisplayString() ?? "";
            if (!string.IsNullOrEmpty(ns))
            {
                sb.Append(ns);
                sb.Append('.');
            }
            sb.Append(symbol.MetadataName);
        }
        return sb.ToString();
    }

    private static string SanitizeFileName(string value)
    {
        var invalid = System.IO.Path.GetInvalidFileNameChars();
        var arr = value.Select(ch => invalid.Contains(ch) ? '_' : ch).ToArray();
        return new string(arr);
    }


    private sealed class Emitter
    {
        private readonly Compilation _compilation;

        public Emitter(Compilation compilation) => _compilation = compilation;

        private const string DeepCompareAttributeName = DeepCompareAttributeMetadataName;

        internal readonly record struct Target(
            INamedTypeSymbol Type,
            bool IncludeInternals,
            bool OrderInsensitiveCollections,
            bool CycleTrackingEnabled,
            bool IncludeBaseMembers,
            bool GenerateDiff,
            bool GenerateDelta);

        private readonly record struct MemberSymbol(string Name, ITypeSymbol Type, ISymbol Symbol);

        private sealed record TypeSchema(
            IReadOnlyList<string> IncludeMembers,
            IReadOnlyList<string> IgnoreMembers,
            CompareKind DefaultKind,
            bool DefaultOrderInsensitive,
            bool DefaultDeltaShallow,
            bool DefaultDeltaSkip);

        public void EmitForRoot(SourceProductionContext spc, Target root, string? hintOverride = null)
        {
            var ns = root.Type.ContainingNamespace.IsGlobalNamespace
                ? null
                : root.Type.ContainingNamespace.ToDisplayString();

            var rootFqn = root.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var helperClass = root.Type.Name + "DeepOps";
            var hintName = hintOverride ?? SanitizeFileName(rootFqn + "_DeepOps.g.cs");

            var w = new CodeWriter();
            w.Line("// <auto-generated/>");
            w.Line("#pragma warning disable");
            w.Line("using System;");
            w.Line("using System.Collections;");
            w.Line("using System.Collections.Generic;");
            w.Line("using DeepEqual.Generator.Shared;");
            w.Line();

            if (ns is not null)
            {
                w.Open("namespace " + ns);
            }

            var accessibility = root.IncludeInternals || root.Type.DeclaredAccessibility != Accessibility.Public ? "internal" : "public";
            var typeParams = root.Type.Arity > 0 ? "<" + string.Join(",", root.Type.TypeArguments.Select(a => a.Name)) + ">" : "";

            // ----- helper class -----
            w.Open(accessibility + " static class " + helperClass + typeParams);

            // reachable closure and registrations (your existing code)
            var reachable = BuildReachableTypeClosure(root);

            w.Open("static " + helperClass + "()");
            foreach (var t in reachable.OrderBy(t => t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), StringComparer.Ordinal))
            {
                var fqn = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                if (root.GenerateDiff)
                {
                    w.Line("GeneratedHelperRegistry.RegisterDiff<" + fqn + ">((l, r, c) => TryGetDiff__" + SanitizeIdentifier(fqn) + "(l, r, c));");
                }
                if (root.GenerateDelta)
                {
                    w.Line("GeneratedHelperRegistry.RegisterDelta<" + fqn + ">(ComputeDelta__" + SanitizeIdentifier(fqn) + ", ApplyDelta__" + SanitizeIdentifier(fqn) + ");");
                }
            }
            w.Close(); // static ctor
            w.Line();

            // public root APIs
            EmitRootApis(w, root.Type, root.CycleTrackingEnabled, root.GenerateDiff, root.GenerateDelta);

            // per-type implementations
            foreach (var t in reachable.OrderBy(t => t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), StringComparer.Ordinal))
            {
                EmitImplementationsForType(w, t, root);
            }

            w.Close(); // close helper class

            // ----- module initializer at namespace scope (NOT nested) -----
            // Builds the open generic arity suffix: "<>", "<,>", "<,,>", ...
            string OpenGenericSuffix(int arity)
            {
                if (arity <= 0) return "";
                if (arity == 1) return "<>";
                return "<" + new string(',', arity - 1) + ">";
            }

            var openSuffix = OpenGenericSuffix(root.Type.Arity);

            // unique type name to avoid collisions across multiple roots
            var initTypeName = "__" + SanitizeIdentifier(helperClass) + "_ModuleInit_" +
                               Math.Abs(root.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).GetHashCode());

            w.Open("internal static class " + initTypeName);

            w.Line("[System.Runtime.CompilerServices.ModuleInitializer]");
            w.Open("internal static void Init()");
            // Force-run the helper's static constructor at module load
            w.Line("System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(typeof(" + helperClass + openSuffix + ").TypeHandle);");
            w.Close(); // Init
            w.Close(); // static class

            if (ns is not null) w.Close(); // namespace

            spc.AddSource(hintName, w.ToString());
        }

        private void EmitRootApis(CodeWriter w, INamedTypeSymbol rootType, bool trackCycles, bool genDiff, bool genDelta)
        {
            var rootFqn = rootType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var valOrRefNull = rootType.IsValueType ? "" : "?";

            if (genDiff)
            {
                // TryGetDiff
                w.Open("public static bool TryGetDiff(" + rootFqn + valOrRefNull + " left, " + rootFqn + valOrRefNull + " right, out DeepEqual.Generator.Shared.Diff<" + rootFqn + "> diff)");
                w.Line("var context = " + (trackCycles ? "new DeepEqual.Generator.Shared.ComparisonContext()" : "DeepEqual.Generator.Shared.ComparisonContext.NoTracking") + ";");
                w.Line("var t = TryGetDiff__" + SanitizeIdentifier(rootFqn) + "(left, right, context);");
                w.Open("if (t.hasDiff)");
                w.Line("diff = t.diff; return true;");
                w.Close();
                w.Line("diff = DeepEqual.Generator.Shared.Diff<" + rootFqn + ">.Empty; return false;");
                w.Close();
                w.Line();

                // GetDiff
                w.Open("public static DeepEqual.Generator.Shared.Diff<" + rootFqn + "> GetDiff(" + rootFqn + valOrRefNull + " left, " + rootFqn + valOrRefNull + " right)");
                w.Line("var context = " + (trackCycles ? "new DeepEqual.Generator.Shared.ComparisonContext()" : "DeepEqual.Generator.Shared.ComparisonContext.NoTracking") + ";");
                w.Line("var t = TryGetDiff__" + SanitizeIdentifier(rootFqn) + "(left, right, context);");
                w.Line("return t.hasDiff ? t.diff : DeepEqual.Generator.Shared.Diff<" + rootFqn + ">.Empty;");
                w.Close();
                w.Line();
            }

            if (genDelta)
            {
                // ComputeDelta
                w.Open("public static void ComputeDelta(" + rootFqn + valOrRefNull + " left, " + rootFqn + valOrRefNull + " right, ref DeepEqual.Generator.Shared.DeltaWriter writer)");
                w.Line("ComputeDelta__" + SanitizeIdentifier(rootFqn) + "(left, right, ref writer);");
                w.Close();
                w.Line();

                // ApplyDelta
                w.Open("public static void ApplyDelta(ref " + rootFqn + valOrRefNull + " target, ref DeepEqual.Generator.Shared.DeltaReader reader)");
                w.Line("ApplyDelta__" + SanitizeIdentifier(rootFqn) + "(ref target, ref reader);");
                w.Close();
                w.Line();
            }
        }

        private void EmitImplementationsForType(CodeWriter w, INamedTypeSymbol type, Target root)
        {
            var fqn = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var id = SanitizeIdentifier(fqn);
            var valOrRefNull = type.IsValueType ? "" : "?";

            var schema = GetTypeSchema(type);

            // ----- TryGetDiff__T -----
            if (root.GenerateDiff)
            {
                w.Open("private static (bool hasDiff, DeepEqual.Generator.Shared.Diff<" + fqn + "> diff) TryGetDiff__" + id + "(" + fqn + valOrRefNull + " left, " + fqn + valOrRefNull + " right, DeepEqual.Generator.Shared.ComparisonContext context)");
                if (!type.IsValueType)
                {
                    w.Open("if (object.ReferenceEquals(left, right))");
                    w.Line("return (false, DeepEqual.Generator.Shared.Diff<" + fqn + ">.Empty);");
                    w.Close();

                    w.Open("if (left is null && right is not null)");
                    w.Line("return (true, DeepEqual.Generator.Shared.Diff<" + fqn + ">.Replacement(right));");
                    w.Close();

                    w.Open("if (left is not null && right is null)");
                    w.Line("return (true, DeepEqual.Generator.Shared.Diff<" + fqn + ">.Replacement(right));");
                    w.Close();

                    if (root.CycleTrackingEnabled)
                    {
                        w.Open("if (!context.Enter(left!, right!))");
                        w.Line("return (false, DeepEqual.Generator.Shared.Diff<" + fqn + ">.Empty);");
                        w.Close();
                        w.Open("try");
                    }
                }

                w.Line("var changes = new System.Collections.Generic.List<DeepEqual.Generator.Shared.MemberChange>();");

                foreach (var m in OrderMembers(EnumerateMembers(type, root.IncludeInternals, root.IncludeBaseMembers, schema)))
                {
                    EmitMemberDiff(w, type, m, root);
                }

                w.Line("return changes.Count == 0 ? (false, DeepEqual.Generator.Shared.Diff<" + fqn + ">.Empty) : (true, DeepEqual.Generator.Shared.Diff<" + fqn + ">.Members(changes));");

                if (!type.IsValueType && root.CycleTrackingEnabled)
                {
                    w.Close(); // try
                    w.Open("finally");
                    w.Line("context.Exit(left!, right!);");
                    w.Close();
                }
                w.Close();
                w.Line();
            }

            // ----- ComputeDelta__T -----
            if (root.GenerateDelta)
            {
                w.Open($"private static void ComputeDelta__{id}({fqn}{valOrRefNull} left, {fqn}{valOrRefNull} right, ref DeepEqual.Generator.Shared.DeltaWriter writer)");
                if (!type.IsValueType)
                {
                    w.Open("if (object.ReferenceEquals(left, right))"); w.Line("return;"); w.Close();
                    w.Open("if (left is null && right is not null)"); w.Line("writer.WriteReplaceObject(right); return;"); w.Close();
                    w.Open("if (left is not null && right is null)"); w.Line("writer.WriteReplaceObject(right); return;"); w.Close();
                }

                // local non-tracking context for ComparisonHelpers in delta
                w.Line("var context = DeepEqual.Generator.Shared.ComparisonContext.NoTracking;");

                foreach (var m in OrderMembers(EnumerateMembers(type, root.IncludeInternals, root.IncludeBaseMembers, schema)))
                {
                    EmitMemberDelta(w, type, m, root);
                }

                w.Close(); // ComputeDelta__T
                w.Line();
            }

            // ----- ApplyDelta__T -----
            if (root.GenerateDelta)
            {
                w.Open($"private static void ApplyDelta__{id}(ref {fqn}{valOrRefNull} target, ref DeepEqual.Generator.Shared.DeltaReader reader)");

                // 1) replacement first
                w.Open("foreach (var op in reader.EnumerateAll())");
                w.Open("if (op.MemberIndex == -1 && op.Kind == DeepEqual.Generator.Shared.DeltaKind.ReplaceObject)");
                w.Line($"target = ({fqn}{valOrRefNull})op.Value; return;");
                w.Close();
                w.Close(); // foreach

                // 2) per-member
                foreach (var m in OrderMembers(EnumerateMembers(type, root.IncludeInternals, root.IncludeBaseMembers, schema)).Select((ms, idx) => (ms, idx)))
                {
                    EmitMemberApplyDelta(w, type, m.ms, m.idx, root);
                }

                w.Close(); // ApplyDelta__T
                w.Line();
            }
        }
        private void EmitMemberDiff(CodeWriter w, INamedTypeSymbol owner, MemberSymbol member, Target root)
        {
            var idx = GetStableMemberIndex(owner, member);
            var left = "left." + member.Name;
            var right = "right." + member.Name;

            var (effKind, orderInsensitive, keyMembers, deltaShallow, deltaSkip) = ResolveEffectiveSettings(member);
            if (effKind == CompareKind.Skip || deltaSkip) return;

            // 1) Value-like (incl. Nullable<T>, enums, structs, string) — always shallow compare
            if (IsValueLike(member.Type))
            {
                var cmp = GetValueLikeEqualsInvocation(member.Type, left, right);
                w.Open($"if (!({cmp}))");
                w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
                w.Close();
                return;
            }

            // 2) Reference compare: only meaningful for reference types
            if (effKind == CompareKind.Reference && member.Type.IsReferenceType)
            {
                w.Open($"if (!object.ReferenceEquals({left}, {right}))");
                w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
                w.Close();
                return;
            }

            // 3) Shallow compare for reference types
            if (effKind == CompareKind.Shallow)
            {
                var tfqn = member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                w.Open($"if (!System.Collections.Generic.EqualityComparer<{tfqn}>.Default.Equals({left}, {right}))");
                w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
                w.Close();
                return;
            }

            // 4) Collections/dicts → v1: Set on any difference
            if (IsEnumerable(member.Type) || IsDictionary(member.Type))
            {
                w.Open($"if (!DeepEqual.Generator.Shared.DynamicDeepComparer.AreEqualDynamic({left}, {right}, context))");
                w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
                w.Close();
                return;
            }

            // 5) Reference-type user objects with deep semantics → runtime dispatch
            // (DeltaShallow forces Set)
            if (deltaShallow)
            {
                w.Open($"if (!DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic({left}, {right}, context))");
                w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
                w.Close();
                return;
            }

            var ltmp = $"__l_{idx}";
            var rtmp = $"__r_{idx}";
            w.Line($"var {ltmp} = {left};");
            w.Line($"var {rtmp} = {right};");

            w.Open($"if (object.ReferenceEquals({ltmp}, {rtmp}))");
            w.Line("// no change");
            w.Close();

            w.Open($"else if ({ltmp} is null || {rtmp} is null)");
            w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            w.Close();

            w.Line("else {");
            w.Line($"    var __tL = {ltmp}.GetType();");
            w.Line($"    var __tR = {rtmp}.GetType();");
            w.Open("    if (!object.ReferenceEquals(__tL, __tR))");
            w.Line($"    changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            w.Close();
            w.Line("    else {");
            w.Line("        if (GeneratedHelperRegistry.TryGetDiffSameType(__tL, " + ltmp + ", " + rtmp + ", context, out var __idiff) && !__idiff.IsEmpty)");
            w.Line("            changes.Add(new DeepEqual.Generator.Shared.MemberChange(" + idx + ", DeepEqual.Generator.Shared.MemberChangeKind.Nested, __idiff));");
            w.Line("    }");
            w.Line("}");
        }

        private void EmitMemberDelta(CodeWriter w, INamedTypeSymbol owner, MemberSymbol member, Target root)
        {
            var idx = GetStableMemberIndex(owner, member);
            var left = "left." + member.Name;
            var right = "right." + member.Name;

            var (effKind, orderInsensitive, keyMembers, deltaShallow, deltaSkip) = ResolveEffectiveSettings(member);
            if (effKind == CompareKind.Skip || deltaSkip) return;

            // Value-like (incl. Nullable<T>, structs, string)
            if (IsValueLike(member.Type))
            {
                var cmp = GetValueLikeEqualsInvocation(member.Type, left, right);
                w.Open($"if (!({cmp}))");
                w.Line($"writer.WriteSetMember({idx}, {right});");
                w.Close();
                return;
            }

            // Reference compare (only for ref types)
            if (effKind == CompareKind.Reference && member.Type.IsReferenceType)
            {
                w.Open($"if (!object.ReferenceEquals({left}, {right}))");
                w.Line($"writer.WriteSetMember({idx}, {right});");
                w.Close();
                return;
            }

            // Shallow compare for reference types
            if (effKind == CompareKind.Shallow)
            {
                var tfqn = member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                w.Open($"if (!System.Collections.Generic.EqualityComparer<{tfqn}>.Default.Equals({left}, {right}))");
                w.Line($"writer.WriteSetMember({idx}, {right});");
                w.Close();
                return;
            }
            // Dictionaries
            if (TryGetDictionaryTypes(member.Type, out var keyT, out var valT))
            {
                var kFqn = keyT.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var vFqn = valT.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var nestedValues = !IsValueLike(valT);
                w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeDictDelta<{kFqn}, {vFqn}>({left}, {right}, {idx}, ref writer, {(nestedValues ? "true" : "false")}, context);");
                return;
            }

            if (member.Type is IArrayTypeSymbol arrSym)
            {
                var elFqn = arrSym.ElementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                // Fast path for primitive/value-like elements
                w.Open($"if (!DeepEqual.Generator.Shared.ComparisonHelpers.ArraysEqual<{elFqn}>({left}, {right}))");
                w.Line($"writer.WriteSetMember({idx}, {right});");
                w.Close();

                return;
            }

            // Collections (ordered)
            if (TryGetEnumerableElement(member.Type, out var elem) && !(member.Type is IArrayTypeSymbol))
            {
                // Only emit granular ops when we can treat it as IList<T>; else fallback to SetMember
                if (TryGetListInterface(member.Type, out var listEl))
                {
                    // We already know it's a list (TryGetListInterface succeeded)
                    var elFqn = elem.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var cmpExpr = IsValueLike(elem)
                        ? $"new System.Func<{elFqn}, {elFqn}, bool>((a,b)=>System.Collections.Generic.EqualityComparer<{elFqn}>.Default.Equals(a,b))"
                        : $"new System.Func<{elFqn}, {elFqn}, bool>((a,b)=>DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic(a,b, context))";

                    w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeListDelta<{elFqn}>({left}, {right}, {idx}, ref writer, {cmpExpr});");

                }
                else
                {
                    // e.g., arrays or read-only enumerables -> fallback (replace)
                    w.Open($"if (!DeepEqual.Generator.Shared.DynamicDeepComparer.AreEqualDynamic({left}, {right}, context))");
                    w.Line($"writer.WriteSetMember({idx}, {right});");
                    w.Close();
                }
                return;
            }

            // User object (deep, polymorphic-safe)
            if (deltaShallow)
            {
                w.Open($"if (!DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic({left}, {right}, context))");
                w.Line($"writer.WriteSetMember({idx}, {right});");
                w.Close();
                return;
            }

            var ltmp = $"__l_{idx}";
            var rtmp = $"__r_{idx}";
            w.Line($"var {ltmp} = {left};");
            w.Line($"var {rtmp} = {right};");

            w.Open($"if (object.ReferenceEquals({ltmp}, {rtmp}))");
            w.Line("// identical");
            w.Close();

            w.Open($"else if ({ltmp} is null || {rtmp} is null)");
            w.Line($"writer.WriteSetMember({idx}, {right});");
            w.Close();

            w.Line("else {");
            w.Line($"    var __tL = {ltmp}.GetType();");
            w.Line($"    var __tR = {rtmp}.GetType();");
            w.Open("    if (!object.ReferenceEquals(__tL, __tR))");
            w.Line($"    writer.WriteSetMember({idx}, {right});");
            w.Close();
            w.Line("    else {");
            w.Line("        var __sub = new DeepEqual.Generator.Shared.DeltaDocument();");
            w.Line("        var __w   = new DeepEqual.Generator.Shared.DeltaWriter(__sub);");
            w.Line("        GeneratedHelperRegistry.ComputeDeltaSameType(__tL, " + ltmp + ", " + rtmp + ", ref __w);");
            w.Open("        if (!__sub.IsEmpty)");
            w.Line($"        writer.WriteNestedMember({idx}, __sub);");
            w.Close();
            w.Line("    }");
            w.Line("}");
        }

        private static bool TryGetEnumerableElement(ITypeSymbol t, out ITypeSymbol element)
        {
            element = null!;
            if (t is IArrayTypeSymbol at) { element = at.ElementType; return true; }

            foreach (var i in t.AllInterfaces)
            {
                if (i is INamedTypeSymbol ni &&
                    ni.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                    "global::System.Collections.Generic.IEnumerable<T>")
                {
                    element = ni.TypeArguments[0];
                    return true;
                }
            }
            if (t is INamedTypeSymbol nt &&
                nt.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                "global::System.Collections.Generic.IEnumerable<T>")
            {
                element = nt.TypeArguments[0];
                return true;
            }
            return false;
        }

        private static bool TryGetListInterface(ITypeSymbol t, out ITypeSymbol element)
        {
            element = null!;
            foreach (var i in t.AllInterfaces)
            {
                if (i is INamedTypeSymbol ni &&
                    ni.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                    "global::System.Collections.Generic.IList<T>")
                {
                    element = ni.TypeArguments[0];
                    return true;
                }
            }
            // List<T> itself
            if (t is INamedTypeSymbol nt &&
                nt.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                "global::System.Collections.Generic.List<T>")
            {
                element = nt.TypeArguments[0];
                return true;
            }
            return false;
        }

        private static bool TryGetDictionaryTypes(ITypeSymbol t, out ITypeSymbol key, out ITypeSymbol value)
        {
            key = value = null!;
            static bool IsDict(INamedTypeSymbol x) =>
                x.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                    "global::System.Collections.Generic.IDictionary<TKey, TValue>" ||
                x.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                    "global::System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>";

            foreach (var i in t.AllInterfaces)
            {
                if (i is INamedTypeSymbol ni && IsDict(ni))
                {
                    key = ni.TypeArguments[0];
                    value = ni.TypeArguments[1];
                    return true;
                }
            }

            if (t is INamedTypeSymbol nt && IsDict(nt))
            {
                key = nt.TypeArguments[0];
                value = nt.TypeArguments[1];
                return true;
            }

            return false;
        }

        private void EmitMemberApplyDelta(CodeWriter w, INamedTypeSymbol owner, MemberSymbol member, int index, Target root)
        {
            var memberIdx = GetStableMemberIndex(owner, member);
            var propAccess = "target." + member.Name;
            var typeFqn = member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var nullableQ = member.Type.IsReferenceType ? "?" : "";

            w.Line("// apply for member #" + memberIdx + " " + member.Name);
            w.Open($"foreach (var op in reader.EnumerateMember({memberIdx}))");
            w.Open("switch (op.Kind)");

            // SetMember (always)
            w.Open("case DeepEqual.Generator.Shared.DeltaKind.SetMember:");
            w.Line($"{propAccess} = ({typeFqn})op.Value;");
            w.Line("break;");
            w.Close();

            // NestedMember: only for user objects (not value-like / lists / dicts)
            if (!IsValueLike(member.Type) && !TryGetEnumerableElement(member.Type, out _) && !TryGetDictionaryTypes(member.Type, out _, out _))
            {
                var nestedId = SanitizeIdentifier(member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                w.Open("case DeepEqual.Generator.Shared.DeltaKind.NestedMember:");
                w.Line($"{typeFqn}{nullableQ} __tmp = {propAccess};");
                w.Line("var __obj = (object?)__tmp;");
                w.Line("var __subReader = new DeepEqual.Generator.Shared.DeltaReader(op.Nested!);");
                w.Open("if (__obj != null)");
                w.Line("var __t = __obj.GetType();");
                w.Line("GeneratedHelperRegistry.TryApplyDeltaSameType(__t, ref __obj, ref __subReader);");
                w.Close();
                w.Line($"{propAccess} = ({typeFqn})__obj;");
                w.Line("break;");
                w.Close();
            }

            // -------- Sequence granular ops (only when the member is IList<T>) --------
            if (TryGetListInterface(member.Type, out var elType))
            {
                var elFqn = elType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                w.Open("case DeepEqual.Generator.Shared.DeltaKind.SeqReplaceAt:");
                w.Open($"if ({propAccess} is System.Collections.Generic.IList<{elFqn}> __list_r)");
                w.Line($"__list_r[op.Index] = ({elFqn})op.Value!;");
                w.Close();
                w.Line("break;");
                w.Close();

                w.Open("case DeepEqual.Generator.Shared.DeltaKind.SeqAddAt:");
                w.Open($"if ({propAccess} is System.Collections.Generic.IList<{elFqn}> __list_a)");
                w.Line($"__list_a.Insert(op.Index, ({elFqn})op.Value!);");
                w.Close();
                w.Line("break;");
                w.Close();

                w.Open("case DeepEqual.Generator.Shared.DeltaKind.SeqRemoveAt:");
                w.Open($"if ({propAccess} is System.Collections.Generic.IList<{elFqn}> __list_d)");
                w.Line($"__list_d.RemoveAt(op.Index);");
                w.Close();
                w.Line("break;");
                w.Close();
            }
            else
            {
                // If not a mutable list, ignore (we only emit granular ops for lists; arrays fell back to SetMember)
                w.Open("case DeepEqual.Generator.Shared.DeltaKind.SeqReplaceAt:");
                w.Line("break;");
                w.Close();
                w.Open("case DeepEqual.Generator.Shared.DeltaKind.SeqAddAt:");
                w.Line("break;");
                w.Close();
                w.Open("case DeepEqual.Generator.Shared.DeltaKind.SeqRemoveAt:");
                w.Line("break;");
                w.Close();
            }

            // -------- Dictionary granular ops --------
            if (TryGetDictionaryTypes(member.Type, out var kType, out var vType))
            {
                var kFqn = kType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var vFqn = vType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                w.Open("case DeepEqual.Generator.Shared.DeltaKind.DictSet:");
                w.Open($"if ({propAccess} is System.Collections.Generic.IDictionary<{kFqn}, {vFqn}> __dict_s)");
                w.Line($"__dict_s[({kFqn})op.Key!] = ({vFqn})op.Value!;");
                w.Close();
                w.Line("break;");
                w.Close();

                w.Open("case DeepEqual.Generator.Shared.DeltaKind.DictRemove:");
                w.Open($"if ({propAccess} is System.Collections.Generic.IDictionary<{kFqn}, {vFqn}> __dict_r)");
                w.Line($"__dict_r.Remove(({kFqn})op.Key!);");
                w.Close();
                w.Line("break;");
                w.Close();

                w.Open("case DeepEqual.Generator.Shared.DeltaKind.DictNested:");
                w.Open($"if ({propAccess} is System.Collections.Generic.IDictionary<{kFqn}, {vFqn}> __dict_n)");
                w.Open($"if (__dict_n.TryGetValue(({kFqn})op.Key!, out var __old))");
                w.Line("object? __obj = __old;");
                w.Line("var __subReader = new DeepEqual.Generator.Shared.DeltaReader(op.Nested!);");
                w.Line("GeneratedHelperRegistry.TryApplyDeltaSameType(__obj!.GetType(), ref __obj, ref __subReader);");
                w.Line($"__dict_n[({kFqn})op.Key!] = ({vFqn})__obj!;");
                w.Close();
                w.Close();
                w.Line("break;");
                w.Close();
            }
            else
            {
                w.Open("case DeepEqual.Generator.Shared.DeltaKind.DictSet:"); w.Line("break;"); w.Close();
                w.Open("case DeepEqual.Generator.Shared.DeltaKind.DictRemove:"); w.Line("break;"); w.Close();
                w.Open("case DeepEqual.Generator.Shared.DeltaKind.DictNested:"); w.Line("break;"); w.Close();
            }

            // default
            w.Open("default:");
            w.Line("break;");
            w.Close();

            w.Close(); // switch
            w.Close(); // foreach

            w.Line();
        }

        private static IEnumerable<MemberSymbol> EnumerateMembers(INamedTypeSymbol type, bool includeInternals, bool includeBase, TypeSchema schema)
        {
            var flags = new[] { Accessibility.Public }.ToImmutableHashSet();
            if (includeInternals) flags.Add(Accessibility.Internal);

            var set = new List<MemberSymbol>();

            var t = type;
            while (t is not null)
            {
                foreach (var m in t.GetMembers())
                {
                    if (m is IPropertySymbol p && !p.IsStatic && p.GetMethod is not null && p.GetMethod.DeclaredAccessibility is var acc1 && flags.Contains(acc1))
                    {
                        if (p.SetMethod is null) continue;
                        set.Add(new MemberSymbol(p.Name, p.Type, p));
                    }
                    else if (m is IFieldSymbol f && !f.IsStatic && f.DeclaredAccessibility is var acc2 && flags.Contains(acc2))
                    {
                        if (f.IsReadOnly) continue;
                        set.Add(new MemberSymbol(f.Name, f.Type, f));
                    }
                }

                if (!includeBase) break;
                t = t.BaseType;
            }

            var includes = schema.IncludeMembers;
            var ignores = schema.IgnoreMembers;

            var filtered = set
                .Where(ms => includes.Count == 0 || includes.Contains(ms.Name, StringComparer.Ordinal))
                .Where(ms => !ignores.Contains(ms.Name, StringComparer.Ordinal));

            return filtered;
        }

        private static IEnumerable<MemberSymbol> OrderMembers(IEnumerable<MemberSymbol> members) =>
            members.OrderBy(m => m.Name, StringComparer.Ordinal);

        private TypeSchema GetTypeSchema(INamedTypeSymbol type)
        {
            CompareKind defKind = CompareKind.Deep;
            bool defOrderInsensitive = false;
            bool defDeltaShallow = false;
            bool defDeltaSkip = false;
            var includes = new List<string>();
            var ignores = new List<string>();

            foreach (var a in type.GetAttributes())
            {
                if (a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName)
                {
                    foreach (var kv in a.NamedArguments)
                    {
                        switch (kv.Key)
                        {
                            case "Kind": defKind = (CompareKind)kv.Value.Value!; break;
                            case "OrderInsensitive": defOrderInsensitive = (bool)kv.Value.Value!; break;
                            case "Members": includes.AddRange(kv.Value.Values.Select(v => (string)v.Value!)); break;
                            case "IgnoreMembers": ignores.AddRange(kv.Value.Values.Select(v => (string)v.Value!)); break;
                            case "DeltaShallow": defDeltaShallow = (bool)kv.Value.Value!; break;
                            case "DeltaSkip": defDeltaSkip = (bool)kv.Value.Value!; break;
                        }
                    }
                }
            }

            return new TypeSchema(includes, ignores, defKind, defOrderInsensitive, defDeltaShallow, defDeltaSkip);
        }

        private (CompareKind kind, bool orderInsensitive, string[] keys, bool deltaShallow, bool deltaSkip) ResolveEffectiveSettings(MemberSymbol member)
        {
            CompareKind kind = CompareKind.Deep;
            bool orderInsensitive = false;
            bool deltaShallow = false;
            bool deltaSkip = false;
            string[] keys = Array.Empty<string>();

            foreach (var a in member.Symbol.GetAttributes())
            {
                if (a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName)
                {
                    foreach (var kv in a.NamedArguments)
                    {
                        switch (kv.Key)
                        {
                            case "Kind": kind = (CompareKind)kv.Value.Value!; break;
                            case "OrderInsensitive": orderInsensitive = (bool)kv.Value.Value!; break;
                            case "KeyMembers": keys = kv.Value.Values.Select(v => (string)v.Value!).ToArray(); break;
                            case "DeltaShallow": deltaShallow = (bool)kv.Value.Value!; break;
                            case "DeltaSkip": deltaSkip = (bool)kv.Value.Value!; break;
                        }
                    }
                }
            }

            return (kind, orderInsensitive, keys, deltaShallow, deltaSkip);
        }

        private static bool IsValueLike(ITypeSymbol t)
        {
            if (t.SpecialType == SpecialType.System_String) return true;
            if (t.IsValueType) return true;

            if (t is INamedTypeSymbol nn && nn.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Nullable<T>")
                return true;

            return false;
        }

        private static readonly SymbolDisplayFormat Fqn = SymbolDisplayFormat.FullyQualifiedFormat;
        private static bool IsEnumerable(ITypeSymbol t)
        {
            // arrays
            if (t is IArrayTypeSymbol) return true;

            // IEnumerable<T> implemented?
            foreach (var i in t.AllInterfaces)
            {
                if (i is INamedTypeSymbol ni &&
                    ni.OriginalDefinition.ToDisplayString(Fqn) == "global::System.Collections.Generic.IEnumerable<T>")
                    return true;
            }

            // type itself is an IEnumerable<T> (rare, but be thorough)
            if (t is INamedTypeSymbol nt &&
                nt.OriginalDefinition.ToDisplayString(Fqn) == "global::System.Collections.Generic.IEnumerable<T>")
                return true;

            return false;
        }

        private static bool IsDictionary(ITypeSymbol t)
        {
            static bool IsDict(INamedTypeSymbol x) =>
                x.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                "global::System.Collections.Generic.IDictionary<TKey, TValue>" ||
                x.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                "global::System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>";

            // via interfaces
            foreach (var i in t.AllInterfaces)
                if (i is INamedTypeSymbol ni && IsDict(ni))
                    return true;

            // type itself is a dict
            if (t is INamedTypeSymbol nt && IsDict(nt))
                return true;

            return false;
        }

        private static string GetValueLikeEqualsInvocation(ITypeSymbol t, string leftExpr, string rightExpr)
        {
            // strings & numerics with your helpers
            if (t.SpecialType == SpecialType.System_String)
                return $"DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualStrings({leftExpr}, {rightExpr}, context)";
            if (t.SpecialType == SpecialType.System_Double)
                return $"DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualDouble({leftExpr}, {rightExpr}, context)";
            if (t.SpecialType == SpecialType.System_Single)
                return $"DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualSingle({leftExpr}, {rightExpr}, context)";
            if (t.SpecialType == SpecialType.System_Decimal)
                return $"DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualDecimal({leftExpr}, {rightExpr}, context)";

            var tfqn = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            return $"System.Collections.Generic.EqualityComparer<{tfqn}>.Default.Equals({leftExpr}, {rightExpr})";
        }

        private static int GetStableMemberIndex(INamedTypeSymbol owner, MemberSymbol member)
        {
            unchecked
            {
                var h = 17;
                foreach (var ch in owner.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
                    h = h * 31 + ch;
                foreach (var ch in member.Name)
                    h = h * 31 + ch;
                return (h & 0x7FFFFFFF) % 1_000_000_007;
            }
        }

        private static string SanitizeIdentifier(string s)
        {
            var sb = new StringBuilder(s.Length);
            foreach (var ch in s) sb.Append(char.IsLetterOrDigit(ch) ? ch : '_');
            return sb.ToString();
        }

        private static HashSet<INamedTypeSymbol> BuildReachableTypeClosure(Target root)
        {
            var set = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default)
            {
                root.Type
            };
            var queue = new Queue<INamedTypeSymbol>();
            queue.Enqueue(root.Type);

            while (queue.Count > 0)
            {
                var cur = queue.Dequeue();

                foreach (var member in EnumerateMembers(cur, root.IncludeInternals, root.IncludeBaseMembers, new TypeSchema(Array.Empty<string>(), Array.Empty<string>(), CompareKind.Deep, false, false, false)))
                {
                    Accumulate(member.Type);
                }
            }

            return set;

            void Accumulate(ITypeSymbol t)
            {
                if (t is INamedTypeSymbol nnt && nnt.OriginalDefinition.ToDisplayString() == "System.Nullable<T>")
                {
                    t = nnt.TypeArguments[0];
                }

                if (t is IArrayTypeSymbol at)
                {
                    Accumulate(at.ElementType);
                    return;
                }

                if (t is INamedTypeSymbol nn)
                {
                    foreach (var i in nn.AllInterfaces)
                    {
                        if (i is INamedTypeSymbol ii && ii.OriginalDefinition.ToDisplayString() == "System.Collections.Generic.IEnumerable<T>")
                        {
                            Accumulate(ii.TypeArguments[0]);
                        }
                        if (i is INamedTypeSymbol di && (di.OriginalDefinition.ToDisplayString() == "System.Collections.Generic.IDictionary<TKey, TValue>" ||
                                                         di.OriginalDefinition.ToDisplayString() == "System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>"))
                        {
                            Accumulate(di.TypeArguments[0]);
                            Accumulate(di.TypeArguments[1]);
                        }
                    }
                }

                if (t is INamedTypeSymbol user && user.ContainingNamespace?.ToDisplayString() is { Length: > 0 } ns
                    && !ns.StartsWith("System", StringComparison.Ordinal)
                    && set.Add(user))
                {
                    queue.Enqueue(user);
                }
            }
        }
    }

    private sealed class CodeWriter
    {
        private readonly StringBuilder _buffer = new();
        private int _indent;

        public void Line(string text = "")
        {
            if (text.Length == 0) { _buffer.AppendLine(); return; }
            _buffer.Append(' ', _indent * 4);
            _buffer.AppendLine(text);
        }

        public void Open(string header) { Line(header); Line("{"); _indent++; }

        public void Close() { _indent = Math.Max(0, _indent - 1); Line("}"); }

        public override string ToString() => _buffer.ToString();
    }
}
public enum CompareKind
{
    Deep,
    Shallow,
    Reference,
    Skip
}