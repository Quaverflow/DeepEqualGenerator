// <auto-generated/>
#nullable enable
using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;

namespace DeepEqual.Analyzers
{
    [DiagnosticAnalyzer(LanguageNames.CSharp)]
    public sealed class UseDeepOpsAnalyzer : DiagnosticAnalyzer
    {
        public static readonly DiagnosticDescriptor Rule = new(
            id: "DEEP001",
            title: "Use DeepOps typed API",
            messageFormat: "Replace per-type Deep* calls with DeepOps typed methods",
            category: "DeepEqual.Usage",
            defaultSeverity: DiagnosticSeverity.Info,
            isEnabledByDefault: true);

        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => ImmutableArray.Create(Rule);

        public override void Initialize(AnalysisContext context)
        {
            context.EnableConcurrentExecution();
            context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
            context.RegisterSyntaxNodeAction(Analyze, Microsoft.CodeAnalysis.CSharp.SyntaxKind.SimpleMemberAccessExpression);
        }

        private static void Analyze(SyntaxNodeAnalysisContext ctx)
        {
            var node = (Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax)ctx.Node;
            var symbol = ctx.SemanticModel.GetSymbolInfo(node).Symbol;
            if (symbol is IMethodSymbol ms && ms.ContainingType.Name.EndsWith("DeepOps", System.StringComparison.Ordinal))
            {
                ctx.ReportDiagnostic(Diagnostic.Create(Rule, node.GetLocation()));
            }
        }
    }
}