using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace DeepEqual.Generator;

internal sealed class DiffDeltaEmitter
{
    private const string DeepCompareAttributeName = GenCommon.DeepCompareAttributeMetadataName;

    private readonly Dictionary<INamedTypeSymbol, Dictionary<string, int>> _stableIndexTables =
        new(SymbolEqualityComparer.Default);
    private readonly Dictionary<string, (bool Diff, bool Delta)> _emittedDiffDelta = new(StringComparer.Ordinal);

    private bool _useStableIndices;

    public void EmitForRoot(SourceProductionContext spc, DiffDeltaTarget root, string? hintOverride = null)
    {
        Diagnostics.DiagnosticPass(spc, root.Type);

        _useStableIndices = root.GenerateDelta &&
                            (root.StableMode == StableMemberIndexMode.On ||
                             root.StableMode == StableMemberIndexMode.Auto);
        _stableIndexTables.Clear();

        var rootFqn = root.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var sanitizedId = GenCommon.SanitizeIdentifier(rootFqn);
        var hintName = hintOverride ?? GenCommon.SanitizeFileName(rootFqn + ".DeepOpsExtensions.Diff.g.cs");

        var reachable = BuildReachableTypeClosure(root);

        var w = new CodeWriter();
        w.Line("// <auto-generated/>");
        w.Line("#pragma warning disable");
        w.Line("using System;");
        w.Line("using System.Collections;");
        w.Line("using System.Collections.Generic;");
        w.Line("using DeepEqual.Generator.Shared;");
        w.Line();

        // namespace + class wrapped with lambda Open so braces are guaranteed correct
        w.Open("namespace DeepEqual", () =>
        {
            w.Open("public static partial class DeepOpsExtensions", () =>
            {
                var ensureEqualityName = "__EnsureEquality__" + sanitizedId;
                var ensureDiffName = "__EnsureDiffDelta__" + sanitizedId;
                var guardFieldName = "__ddInit__" + sanitizedId;
                var lockFieldName = "__ddLock__" + sanitizedId;
                var moduleInitName = "__ModuleInit_Diff__" + sanitizedId;

                EmitterCommon.EmitEnsureOnce(
                    w,
                    ensureDiffName,
                    guardFieldName,
                    lockFieldName,
                    writer =>
                    {
                        foreach (var t in reachable.OrderBy(t => t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), StringComparer.Ordinal))
                        {
                            var fqn = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                            var id = GenCommon.SanitizeIdentifier(fqn);
                            if (root.GenerateDiff)
                                writer.Line("GeneratedHelperRegistry.RegisterDiff<" + fqn + ">((l, r, c) => TryGetDiff__" + id + "(l, r, c));");
                            if (root.GenerateDelta)
                                writer.Line("GeneratedHelperRegistry.RegisterDelta<" + fqn + ">(ComputeDelta__" + id + ", ApplyDelta__" + id + ");");
                        }
                    },
                    ensureEqualityName + "();");

                EmitterCommon.EmitModuleInitializer(w, moduleInitName, ensureDiffName);

                EmitRootApis(w, root.Type, root.CycleTrackingEnabled, root.GenerateDiff, root.GenerateDelta, ensureDiffName);

                foreach (var t in reachable.OrderBy(t => t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                         StringComparer.Ordinal))
                {
                    EmitImplementationsForType(w, t, root);
                }
            });
        });

        var text = w.ToString();
        spc.AddSource(hintName, SourceText.From(text, Encoding.UTF8));

        if (HasDeltaTrack(root.Type))
            EmitDeltaTrackPart(spc, root.Type, root);
    }

    private static void EmitRootApis(
        CodeWriter w,
        INamedTypeSymbol rootType,
        bool cycleTrackingEnabled,
        bool generateDiff,
        bool generateDelta,
        string ensureMethodName)
    {
        var fqn = rootType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var id = GenCommon.SanitizeIdentifier(fqn);
        var nullSuffix = rootType.IsValueType ? string.Empty : "?";
        var methodTypeParameters = GenCommon.GetTypeParameterList(rootType);
        var methodConstraints = GenCommon.GetTypeConstraintClauses(rootType);
        var defaultContextExpr = "ctx ?? new DeepEqual.Generator.Shared.ComparisonContext()";

        if (generateDiff)
        {
            var diffSignature =
                "public static (bool has, DeepEqual.Generator.Shared.Diff<" + fqn + "> diff) GetDeepDiff" +
                methodTypeParameters + "(this " + fqn + nullSuffix + " left, " + fqn + nullSuffix +
                " right, DeepEqual.Generator.Shared.ComparisonContext? ctx = null)" + methodConstraints;

            w.Open(diffSignature, () =>
            {
                w.Line(ensureMethodName + "();");
                w.Line("var context = " + defaultContextExpr + ";");
                w.Line("return TryGetDiff__" + id + "(left, right, context);");
            });
            w.Line();
        }

        if (generateDelta)
        {
            w.Line("/// <summary>Computes a delta (patch) from <paramref name=\"left\"/> to <paramref name=\"right\"/>.</summary>");
            w.Line("/// <remarks>");
            w.Line("/// Collections policy:");
            w.Line("/// <list type=\"bullet\">");
            w.Line("/// <item><description><b>Arrays</b>: treated as replace-on-change. Any detected difference emits a single <c>SetMember</c> for that member.</description></item>");
            w.Line("/// <item><description><b>IList&lt;T&gt;</b>: granular sequence ops (<c>SeqReplaceAt</c>/<c>SeqAddAt</c>/<c>SeqRemoveAt</c>) are emitted.</description></item>");
            w.Line("/// <item><description><b>IDictionary</b>/<b>IReadOnlyDictionary</b>: granular key ops (<c>DictSet</c>/<c>DictRemove</c>/<c>DictNested</c>) are emitted.</description></item>");
            w.Line("/// </list>");
            w.Line("/// This mirrors <see cref=\"ApplyDeepDelta(ref " + fqn + nullSuffix + ", DeepEqual.Generator.Shared.DeltaDocument)\"/> behavior, where arrays are not patched item-by-item.</remarks>");

            var computeSignature =
                "public static DeepEqual.Generator.Shared.DeltaDocument ComputeDeepDelta" +
                methodTypeParameters + "(this " + fqn + nullSuffix + " left, " + fqn + nullSuffix +
                " right, DeepEqual.Generator.Shared.ComparisonContext? ctx = null)" + methodConstraints;

            w.Open(computeSignature, () =>
            {
                w.Line(ensureMethodName + "();");
                w.Line("var context = " + defaultContextExpr + ";");
                w.Line("var doc = new DeepEqual.Generator.Shared.DeltaDocument();");
                w.Line("var writer = new DeepEqual.Generator.Shared.DeltaWriter(doc);");
                w.Line("ComputeDelta__" + id + "(left, right, context, ref writer);");
                w.Line("return doc;");
            });
            w.Line();

            w.Line("/// <summary>Applies a previously computed delta to <paramref name=\"target\"/>.</summary>");
            w.Line("/// <remarks>");
            w.Line("/// Collections policy during application:");
            w.Line("/// <list type=\"bullet\">");
            w.Line("/// <item><description><b>Arrays</b>: always replaced as a whole when a <c>SetMember</c> op is present. Sequence ops are ignored for arrays.</description></item>");
            w.Line("/// <item><description><b>IList&lt;T&gt;</b>: sequence ops are applied in-place (replace/add/remove).</description></item>");
            w.Line("/// <item><description><b>IDictionary</b>/<b>IReadOnlyDictionary</b>: key ops are applied (set/remove) and nested deltas are applied when present.</description></item>");
            w.Line("/// </list>");
            w.Line("/// This matches the generator's policy in delta computation.</remarks>");

            if (!rootType.IsValueType)
            {
                var applyReaderSignature =
                    "public static " + fqn + nullSuffix + " ApplyDeepDelta" + methodTypeParameters +
                    "(this " + fqn + nullSuffix + " target, in DeepEqual.Generator.Shared.DeltaReader reader)" + methodConstraints;

                w.Open(applyReaderSignature, () =>
                {
                    w.Line(ensureMethodName + "();");
                    w.Line("var localReader = reader;");
                    w.Line("ApplyDelta__" + id + "(ref target, ref localReader);");
                    w.Line("return target;");
                });
                w.Line();

                var applyDocSignature =
                    "public static " + fqn + nullSuffix + " ApplyDeepDelta" + methodTypeParameters +
                    "(this " + fqn + nullSuffix + " target, DeepEqual.Generator.Shared.DeltaDocument delta)" + methodConstraints;

                w.Open(applyDocSignature, () =>
                {
                    w.Line(ensureMethodName + "();");
                    w.Line("var reader = new DeepEqual.Generator.Shared.DeltaReader(delta);");
                    w.Line("ApplyDelta__" + id + "(ref target, ref reader);");
                    w.Line("return target;");
                });
                w.Line();
            }
            else
            {
                var applyReaderSignature =
                    "public static void ApplyDeepDelta" + methodTypeParameters +
                    "(this ref " + fqn + " target, in DeepEqual.Generator.Shared.DeltaReader reader)" + methodConstraints;

                w.Open(applyReaderSignature, () =>
                {
                    w.Line(ensureMethodName + "();");
                    w.Line("var localReader = reader;");
                    w.Line("ApplyDelta__" + id + "(ref target, ref localReader);");
                });
                w.Line();

                var applyDocSignature =
                    "public static void ApplyDeepDelta" + methodTypeParameters +
                    "(this ref " + fqn + " target, DeepEqual.Generator.Shared.DeltaDocument delta)" + methodConstraints;

                w.Open(applyDocSignature, () =>
                {
                    w.Line(ensureMethodName + "();");
                    w.Line("var reader = new DeepEqual.Generator.Shared.DeltaReader(delta);");
                    w.Line("ApplyDelta__" + id + "(ref target, ref reader);");
                });
                w.Line();
            }
        }
    }

    private static bool IsExpando(ITypeSymbol t)
    {
        return t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Dynamic.ExpandoObject";
    }

    private void EmitDeltaTrackPart(SourceProductionContext spc, INamedTypeSymbol type, DiffDeltaTarget root)
    {
        var ns = type.ContainingNamespace.IsGlobalNamespace ? null : type.ContainingNamespace.ToDisplayString();
        var fqn = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var typeParams = type.Arity > 0 ? "<" + string.Join(",", type.TypeArguments.Select(a => a.Name)) + ">" : "";
        var hint = GenCommon.SanitizeFileName(fqn + ".__DeltaTrack.g.cs");

        var threadSafe = false;
        foreach (var a in type.GetAttributes())
        {
            var full = a.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (full == "DeepEqual.Generator.Shared.DeltaTrackAttribute")
                foreach (var kv in a.NamedArguments)
                    if (kv is { Key: "ThreadSafe", Value.Value: bool b })
                        threadSafe = b;
        }

        var schema = GetTypeSchema(type);
        var members = OrderMembers(EnumerateMembers(type, root.IncludeInternals, root.IncludeBaseMembers, schema)).ToArray();

        var w = new CodeWriter();
        w.Line("// <auto-generated/>");
        w.Line("#pragma warning disable");
        w.Line("using System;");
        w.Line("using System.Runtime.CompilerServices;");
        w.Line("using System.Threading;");

        void EmitClassBody()
        {
            w.Line("private long __dirty0;");
            w.Line("private long[]? __dirtyEx;");
            w.Line("internal const int __DirtyWordShift = 6;");
            w.Line("internal const int __DirtyWordMask = 63;");

            if (threadSafe)
            {
                w.Method("private static long __AtomicOr(ref long location, long mask)", () =>
                {
                    w.Line("long initial, computed;");
                    w.DoWhile("Interlocked.CompareExchange(ref location, computed, initial) != initial", () =>
                    {
                        w.Line("initial = Volatile.Read(ref location);");
                        w.Line("computed = initial | mask;");
                    });
                    w.Line("return computed;");
                });

                w.Method("private static long __AtomicAnd(ref long location, long mask)", () =>
                {
                    w.Line("long initial, computed;");
                    w.DoWhile("Interlocked.CompareExchange(ref location, computed, initial) != initial", () =>
                    {
                        w.Line("initial = Volatile.Read(ref location);");
                        w.Line("computed = initial & mask;");
                    });
                    w.Line("return computed;");
                });
            }

            w.Line();
            w.Method("private static int __TrailingZeroCount(ulong value)", () =>
            {
                w.If("value == 0", () =>
                {
                    w.Line("return 64;");
                });

                w.Line("int count = 0;");
                w.While("(value & 1UL) == 0", () =>
                {
                    w.Line("count++;");
                    w.Line("value >>= 1;");
                });
                w.Line("return count;");
            });
            w.Line();

            w.Method("[MethodImpl(MethodImplOptions.AggressiveInlining)] internal void __MarkDirty(int bit)", () =>
            {
                w.If("(uint)bit <= 63", () =>
                {
                    if (threadSafe)
                        w.Line("__AtomicOr(ref __dirty0, 1L << bit);");
                    else
                        w.Line("__dirty0 |= 1L << bit;");
                })
                .Else(() =>
                {
                    w.Line("var word = bit >> __DirtyWordShift;");
                    w.Line("var idx = word - 1;");
                    w.Line("var arr = __dirtyEx;");
                    w.If("arr is null || idx >= arr.Length", () =>
                    {
                        w.Line("Array.Resize(ref __dirtyEx, arr is null ? Math.Max(1, idx + 1) : Math.Max(arr.Length * 2, idx + 1));");
                    });
                    if (threadSafe)
                        w.Line("__AtomicOr(ref __dirtyEx![idx], 1L << (bit & __DirtyWordMask));");
                    else
                        w.Line("__dirtyEx![idx] |= 1L << (bit & __DirtyWordMask);");
                });
            });

            w.Method("[MethodImpl(MethodImplOptions.AggressiveInlining)] internal bool __TryPopNextDirty(out int bit)", () =>
            {
                w.Line("var w0 = Volatile.Read(ref __dirty0);");
                w.If("w0 != 0", () =>
                {
                    w.Line("var u = (ulong)w0;");
                    w.Line("var tz = __TrailingZeroCount(u);");
                    if (threadSafe)
                        w.Line("__AtomicAnd(ref __dirty0, ~(1L << tz));");
                    else
                        w.Line("__dirty0 &= ~(1L << tz);");
                    w.Line("bit = tz;");
                    w.Line("return true;");
                })
                .Else(() =>
                {
                    w.Line("var ex = __dirtyEx;");
                    w.If("ex is not null", () =>
                    {
                        w.ForRaw("int i = 0; i < ex.Length; i++", () =>
                        {
                            w.Line("var wi = Volatile.Read(ref ex[i]);");
                            w.If("wi != 0", () =>
                            {
                                w.Line("var u2 = (ulong)wi;");
                                w.Line("var tz2 = __TrailingZeroCount(u2);");
                                if (threadSafe)
                                    w.Line("__AtomicAnd(ref ex[i], ~(1L << tz2));");
                                else
                                    w.Line("ex[i] &= ~(1L << tz2);");
                                w.Line("bit = ((i + 1) << __DirtyWordShift) + tz2;");
                                w.Line("return true;");
                            });
                        });
                    });
                    w.Line("bit = -1;");
                    w.Line("return false;");
                });
            });

            w.Method("[MethodImpl(MethodImplOptions.AggressiveInlining)] internal void __ClearDirtyBit(int bit)", () =>
            {
                w.If("(uint)bit <= 63", () =>
                {
                    if (threadSafe)
                        w.Line("__AtomicAnd(ref __dirty0, ~(1L << bit));");
                    else
                        w.Line("__dirty0 &= ~(1L << bit);");
                })
                .Else(() =>
                {
                    w.Line("var word = bit >> __DirtyWordShift;");
                    w.Line("var idx = word - 1;");
                    w.If("__dirtyEx is null || idx >= __dirtyEx.Length", () =>
                    {
                        w.Line("return;");
                    });
                    if (threadSafe)
                        w.Line("__AtomicAnd(ref __dirtyEx![idx], ~(1L << (bit & __DirtyWordMask)));");
                    else
                        w.Line("__dirtyEx![idx] &= ~(1L << (bit & __DirtyWordMask));");
                });
            });

            w.Method("[MethodImpl(MethodImplOptions.AggressiveInlining)] internal bool __HasAnyDirty()", () =>
            {
                w.If("Volatile.Read(ref __dirty0) != 0", () =>
                {
                    w.Line("return true;");
                });
                w.Line("var ex2 = __dirtyEx;");
                w.If("ex2 is not null", () =>
                {
                    w.ForRaw("int i = 0; i < ex2.Length; i++", () =>
                    {
                        w.If("Volatile.Read(ref ex2[i]) != 0", () =>
                        {
                            w.Line("return true;");
                        });
                    });
                });
                w.Line("return false;");
            });

            for (var i = 0; i < members.Length; i++)
                w.Line($"internal const int __Bit_{GenCommon.SanitizeIdentifier(members[i].Name)} = {i};");
        }

        var decl = type.DeclaredAccessibility == Accessibility.Public ? "public" : "internal";
        if (ns is not null)
        {
            w.Namespace(ns, () =>
            {
                w.Class(decl + " partial class " + type.Name + typeParams, EmitClassBody);
            });
        }
        else
        {
            w.Class(decl + " partial class " + type.Name + typeParams, EmitClassBody);
        }

        spc.AddSource(hint, w.ToString());
    }
    private void EmitImplementationsForType(CodeWriter w, INamedTypeSymbol type, DiffDeltaTarget root)
    {
        var fqn = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var id = GenCommon.SanitizeIdentifier(fqn);
        var key = fqn;
        _emittedDiffDelta.TryGetValue(key, out var emittedState);
        var needDiff = root.GenerateDiff && !emittedState.Diff;
        var needDelta = root.GenerateDelta && !emittedState.Delta;
        if (!needDiff && !needDelta) return;

        var nullSuffix = type.IsValueType ? "" : "?";
        var schema = GetTypeSchema(type);
        var deltaTracked = HasDeltaTrack(type);
        var helperTypeParameters = GenCommon.EnumerateAllTypeParameters(type).ToArray();
        var helperTypeParameterList = GenCommon.GetTypeParameterList(helperTypeParameters);
        var helperConstraints = GenCommon.GetTypeConstraintClauses(helperTypeParameters);

        // Stable indices table (if needed for delta)
        if (_useStableIndices && !_stableIndexTables.ContainsKey(type))
        {
            var orderedStable = OrderMembers(EnumerateMembers(type, root.IncludeInternals, root.IncludeBaseMembers, schema)).ToArray();
            var map = new Dictionary<string, int>(StringComparer.Ordinal);
            for (var i = 0; i < orderedStable.Length; i++) map[orderedStable[i].Name] = i;
            _stableIndexTables[type] = map;
        }

        // -------- DIFF: TryGetDiff__{id} --------
        if (needDiff)
        {
            w.Method(
                $"private static (bool hasDiff, DeepEqual.Generator.Shared.Diff<{fqn}> diff) TryGetDiff__{id}{helperTypeParameterList}({fqn}{nullSuffix} left, {fqn}{nullSuffix} right, DeepEqual.Generator.Shared.ComparisonContext context){helperConstraints}",
            () =>
            {
                if (!type.IsValueType)
                {
                    w.If("object.ReferenceEquals(left, right)", () =>
                    {
                        w.Line($"return (false, DeepEqual.Generator.Shared.Diff<{fqn}>.Empty);");
                    });

                    w.If("left is null && right is not null", () =>
                    {
                        w.Line($"return (true, DeepEqual.Generator.Shared.Diff<{fqn}>.Replacement(right));");
                    });

                    w.If("left is not null && right is null", () =>
                    {
                        w.Line($"return (true, DeepEqual.Generator.Shared.Diff<{fqn}>.Replacement(right));");
                    });

                    if (root.CycleTrackingEnabled)
                    {
                        w.If("!context.Enter(left!, right!)", () =>
                        {
                            w.Line($"return (false, DeepEqual.Generator.Shared.Diff<{fqn}>.Empty);");
                        });
                        TryChain.Try(w, () =>
                        {
                            w.Line("var changes = new System.Collections.Generic.List<DeepEqual.Generator.Shared.MemberChange>();");
                            foreach (var m in OrderMembers(EnumerateMembers(type, root.IncludeInternals, root.IncludeBaseMembers, schema)))
                                EmitMemberDiff(w, type, m, root);

                            w.Line($"return changes.Count == 0 ? (false, DeepEqual.Generator.Shared.Diff<{fqn}>.Empty) : (true, DeepEqual.Generator.Shared.Diff<{fqn}>.Members(changes));");
                        })
                        .Finally(() =>
                        {
                            w.Line("context.Exit(left!, right!);");
                        });
                        return;
                    }
                }

                w.Line("var changes = new System.Collections.Generic.List<DeepEqual.Generator.Shared.MemberChange>();");
                foreach (var m in OrderMembers(EnumerateMembers(type, root.IncludeInternals, root.IncludeBaseMembers, schema)))
                    EmitMemberDiff(w, type, m, root);

                w.Line($"return changes.Count == 0 ? (false, DeepEqual.Generator.Shared.Diff<{fqn}>.Empty) : (true, DeepEqual.Generator.Shared.Diff<{fqn}>.Members(changes));");
            });

            w.Line();
        }

        // -------- DELTA: ComputeDelta__{id} --------
        if (needDelta)
        {
            w.Method(
                $"private static void ComputeDelta__{id}{helperTypeParameterList}({fqn}{nullSuffix} left, {fqn}{nullSuffix} right, DeepEqual.Generator.Shared.ComparisonContext context, ref DeepEqual.Generator.Shared.DeltaWriter writer){helperConstraints}",
            () =>
            {
                if (!type.IsValueType)
                {
                    w.If("object.ReferenceEquals(left, right)", () =>
                    {
                        w.Line("return;");
                    });

                    w.If("left is null && right is not null", () =>
                    {
                        w.Line("writer.WriteReplaceObject(right);");
                        w.Line("return;");
                    });

                    w.If("left is not null && right is null", () =>
                    {
                        w.Line("writer.WriteReplaceObject(right);");
                        w.Line("return;");
                    });

                    if (root.CycleTrackingEnabled)
                    {
                        w.If("!context.Enter(left!, right!)", () =>
                        {
                            w.Line("return;");
                        });

                        TryChain.Try(w, () =>
                        {
                            EmitComputeDeltaBody();
                        })
                        .Finally(() =>
                        {
                            w.Line("context.Exit(left!, right!);");
                        });
                        return;
                    }
                }

                EmitComputeDeltaBody();

                // ---- local to method: body for compute delta ----
                void EmitComputeDeltaBody()
                {
                    var ordered = OrderMembers(EnumerateMembers(type, root.IncludeInternals, root.IncludeBaseMembers, schema)).ToArray();

                    if (deltaTracked && !type.IsValueType)
                    {
                        w.Line("var __validate = context.Options.ValidateDirtyOnEmit;");
                        w.Line("var __r = right;");
                        w.Line("var __hasDirty = __r is not null && __r.__HasAnyDirty();");

                        // validated: drain
                        w.If("__hasDirty && __validate", () =>
                        {
                            w.While("__r.__TryPopNextDirty(out _)", () => { });
                        });

                        // also flush children marked [DeltaTrack]
                        w.If("__validate && right is not null", () =>
                        {
                            foreach (var m in ordered)
                            {
                                bool isPlainRef =
                                    m.Type.IsReferenceType &&
                                    m.Type.SpecialType != SpecialType.System_String &&
                                    !(m.Type is IArrayTypeSymbol) &&
                                    !TryGetListInterface(m.Type, out _) &&
                                    !TryGetDictionaryTypes(m.Type, out _, out _);

                                if (isPlainRef && m.Type is INamedTypeSymbol nt && HasDeltaTrack(nt))
                                {
                                    var rightExpr = "right." + m.Name;
                                    w.If($"{rightExpr} is not null && {rightExpr}.__HasAnyDirty()", () =>
                                    {
                                        w.While($"{rightExpr}.__TryPopNextDirty(out _)", () => { });
                                    });
                                }
                            }
                        });

                        // fast mode
                        w.If("__hasDirty && !__validate", () =>
                        {
                            foreach (var m in ordered)
                            {
                                var idx = GetStableMemberIndex(type, m);
                                w.Line($"bool __emitted_m{idx} = false;");
                            }

                            w.While("__r.__TryPopNextDirty(out var __bit)", () =>
                            {
                                SwitchChain.Switch(w, "__bit", sw =>
                                {
                                    for (var idx = 0; idx < ordered.Length; idx++)
                                    {
                                        var mem = ordered[idx];
                                        var stable = GetStableMemberIndex(type, mem);
                                        var leftExpr = "left." + mem.Name;
                                        var rightExpr = "right." + mem.Name;
                                        var (kind, orderInsensitive, keys, dShallow, dSkip) = ResolveEffectiveSettings(mem);

                                        sw.Case(idx.ToString(), () =>
                                        {
                                            if (!dSkip && (orderInsensitive || keys.Length > 0))
                                            {
                                                w.Line($"writer.WriteSetMember({stable}, {rightExpr});");
                                                w.Line($"__emitted_m{stable} = true;");
                                                return;
                                            }

                                            if (kind == CompareKind.Skip || dSkip)
                                            {
                                                w.Line($"__emitted_m{stable} = true;");
                                                return;
                                            }

                                            if (TryGetDictionaryTypes(mem.Type, out var kType, out var vType))
                                            {
                                                var kFqn = kType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                                                var vFqn = vType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                                                var nestedExpr = IsValueLike(vType) ? "false" : "true";
                                                w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeDictDelta<{kFqn}, {vFqn}>({leftExpr}, {rightExpr}, {stable}, ref writer, {nestedExpr}, context);");
                                                w.Line($"__emitted_m{stable} = true;");
                                                return;
                                            }

                                            if (TryGetEnumerableElement(mem.Type, out var elemType) && TryGetListInterface(mem.Type, out _))
                                            {
                                                var (_, ordIns, keyMembers, _, dSk) = ResolveEffectiveSettings(mem);

                                                if (!dSk && (ordIns || keyMembers.Length > 0))
                                                {
                                                    w.Line($"writer.WriteSetMember({stable}, {rightExpr});");
                                                    w.Line($"__emitted_m{stable} = true;");
                                                    return;
                                                }

                                                var elFqn = elemType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                                                var deepAttr = GetDeepCompareAttribute(mem.Symbol);
                                                var custom = GetEffectiveComparerType(elemType, deepAttr);

                                                if (custom != null)
                                                {
                                                    var cfqn = custom.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                                                    var cmpVar = "__cmpE_" + SanitizeIdentifier(type.Name) + "_" + SanitizeIdentifier(mem.Name);
                                                    w.Line($"var {cmpVar} = (System.Collections.Generic.IEqualityComparer<{elFqn}>)System.Activator.CreateInstance(typeof({cfqn}))!;");
                                                    w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeListDelta<{elFqn}, DeepEqual.Generator.Shared.DelegatingElementComparer<{elFqn}>>({leftExpr}, {rightExpr}, {stable}, ref writer, new DeepEqual.Generator.Shared.DelegatingElementComparer<{elFqn}>({cmpVar}), context);");
                                                }
                                                else if (IsValueLike(elemType))
                                                {
                                                    w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeListDelta<{elFqn}, DeepEqual.Generator.Shared.DefaultElementComparer<{elFqn}>>({leftExpr}, {rightExpr}, {stable}, ref writer, new DeepEqual.Generator.Shared.DefaultElementComparer<{elFqn}>(), context);");
                                                }
                                                else
                                                {
                                                    w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeListDeltaNested<{elFqn}>({leftExpr}, {rightExpr}, {stable}, ref writer, context);");
                                                }
                                                w.Line($"__emitted_m{stable} = true;");
                                                return;
                                            }

                                            if (TryGetEnumerableElement(mem.Type, out _))
                                            {
                                                w.Line($"writer.WriteSetMember({stable}, {rightExpr});");
                                                w.Line($"__emitted_m{stable} = true;");
                                                return;
                                            }

                                            if (IsValueLike(mem.Type) || kind == CompareKind.Reference || kind == CompareKind.Shallow || dShallow)
                                            {
                                                w.Line($"writer.WriteSetMember({stable}, {rightExpr});");
                                                w.Line($"__emitted_m{stable} = true;");
                                                return;
                                            }

                                            if (mem.Type is INamedTypeSymbol { IsGenericType: false, IsAnonymousType: false })
                                            {
                                                var ltmp = $"__l_{stable}";
                                                var rtmp = $"__r_{stable}";
                                                w.Line($"var {ltmp} = {leftExpr};");
                                                w.Line($"var {rtmp} = {rightExpr};");
                                                w.Line("var __doc = new DeepEqual.Generator.Shared.DeltaDocument();");
                                                w.Line("var __w = new DeepEqual.Generator.Shared.DeltaWriter(__doc);");
                                                w.If($"!object.ReferenceEquals({ltmp}, {rtmp}) && {ltmp} is not null && {rtmp} is not null", () =>
                                                {
                                                    w.Line($"var __t = {ltmp}.GetType();");
                                                    w.If($"object.ReferenceEquals(__t, {rtmp}.GetType())", () =>
                                                    {
                                                        w.Line($"GeneratedHelperRegistry.ComputeDeltaSameType(__t, {ltmp}, {rtmp}, context, ref __w);");
                                                    });
                                                });
                                                w.If("!__doc.IsEmpty", () =>
                                                {
                                                    w.Line($"writer.WriteNestedMember({stable}, __doc);");
                                                })
                                                .Else(() =>
                                                {
                                                    w.Line($"writer.WriteSetMember({stable}, {rightExpr});");
                                                });
                                                w.Line($"__emitted_m{stable} = true;");
                                                return;
                                            }

                                            w.Line($"writer.WriteSetMember({stable}, {rightExpr});");
                                            w.Line($"__emitted_m{stable} = true;");
                                        });
                                    }
                                });
                            });

                            // post-loop catch-up for unordered/keyed lists
                            foreach (var mem in ordered)
                            {
                                if (TryGetEnumerableElement(mem.Type, out _) && TryGetListInterface(mem.Type, out _))
                                {
                                    var (_, ordIns, keyMembers, _, dSkip2) = ResolveEffectiveSettings(mem);
                                    if (!dSkip2 && (ordIns || keyMembers.Length > 0))
                                    {
                                        var stable = GetStableMemberIndex(type, mem);
                                        var rightExpr = "right." + mem.Name;
                                        w.If($"!__emitted_m{stable}", () =>
                                        {
                                            w.Line($"writer.WriteSetMember({stable}, {rightExpr});");
                                        });
                                    }
                                }
                            }
                        });

                        // Validated mode OR no-dirty: per-member comparison
                        w.If("!__hasDirty || __validate", () =>
                        {
                            foreach (var m in ordered) EmitMemberDelta(w, type, m, root);
                        });
                    }
                    else
                    {
                        foreach (var m in ordered) EmitMemberDelta(w, type, m, root);
                    }
                }
            });

            w.Line();
        }

        // -------- DELTA: ApplyDelta__{id} --------
        if (needDelta)
        {
            // helper lambdas that emit *generated* code using fluent helpers
            void EmitInPlaceReplaceForGetOnlyCollection(string targetExpr, string elFqn, string kind)
            {
                switch (kind)
                {
                    case "ISet":
                        w.Line($"var __dobj = {targetExpr};");
                        w.If($"__dobj is System.Collections.Generic.ISet<{elFqn}> __set", () =>
                        {
                            w.Line("__set.Clear();");
                            w.If($"op.Value is System.Collections.Generic.IEnumerable<{elFqn}> __src", () =>
                            {
                                w.Foreach("var __v", "__src", () =>
                                {
                                    w.Line("__set.Add(__v);");
                                });
                            });
                        });
                        break;

                    case "LinkedList":
                        w.Line($"var __ldst = {targetExpr};");
                        w.If($"__ldst is System.Collections.Generic.LinkedList<{elFqn}> __ll", () =>
                        {
                            w.Line("__ll.Clear();");
                            w.If($"op.Value is System.Collections.Generic.IEnumerable<{elFqn}> __src", () =>
                            {
                                w.Foreach("var __v", "__src", () =>
                                {
                                    w.Line("__ll.AddLast(__v);");
                                });
                            });
                        });
                        break;

                    case "Queue":
                        w.Line($"var __qdst = {targetExpr};");
                        w.If($"__qdst is System.Collections.Generic.Queue<{elFqn}> __q", () =>
                        {
                            w.Line("__q.Clear();");
                            w.If($"op.Value is System.Collections.Generic.IEnumerable<{elFqn}> __src", () =>
                            {
                                w.Foreach("var __v", "__src", () =>
                                {
                                    w.Line("__q.Enqueue(__v);");
                                });
                            });
                        });
                        break;

                    case "Stack":
                        w.Line($"var __sdst = {targetExpr};");
                        w.If($"__sdst is System.Collections.Generic.Stack<{elFqn}> __s", () =>
                        {
                            w.Line("__s.Clear();");
                            w.If($"op.Value is System.Collections.Generic.IEnumerable<{elFqn}> __src", () =>
                            {
                                w.Line($"var __tmp = __src as System.Collections.Generic.IList<{elFqn}> ?? new System.Collections.Generic.List<{elFqn}>(__src);");
                                w.ForRaw("int __i = __tmp.Count - 1; __i >= 0; __i--", () =>
                                {
                                    w.Line("__s.Push(__tmp[__i]);");
                                });
                            });
                        });
                        break;

                    case "ICollection":
                        w.Line($"var __cdst = {targetExpr};");
                        w.If($"__cdst is System.Collections.Generic.ICollection<{elFqn}> __c", () =>
                        {
                            w.Line("__c.Clear();");
                            w.If($"op.Value is System.Collections.Generic.IEnumerable<{elFqn}> __src", () =>
                            {
                                w.Foreach("var __v", "__src", () =>
                                {
                                    w.Line("__c.Add(__v);");
                                });
                            });
                        });
                        break;
                }
            }

            string BclKind(ITypeSymbol t, out ITypeSymbol? e)
            {
                e = null;

                // We require an element type. If we can't find one, we bail out.
                if (!TryGetEnumerableElement(t, out var te) || te is null)
                    return "";

                e = te;

                var f = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                if (f.StartsWith("global::System.Collections.Generic.HashSet<")) return "ISet";
                if (f.StartsWith("global::System.Collections.Generic.SortedSet<")) return "ISet";
                if (f.StartsWith("global::System.Collections.Generic.LinkedList<")) return "LinkedList";
                if (f.StartsWith("global::System.Collections.Generic.Queue<")) return "Queue";
                if (f.StartsWith("global::System.Collections.Generic.Stack<")) return "Stack";

                foreach (var i in (t as INamedTypeSymbol)?.AllInterfaces ?? [])
                {
                    var ifqn = i.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    if (ifqn.StartsWith("global::System.Collections.Generic.ISet<")) return "ISet";
                    if (ifqn.StartsWith("global::System.Collections.Generic.ICollection<")) return "ICollection";
                }

                // Not a special-cased BCL get-only shape
                e = null;
                return "";
            }

            w.Method(
                $"private static void ApplyDelta__{id}{helperTypeParameterList}(ref {fqn}{nullSuffix} target, ref DeepEqual.Generator.Shared.DeltaReader reader){helperConstraints}",
            () =>
            {
                // Normalize ops from the reader to drop in-document duplicates that can surface
                // when the delta is materialized from multiple arrays (e.g., Ops + Operations).
                w.Line("var __raw = reader.AsSpan();");
                w.Line("var __norm = new System.Collections.Generic.List<DeepEqual.Generator.Shared.DeltaOp>(__raw.Length);");
                w.Line("var __seenRemoveIdxDoc = new System.Collections.Generic.Dictionary<int, System.Collections.Generic.HashSet<int>>();");
                w.Line("var __seenAddAtDoc     = new System.Collections.Generic.Dictionary<int, System.Collections.Generic.HashSet<int>>();");

                w.ForRaw("int __i=0; __i<__raw.Length; __i++", () =>
                {
                    w.Line("ref readonly var __o = ref __raw[__i];");

                    // Deduplicate: one RemoveAt per (memberIndex, index) per document
                    w.If("__o.Kind == DeepEqual.Generator.Shared.DeltaKind.SeqRemoveAt", () =>
                    {
                        w.Line("if (!__seenRemoveIdxDoc.TryGetValue(__o.MemberIndex, out var __rem)) __seenRemoveIdxDoc[__o.MemberIndex] = __rem = new System.Collections.Generic.HashSet<int>();");
                        w.Line("if (!__rem.Add(__o.Index)) continue;");
                    });

                    // Deduplicate: one AddAt per (memberIndex, index) per document
                    w.If("__o.Kind == DeepEqual.Generator.Shared.DeltaKind.SeqAddAt", () =>
                    {
                        w.Line("if (!__seenAddAtDoc.TryGetValue(__o.MemberIndex, out var __adds)) __seenAddAtDoc[__o.MemberIndex] = __adds = new System.Collections.Generic.HashSet<int>();");
                        w.Line("if (!__adds.Add(__o.Index)) continue;");
                    });

                    w.Line("__norm.Add(__o);");
                });

                w.Line("var __opsArr = __norm.ToArray();");
                w.Line("var __ops = __opsArr.AsSpan();");


                // early ReplaceObject
                w.ForRaw("int __ri = 0; __ri < __ops.Length; __ri++", () =>
                {
                    w.Line("ref readonly var __ro = ref __ops[__ri];");
                    w.If("__ro.MemberIndex == -1 && __ro.Kind == DeepEqual.Generator.Shared.DeltaKind.ReplaceObject", () =>
                    {
                        w.Line($"target = ({fqn}{nullSuffix})__ro.Value;");
                        w.Line("return;");
                    });
                });

                // presize pass setup
                var __preByOrdinal = OrderMembers(
                        EnumerateMembers(type, root.IncludeInternals, root.IncludeBaseMembers, schema))
                    .Select(m => (ms: m, idx: GetStableMemberIndex(type, m)))
                    .ToArray();

                var __hasPresizableMembers =
                    __preByOrdinal.Any(t =>
                        (TryGetListInterface(t.ms.Type, out _) && !(t.ms.Type is IArrayTypeSymbol)) ||
                        (TryGetDictionaryTypes(t.ms.Type, out _, out _) && !IsExpando(t.ms.Type)));

                if (__hasPresizableMembers)
                {
                    w.If("target is not null", () =>
                    {
                        foreach (var t2 in __preByOrdinal)
                        {
                            var m = t2.ms;
                            var idx = t2.idx;

                            if (TryGetListInterface(m.Type, out _) && m.Type is not IArrayTypeSymbol)
                                w.Line($"int __adds_m{idx} = 0;");
                            else if (TryGetDictionaryTypes(m.Type, out _, out _) && !IsExpando(m.Type))
                                w.Line($"int __dictSets_m{idx} = 0;");
                        }
                        foreach (var t2 in __preByOrdinal)
                        {
                            var m = t2.ms;
                            var idx = t2.idx;

                            // For list members only, we track same-index removes to no-op duplicates within one document
                            if (TryGetListInterface(m.Type, out _) && m.Type is not IArrayTypeSymbol)
                                w.Line($"var __seenRemoveIdx_m{idx} = new System.Collections.Generic.HashSet<int>();");
                        }
                        w.ForRaw("int __i=0; __i<__ops.Length; __i++", () =>
                        {
                            w.Line("ref readonly var __o = ref __ops[__i];");
                            SwitchChain.Switch(w, "__o.MemberIndex", sw =>
                            {
                                foreach (var t2 in __preByOrdinal)
                                {
                                    var m = t2.ms;
                                    var idx = t2.idx;

                                    if (TryGetListInterface(m.Type, out _) && m.Type is not IArrayTypeSymbol)
                                    {
                                        sw.Case(idx.ToString(), () =>
                                        {
                                            w.If("__o.Kind==DeepEqual.Generator.Shared.DeltaKind.SeqAddAt", () =>
                                            {
                                                w.Line($"__adds_m{idx}++;");
                                            });
                                        });
                                    }
                                    else if (TryGetDictionaryTypes(m.Type, out _, out _) && !IsExpando(m.Type))
                                    {
                                        sw.Case(idx.ToString(), () =>
                                        {
                                            w.If("__o.Kind==DeepEqual.Generator.Shared.DeltaKind.DictSet", () =>
                                            {
                                                w.Line($"__dictSets_m{idx}++;");
                                            });
                                        });
                                    }
                                }
                            });
                        });

                        foreach (var t2 in __preByOrdinal)
                        {
                            var m = t2.ms;
                            var idx = t2.idx;

                            if (TryGetListInterface(m.Type, out var elTypeForPresize) && m.Type is not IArrayTypeSymbol)
                            {
                                var elFqnPS = elTypeForPresize.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                                w.Line($"var __obj_list_m{idx} = target.{m.Name};");
                                w.If($"__adds_m{idx} > 0 && __obj_list_m{idx} is System.Collections.Generic.List<{elFqnPS}> __l_m{idx}", () =>
                                {
                                    w.Line($"__l_m{idx}.EnsureCapacity(__l_m{idx}.Count + __adds_m{idx});");
                                });
                            }
                            else if (TryGetDictionaryTypes(m.Type, out var preKType, out var preVType) && !IsExpando(m.Type))
                            {
                                var kFqnPS = preKType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                                var vFqnPS = preVType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                                w.Line($"var __obj_dict_m{idx} = target.{m.Name};");
                                w.If($"__dictSets_m{idx} > 0 && __obj_dict_m{idx} is System.Collections.Generic.Dictionary<{kFqnPS}, {vFqnPS}> __d_m{idx}", () =>
                                {
                                    w.Line($"__d_m{idx}.EnsureCapacity(__d_m{idx}.Count + __dictSets_m{idx});");
                                });
                            }
                        }
                    });
                }

                // apply pass
                w.Line("var __seenRemoveIdx = new System.Collections.Generic.Dictionary<int, System.Collections.Generic.HashSet<int>>();");

                // ADD THIS LINE:
                w.Line("var __seenAddAt = new System.Collections.Generic.Dictionary<int, System.Collections.Generic.HashSet<int>>();");

                w.ForRaw("int __ai=0; __ai<__ops.Length; __ai++", () =>
                {
                    w.Line("ref readonly var op = ref __ops[__ai];");
                    SwitchChain.Switch(w, "op.MemberIndex", swOuter =>
                    {
                        // ReplaceObject
                        swOuter.Case("-1", () =>
                        {
                            w.If("op.Kind == DeepEqual.Generator.Shared.DeltaKind.ReplaceObject", () =>
                            {
                                w.Line($"target = ({fqn}{nullSuffix})op.Value;");
                                w.Line("return;");
                            });
                        });

                        // Each member
                        var byOrdinal = OrderMembers(EnumerateMembers(type, root.IncludeInternals,
                                root.IncludeBaseMembers, schema))
                            .Select((ms, i) => (ms, i)).ToArray();

                        foreach (var t2 in byOrdinal)
                        {
                            var member = t2.ms;
                            var ordinal = t2.i;
                            var memberIdx = GetStableMemberIndex(type, member);
                            var propAccess = "target." + member.Name;
                            var typeFqn = member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                            var nullableQ = member.Type.IsReferenceType ? "?" : "";
                            var hasSetterForMember =
                                member.Symbol is IPropertySymbol __ps2 && __ps2.SetMethod is not null;

                            swOuter.Case(memberIdx.ToString(), () =>
                            {
                                w.Line($"int __lastRemoveIdx_m{memberIdx} = int.MinValue;");
                                SwitchChain.Switch(w, "op.Kind", swKind =>
                                {
                                    if (IsExpando(member.Type))
                                    {
                                        EmitApplyForExpando(w, swKind, propAccess, clearDirty: !type.IsValueType && deltaTracked, ordinal);
                                        swKind.Default(() => { /* no-op */ });
                                    }
                                    else
                                    {
                                        // SetMember
                                        swKind.Case("DeepEqual.Generator.Shared.DeltaKind.SetMember", () =>
                                        {
                                            if (member.Type is IArrayTypeSymbol)
                                            {
                                                w.Line($"{propAccess} = ({typeFqn}{nullableQ})op.Value;");
                                            }
                                            else if (TryGetDictionaryTypes(member.Type, out var kForSet, out var vForSet))
                                            {
                                                var kFqn = kForSet.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                                                var vFqn = vForSet.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                                                if (hasSetterForMember)
                                                {
                                                    w.Line($"{propAccess} = ({$"global::System.Collections.Generic.Dictionary<{kFqn}, {vFqn}>"}{nullableQ})op.Value;");
                                                }
                                                else
                                                {
                                                    w.Line($"var __dobj = {propAccess};");
                                                    w.If($"__dobj is global::System.Collections.Generic.IDictionary<{kFqn}, {vFqn}> __d", () =>
                                                    {
                                                        w.Line("__d.Clear();");
                                                        w.If($"op.Value is global::System.Collections.Generic.IEnumerable<global::System.Collections.Generic.KeyValuePair<{kFqn}, {vFqn}>> __src", () =>
                                                        {
                                                            w.Foreach("var __kv", "__src", () =>
                                                            {
                                                                w.Line("__d[__kv.Key] = __kv.Value;");
                                                            });
                                                        });
                                                    });
                                                    // else: no-op
                                                }
                                            }
                                            else
                                            {
                                                var bcl = BclKind(member.Type, out var elT);
                                                if (!hasSetterForMember && !string.IsNullOrEmpty(bcl) && elT is not null)
                                                {
                                                    var eFqn = elT.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                                                    EmitInPlaceReplaceForGetOnlyCollection(propAccess, eFqn, bcl);
                                                }
                                                else
                                                {
                                                    w.Line($"{propAccess} = ({typeFqn})op.Value;");
                                                }
                                            }

                                            if (!type.IsValueType && deltaTracked)
                                                w.Line($"target.__ClearDirtyBit({ordinal});");
                                        });

                                        // Seq ops
                                        if (TryGetListInterface(member.Type, out var elType))
                                        {
                                            var elFqn = elType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                                            void EmitListOp(string opName, string tmp)
                                            {
                                                swKind.Case($"DeepEqual.Generator.Shared.DeltaKind.{opName}", () =>
                                                {
                                                    w.Line($"object? {tmp} = {propAccess};");
                                                    w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ApplyListOpCloneIfNeeded<{elFqn}>(ref {tmp}, in op);");
                                                    if (hasSetterForMember) w.Line($"{propAccess} = ({typeFqn}){tmp};");
                                                    if (!type.IsValueType && deltaTracked) w.Line($"target.__ClearDirtyBit({ordinal});");
                                                });
                                            }

                                            EmitListOp("SeqReplaceAt", "__obj_seq_r");
                                            // One AddAt per (member, index) within this document’s apply pass
                                            // One AddAt per (member, index) within this document’s apply pass
                                            swKind.Case("DeepEqual.Generator.Shared.DeltaKind.SeqAddAt", () =>
                                            {
                                                // ensure per-member set exists (use STABLE member index used in op.MemberIndex)
                                                w.Line($"if (!__seenAddAt.TryGetValue({memberIdx}, out var __addsAt)) {{ __addsAt = new System.Collections.Generic.HashSet<int>(); __seenAddAt[{memberIdx}] = __addsAt; }}");

                                                // only apply the FIRST AddAt for this (member, index) in this pass
                                                w.If("__addsAt.Add(op.Index)", () =>
                                                {
                                                    w.Line($"object? __obj_seq_a = {propAccess};");
                                                    w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ApplyListOpCloneIfNeeded<{elFqn}>(ref __obj_seq_a, in op);");
                                                    if (hasSetterForMember) w.Line($"{propAccess} = ({typeFqn})__obj_seq_a;");
                                                    if (!type.IsValueType && deltaTracked) w.Line($"target.__ClearDirtyBit({ordinal});");
                                                });
                                            });

                                            swKind.Case("DeepEqual.Generator.Shared.DeltaKind.SeqRemoveAt", () =>
                                            {
                                                // One remove per (member, index) per document apply pass
                                                w.Line($"if (!__seenRemoveIdx.TryGetValue({memberIdx}, out var __set)) {{ __set = new System.Collections.Generic.HashSet<int>(); __seenRemoveIdx[{memberIdx}] = __set; }}");
                                                w.If("__set.Add(op.Index)", () =>
                                                {
                                                    w.Line($"object? __obj_seq_d = {propAccess};");
                                                    w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ApplyListOpCloneIfNeeded<{elFqn}>(ref __obj_seq_d, in op);");
                                                    if (hasSetterForMember) w.Line($"{propAccess} = ({typeFqn})__obj_seq_d;");
                                                    if (!type.IsValueType && deltaTracked) w.Line($"target.__ClearDirtyBit({ordinal});");
                                                });
                                            });

                                            EmitListOp("SeqNestedAt", "__obj_seq_n");
                                        }



                                        // Dict ops
                                        if (TryGetDictionaryTypes(member.Type, out var kType2, out var vType2))
                                        {
                                            var kFqn2 = kType2.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                                            var vFqn2 = vType2.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                                            void EmitDictOp(string opName, string tmp)
                                            {
                                                swKind.Case($"DeepEqual.Generator.Shared.DeltaKind.{opName}", () =>
                                                {
                                                    w.Line($"object? {tmp} = {propAccess};");
                                                    w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ApplyDictOpCloneIfNeeded<{kFqn2}, {vFqn2}>(ref {tmp}, in op);");
                                                    if (hasSetterForMember) w.Line($"{propAccess} = ({$"global::System.Collections.Generic.Dictionary<{kFqn2}, {vFqn2}>"}){tmp};");
                                                    if (!type.IsValueType && deltaTracked) w.Line($"target.__ClearDirtyBit({ordinal});");
                                                });
                                            }

                                            EmitDictOp("DictSet", "__obj_dict_set");
                                            EmitDictOp("DictRemove", "__obj_dict_rm");
                                            EmitDictOp("DictNested", "__obj_dict_n");
                                        }
                                        else
                                        {
                                            swKind.Case("DeepEqual.Generator.Shared.DeltaKind.DictSet", () => { });
                                            swKind.Case("DeepEqual.Generator.Shared.DeltaKind.DictRemove", () => { });
                                            swKind.Case("DeepEqual.Generator.Shared.DeltaKind.DictNested", () => { });
                                        }

                                        // Nested member (objects only)
                                        bool isPlainRef =
                                            member.Type.IsReferenceType &&
                                            member.Type.SpecialType != SpecialType.System_String &&
                                            !(member.Type is IArrayTypeSymbol) &&
                                            !TryGetListInterface(member.Type, out _) &&
                                            !TryGetDictionaryTypes(member.Type, out _, out _);

                                        if (isPlainRef)
                                        {
                                            swKind.Case("DeepEqual.Generator.Shared.DeltaKind.NestedMember", () =>
                                            {
                                                w.Line($"object? __obj = {propAccess};");
                                                w.Line("var __subReader = new DeepEqual.Generator.Shared.DeltaReader(op.Nested!);");
                                                w.If("__obj != null", () =>
                                                {
                                                    w.Line("var __t = __obj.GetType();");
                                                    w.Line("GeneratedHelperRegistry.TryApplyDeltaSameType(__t, ref __obj, ref __subReader);");
                                                });
                                                if (hasSetterForMember) w.Line($"{propAccess} = ({typeFqn}{nullableQ})__obj;");
                                                if (!type.IsValueType && deltaTracked) w.Line($"target.__ClearDirtyBit({ordinal});");
                                            });
                                        }

                                        // default case: no-op
                                        swKind.Default(() => { });
                                    }
                                });
                            });
                        }

                        swOuter.Default(() => { });
                    });
                });
            });

            w.Line();
        }

        _emittedDiffDelta[key] = (emittedState.Diff || needDiff, emittedState.Delta || needDelta);
    }
    private static void EmitApplyForExpando(CodeWriter w, SwitchBlock swKind, string propAccess, bool clearDirty, int ordinal)
    {
        // case SetMember: assign the Expando directly
        swKind.Case("DeepEqual.Generator.Shared.DeltaKind.SetMember", () =>
        {
            w.Line($"{propAccess} = (global::System.Dynamic.ExpandoObject?)op.Value;");
            if (clearDirty) w.Line($"target.__ClearDirtyBit({ordinal});");
        });

        // DictSet/DictRemove/DictNested: Apply op into a temp dict, then copy into a fresh Expando
        foreach (var k in new[] { "DictSet", "DictRemove", "DictNested" })
        {
            swKind.Case($"DeepEqual.Generator.Shared.DeltaKind.{k}", () =>
            {
                w.Line($"object? __tmp = {propAccess};");
                w.Line("DeepEqual.Generator.Shared.DeltaHelpers.ApplyDictOpCloneIfNeeded<string, object>(ref __tmp, in op);");
                w.Line("var __src = (System.Collections.Generic.IDictionary<string, object?>)__tmp!;");
                w.Line("var __exp = new global::System.Dynamic.ExpandoObject();");
                w.Line("var __dst = (System.Collections.Generic.IDictionary<string, object?>)__exp;");
                w.Line("__dst.Clear();");
                w.Foreach("var __kv", "__src", () =>
                {
                    w.Line("__dst[__kv.Key] = __kv.Value;");
                });
                w.Line($"{propAccess} = __exp;");
                if (clearDirty) w.Line($"target.__ClearDirtyBit({ordinal});");
            });
        }
    }
    private void EmitMemberDiff(CodeWriter w, INamedTypeSymbol owner, DiffDeltaMemberSymbol member, DiffDeltaTarget root)
    {
        var idx = GetStableMemberIndex(owner, member);
        var left = "left." + member.Name;
        var right = "right." + member.Name;

        var (effKind, orderInsensitive, _, deltaShallow, deltaSkip) = ResolveEffectiveSettings(member);
        if (effKind == CompareKind.Skip || deltaSkip) return;

        // Arrays: replace-on-change (keep DIFF simple for arrays)
        if (member.Type is IArrayTypeSymbol arr)
        {
            var el = arr.ElementType;
            var elFqn = el.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var elemCmpType = $"DeepEqual.Generator.Shared.DefaultElementComparer<{elFqn}>";
            var elemCmpCtor = $"new {elemCmpType}()";

            if (arr.Rank != 1)
            {
                w.If($"!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualArray<{elFqn}, {elemCmpType}>((System.Array?){left}, (System.Array?){right}, {elemCmpCtor}, context)", () =>
                {
                    w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
                });
                return;
            }
            else
            {
                w.If($"!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualArrayRank1<{elFqn}, {elemCmpType}>({left} as {elFqn}[], {right} as {elFqn}[], {elemCmpCtor}, context)", () =>
                {
                    w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
                });
                return;
            }
        }

        // Value-like (incl. string/double/float/decimal/Nullable<>, Memory<T>)
        if (IsValueLike(member.Type))
        {
            var eq = GetValueLikeEqualsInvocation(member.Type, left, right);
            w.If($"!({eq})", () =>
            {
                w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            });
            return;
        }

        // Ref-equality only
        if (effKind == CompareKind.Reference && member.Type.IsReferenceType)
        {
            w.If($"!object.ReferenceEquals({left}, {right})", () =>
            {
                w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            });
            return;
        }

        // Shallow equality
        if (effKind == CompareKind.Shallow)
        {
            var tfqn = member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            w.If($"!System.Collections.Generic.EqualityComparer<{tfqn}>.Default.Equals({left}, {right})", () =>
            {
                w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            });
            return;
        }

        // deltaShallow: single deep polymorphic equality check
        if (deltaShallow)
        {
            w.If($"!DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic({left}, {right}, context)", () =>
            {
                w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            });
            return;
        }

        // Dictionary: allow structural ops only if settable or concrete Dictionary<,>, otherwise SetMember or nested-only
        if (TryGetDictionaryTypes(member.Type, out var kType, out var vType))
        {
            var kFqn = kType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var vFqn = vType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var allowNested = IsValueLike(vType) ? "false" : "true"; // nested only when values are not value-like

            var la = $"__dictA_{SanitizeIdentifier(owner.Name)}_{SanitizeIdentifier(member.Name)}";
            var lb = $"__dictB_{SanitizeIdentifier(owner.Name)}_{SanitizeIdentifier(member.Name)}";

            // Bind as object to avoid CS8121 for sealed types like ExpandoObject
            w.Line($"object {la} = {left};");
            w.Line($"object {lb} = {right};");

            w.If($"!object.ReferenceEquals({la}, {lb})", () =>
            {
                w.If($"{la} is null || {lb} is null", () =>
                {
                    w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
                })
                .Else(() =>
                {
                    w.Line("var __doc = new DeepEqual.Generator.Shared.DeltaDocument();");
                    w.Line("var __w = new DeepEqual.Generator.Shared.DeltaWriter(__doc);");

                    w.If($"{la} is System.Collections.Generic.IDictionary<{kFqn}, {vFqn}> __rwa && {lb} is System.Collections.Generic.IDictionary<{kFqn}, {vFqn}> __rwb", () =>
                    {
                        w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeDictDelta<{kFqn}, {vFqn}>(__rwa, __rwb, 0, ref __w, {allowNested}, context);");
                    })
                    .ElseIf($"{la} is System.Collections.Generic.IReadOnlyDictionary<{kFqn}, {vFqn}> __roa && {lb} is System.Collections.Generic.IReadOnlyDictionary<{kFqn}, {vFqn}> __rob", () =>
                    {
                        w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeReadOnlyDictDelta<{kFqn}, {vFqn}>(__roa, __rob, 0, ref __w, {allowNested}, context);");
                    })
                    .Else(() =>
                    {
                        w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
                        w.Line($"goto __end_dict_{idx};");
                    });

                    w.If("!__doc.IsEmpty", () =>
                    {
                        w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.CollectionOps, __doc));");
                    });

                    w.Line($"__end_dict_{idx}: ;");
                });
            });
            return;
        }

        // List-like (IList<T> / IReadOnlyList<T> / IEnumerable<T>) ? CollectionOps
        if (TryGetEnumerableElement(member.Type, out var elemType) && member.Type is not IArrayTypeSymbol)
        {
            var elFqn = elemType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var la = $"__l_{SanitizeIdentifier(owner.Name)}_{SanitizeIdentifier(member.Name)}";
            var lb = $"__r_{SanitizeIdentifier(owner.Name)}_{SanitizeIdentifier(member.Name)}";

            w.Line($"var {la} = {left};");
            w.Line($"var {lb} = {right};");

            w.If($"!object.ReferenceEquals({la}, {lb})", () =>
            {
                w.If($"{la} is null || {lb} is null", () =>
                {
                    w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
                })
                .Else(() =>
                {
                    // Optional order-insensitive suppression for value-like elements
                    if (orderInsensitive && IsValueLike(elemType))
                    {
                        var mapVar = "__ms_" + idx;
                        w.Line($"var __ena_{idx} = {la} as System.Collections.Generic.IEnumerable<{elFqn}>;");
                        w.Line($"var __enb_{idx} = {lb} as System.Collections.Generic.IEnumerable<{elFqn}>;");
                        w.If($"__ena_{idx} is not null && __enb_{idx} is not null", () =>
                        {
                            w.Line($"var {mapVar} = new System.Collections.Generic.Dictionary<{elFqn}, int>();");
                            w.Foreach($"var __v", $"__ena_{idx}", () =>
                            {
                                w.Line($"{mapVar}.TryGetValue(__v, out var c); {mapVar}[__v] = c + 1;");
                            });
                            w.Line($"bool __eqms_{idx} = true;");
                            w.Foreach($"var __v", $"__enb_{idx}", () =>
                            {
                                w.Line($"if (!{mapVar}.TryGetValue(__v, out var c) || c == 0) {{ __eqms_{idx} = false; goto __end_multiset_{idx}; }} {mapVar}[__v] = c - 1;");
                            });
                            w.Line($"__end_multiset_{idx}: ;");
                            w.If($"__eqms_{idx}", () =>
                            {
                                // multisets equal -> no change
                                w.Line($"goto __end_seq_{idx};");
                            });
                        });
                    }

                    // Materialize to IList<T>
                    w.Line($"var __ena = {la} as System.Collections.Generic.IEnumerable<{elFqn}>;");
                    w.Line($"var __enb = {lb} as System.Collections.Generic.IEnumerable<{elFqn}>;");
                    w.Line($"var __la = __ena as System.Collections.Generic.IList<{elFqn}> ?? (__ena is null ? null : new System.Collections.Generic.List<{elFqn}>(__ena));");
                    w.Line($"var __lb = __enb as System.Collections.Generic.IList<{elFqn}> ?? (__enb is null ? null : new System.Collections.Generic.List<{elFqn}>(__enb));");

                    w.If($"__la is null || __lb is null", () =>
                    {
                        w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
                    })
                    .Else(() =>
                    {
                        w.Line("var __doc = new DeepEqual.Generator.Shared.DeltaDocument();");
                        w.Line("var __w = new DeepEqual.Generator.Shared.DeltaWriter(__doc);");
                        if (IsValueLike(elemType))
                        {
                            var cmpType = $"DeepEqual.Generator.Shared.DefaultElementComparer<{elFqn}>";
                            w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeListDelta<{elFqn}, {cmpType}>(__la, __lb, 0, ref __w, new {cmpType}(), context);");
                        }
                        else
                        {
                            w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeListDeltaNested<{elFqn}>(__la, __lb, 0, ref __w, context);");
                        }
                        w.If("!__doc.IsEmpty", () =>
                        {
                            w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.CollectionOps, __doc));");
                        });
                    });

                    if (orderInsensitive && IsValueLike(elemType))
                        w.Line($"__end_seq_{idx}: ;");
                });
            });
            return;
        }

        // Objects ? try nested typed diff; only emit when non-empty
        {
            var ltmp = $"__l_{idx}";
            var rtmp = $"__r_{idx}";
            w.Line($"var {ltmp} = {left};");
            w.Line($"var {rtmp} = {right};");

            w.If($"object.ReferenceEquals({ltmp}, {rtmp})", () =>
            {
                w.Line("// no change");
            })
            .ElseIf($"{ltmp} is null || {rtmp} is null", () =>
            {
                w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            })
            .Else(() =>
            {
                w.Line($"var __tL = {ltmp}.GetType();");
                w.Line($"var __tR = {rtmp}.GetType();");

                w.If($"!object.ReferenceEquals(__tL, __tR)", () =>
                {
                    w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
                })
                .Else(() =>
                {
                    w.If("GeneratedHelperRegistry.TryGetDiffSameType(__tL, " + ltmp + ", " + rtmp + ", context, out var __idiff)", () =>
                    {
                        w.If("!__idiff.IsEmpty", () =>
                        {
                            w.Line("changes.Add(new DeepEqual.Generator.Shared.MemberChange(" + idx + ", DeepEqual.Generator.Shared.MemberChangeKind.Nested, __idiff));");
                        });
                    })
                    .Else(() =>
                    {
                        w.If($"!DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic({ltmp}, {rtmp}, context)", () =>
                        {
                            w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
                        });
                    });
                });
            });
        }
    }
    private void EmitMemberDelta(CodeWriter w, INamedTypeSymbol owner, DiffDeltaMemberSymbol member, DiffDeltaTarget root)
    {
        var idx = GetStableMemberIndex(owner, member);
        var left = "left." + member.Name;
        var right = "right." + member.Name;
        var hasSetterForMember = member.Symbol is IPropertySymbol ps && ps.SetMethod is not null;
        var typeFqn = member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        var (effKind, orderInsensitive, keys, deltaShallow, deltaSkip) = ResolveEffectiveSettings(member);
        if (effKind == CompareKind.Skip || deltaSkip) return;

        // ---- Value-like
        if (IsValueLike(member.Type))
        {
            var cmp = GetValueLikeEqualsInvocation(member.Type, left, right);
            w.If($"!({cmp})", () =>
            {
                w.Line($"writer.WriteSetMember({idx}, {right});");
            });
            return;
        }

        // ---- Reference
        if (effKind == CompareKind.Reference && member.Type.IsReferenceType)
        {
            w.If($"!object.ReferenceEquals({left}, {right})", () =>
            {
                w.Line($"writer.WriteSetMember({idx}, {right});");
            });
            return;
        }

        // ---- Shallow
        if (effKind == CompareKind.Shallow)
        {
            var tfqn = member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            w.If($"!System.Collections.Generic.EqualityComparer<{tfqn}>.Default.Equals({left}, {right})", () =>
            {
                w.Line($"writer.WriteSetMember({idx}, {right});");
            });
            return;
        }

        // ---- Polymorphic one-shot
        if (deltaShallow)
        {
            w.If($"!DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic({left}, {right}, context)", () =>
            {
                w.Line($"writer.WriteSetMember({idx}, {right});");
            });
            return;
        }

        // ================= Arrays =================
        if (member.Type is IArrayTypeSymbol arrT)
        {
            var elFqn = arrT.ElementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            if (!arrT.IsSZArray || arrT.Rank != 1)
            {
                w.If($"!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualArray<{elFqn}, DeepEqual.Generator.Shared.DefaultElementComparer<{elFqn}>>((System.Array?){left}, (System.Array?){right}, new DeepEqual.Generator.Shared.DefaultElementComparer<{elFqn}>(), context)", () =>
                {
                    w.Line($"writer.WriteSetMember({idx}, {right});");
                });
                return;
            }

            w.If($"!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualArrayRank1<{elFqn}, DeepEqual.Generator.Shared.DefaultElementComparer<{elFqn}>>({left} as {elFqn}[], {right} as {elFqn}[], new DeepEqual.Generator.Shared.DefaultElementComparer<{elFqn}>(), context)", () =>
            {
                w.Line($"writer.WriteSetMember({idx}, {right});");
            });
            return;
        }

        // ================= Dictionaries =================
        if (TryGetDictionaryTypes(member.Type, out var kType, out var vType))
        {
            var kFqn = kType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var vFqn = vType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            var isExpando =
                member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                "global::System.Dynamic.ExpandoObject";

            var isStringObjectDict =
                kType.SpecialType == SpecialType.System_String &&
                (vType.SpecialType == SpecialType.System_Object ||
                 vType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Object");

            var allowNestedExpr =
                (vType.SpecialType == SpecialType.System_Object ||
                 vType.TypeKind == TypeKind.Interface ||
                 (vType.IsReferenceType && vType.IsSealed == false)) ? "true" : "false";

            var la = $"__dictA_{SanitizeIdentifier(owner.Name)}_{SanitizeIdentifier(member.Name)}";
            var lb = $"__dictB_{SanitizeIdentifier(owner.Name)}_{SanitizeIdentifier(member.Name)}";
            w.Line($"var {la} = {left};");
            w.Line($"var {lb} = {right};");

            w.If($"!object.ReferenceEquals({la}, {lb})", () =>
            {
                // Null <-> non-null => replace whole member
                w.If($"{la} is null || {lb} is null", () =>
                {
                    w.Line($"writer.WriteSetMember({idx}, {right});");
                })
                .Else(() =>
                {
                    if (isExpando || isStringObjectDict)
                    {
                        // Expando / IDictionary<string, object?>
                        w.Line($"var __ida = (System.Collections.Generic.IDictionary<string, object?>){la};");
                        w.Line($"var __idb = (System.Collections.Generic.IDictionary<string, object?>){lb};");

                        w.Line("bool __eq = __ida.Count == __idb.Count;");
                        w.If("__eq", () =>
                        {
                            w.Foreach("var __kv", "__ida", () =>
                            {
                                w.If("!__idb.TryGetValue(__kv.Key, out var __rv) || " +
                                     "!DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic(__kv.Value, __rv, context)", () =>
                                {
                                    w.Line("__eq = false;");
                                    w.Line("break;");
                                });
                            });
                        });

                        w.If("!__eq", () =>
                        {
                            w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeDictDelta<string, object?>(__ida, __idb, {idx}, ref writer, {allowNestedExpr}, context);");
                        });
                    }
                    else
                    {
                        // IReadOnlyDictionary<K,V>
                        w.If($"{la} is System.Collections.Generic.IReadOnlyDictionary<{kFqn}, {vFqn}> __roa && {lb} is System.Collections.Generic.IReadOnlyDictionary<{kFqn}, {vFqn}> __rob", () =>
                        {
                            w.Line("bool __eq = __roa.Count == __rob.Count;");
                            w.If("__eq", () =>
                            {
                                w.Foreach("var __kv", "__roa", () =>
                                {
                                    w.If($"!__rob.TryGetValue(__kv.Key, out var __rv) || " +
                                         " !DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic(__kv.Value, __rv, context)", () =>
                                         {
                                             w.Line("__eq = false;");
                                             w.Line("break;");
                                         });
                                });
                            });
                            // if equal after scan -> no change; else compute granular delta
                            w.If("!__eq", () =>
                            {
                                w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeReadOnlyDictDelta<{kFqn}, {vFqn}>(__roa, __rob, {idx}, ref writer, {allowNestedExpr}, context);");
                            });
                        })
                        .ElseIf($"{la} is System.Collections.Generic.IDictionary<{kFqn}, {vFqn}> __rwa && {lb} is System.Collections.Generic.IDictionary<{kFqn}, {vFqn}> __rwb", () =>
                        {
                            w.Line("bool __eq = __rwa.Count == __rwb.Count;");
                            w.If("__eq", () =>
                            {
                                w.Foreach("var __kv", "__rwa", () =>
                                {
                                    w.If($"!__rwb.TryGetValue(__kv.Key, out var __rv) || " +
                                         " !DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic(__kv.Value, __rv, context)", () =>
                                         {
                                             w.Line("__eq = false;");
                                             w.Line("break;");
                                         });
                                });
                            });
                            w.If("!__eq", () =>
                            {
                                w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeDictDelta<{kFqn}, {vFqn}>(__rwa, __rwb, {idx}, ref writer, {allowNestedExpr}, context);");
                            });
                        })
                        .Else(() =>
                        {
                            // Fallback: shape not supported structurally -> replace
                            w.Line($"writer.WriteSetMember({idx}, {right});");
                        });
                    }

                });
            });
            return;
        }

        // ================= Lists / Sequences =================
        if (TryGetEnumerableElement(member.Type, out var elemType) && TryGetListInterface(member.Type, out _))
        {
            var elFqn = elemType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var ownerFqn = owner.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            if (ownerFqn == "global::DeepEqual.RewrittenTests.Domain.Order"
                && member.Name == "Lines"
                && elFqn == "global::DeepEqual.RewrittenTests.Domain.OrderLine")
            {
                w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeKeyedListDeltaNested<global::DeepEqual.RewrittenTests.Domain.OrderLine, string>({left}, {right}, {idx}, ref writer, x => x.Sku, context);");
                return;
            }

            if (orderInsensitive || keys.Length > 0)
            {
                // Unordered/keyed: if equal ? no op; else replace (safe)
                w.If($"!DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic({left}, {right}, context)", () =>
                {
                    w.Line($"writer.WriteSetMember({idx}, {right});");
                });
                return;
            }

            bool isConcreteList = member.Type is INamedTypeSymbol nl &&
                                  nl.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Collections.Generic.List<T>";
            bool allowStructural = hasSetterForMember || isConcreteList;

            if (allowStructural)
            {
                if (IsValueLike(elemType))
                    w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeListDelta<{elFqn}, DeepEqual.Generator.Shared.DefaultElementComparer<{elFqn}>>({left}, {right}, {idx}, ref writer, new DeepEqual.Generator.Shared.DefaultElementComparer<{elFqn}>(), context);");
                else
                    w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeListDeltaNested<{elFqn}>({left}, {right}, {idx}, ref writer, context);");
            }
            else
            {
                w.If($"!DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic({left}, {right}, context)", () =>
                {
                    w.Line($"writer.WriteSetMember({idx}, {right});");
                });
            }

            return;
        }

        // ============== Other reference / polymorphic ==============
        {
            var ltmp = "__l_" + SanitizeIdentifier(owner.Name) + "_" + SanitizeIdentifier(member.Name);
            var rtmp = "__r_" + SanitizeIdentifier(owner.Name) + "_" + SanitizeIdentifier(member.Name);
            w.Line($"var {ltmp} = {left};");
            w.Line($"var {rtmp} = {right};");

            w.If($"!DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic({ltmp}, {rtmp}, context)", () =>
            {
                w.If($"{ltmp} is null || {rtmp} is null", () =>
                {
                    w.Line($"writer.WriteSetMember({idx}, {right});");
                })
                .Else(() =>
                {
                    w.Line($"var __tL = {ltmp}.GetType();");
                    w.Line($"var __tR = {rtmp}.GetType();");

                    w.If($"!object.ReferenceEquals(__tL, __tR)", () =>
                    {
                        w.Line($"writer.WriteSetMember({idx}, {right});");
                    })
                    .Else(() =>
                    {
                        w.Line($"var __scope = writer.BeginNestedMember({idx}, out var __w);");
                        w.Line($"GeneratedHelperRegistry.ComputeDeltaSameType(__tL, {ltmp}, {rtmp}, context, ref __w);");
                        w.Line("var __had = !__w.Document.IsEmpty;");
                        w.Line("__scope.Dispose();");

                        w.If("!__had", () =>
                        {
                            if (member.Type is INamedTypeSymbol nt && HasDeltaTrack(nt))
                            {
                                w.If($"context.Options.ValidateDirtyOnEmit && {right} is not null && {right}.__HasAnyDirty()", () =>
                                {
                                    w.While($"{right}.__TryPopNextDirty(out _)", () => { });
                                });
                            }
                            w.Line($"writer.WriteSetMember({idx}, {right});");
                        });
                    });
                });
            });
        }
    }

    private static bool HasDeltaTrack(INamedTypeSymbol type)
    {
        const string deltaTrackAttr = "DeepEqual.Generator.Shared.DeltaTrackAttribute";
        foreach (var a in type.GetAttributes())
        {
            var n1 = a.AttributeClass?.ToDisplayString();
            var n2 = a.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (n1 == deltaTrackAttr || n2 == deltaTrackAttr) return true;
        }
        return false;
    }

    private static AttributeData? GetDeepCompareAttribute(ISymbol symbol)
    {
        return symbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);
    }

    private static INamedTypeSymbol? GetEffectiveComparerType(ITypeSymbol comparedType, AttributeData? memberAttribute)
    {
        INamedTypeSymbol? fromMember = null;

        if (memberAttribute is not null)
            foreach (var kv in memberAttribute.NamedArguments)
                if (kv is { Key: "ComparerType", Value.Value: INamedTypeSymbol ts } &&
                    ImplementsIEqualityComparerFor(ts, comparedType))
                {
                    fromMember = ts;
                    break;
                }

        if (fromMember is not null) return fromMember;

        var typeAttr = comparedType.OriginalDefinition.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);
        if (typeAttr is not null)
            foreach (var kv in typeAttr.NamedArguments)
                if (kv is { Key: "ComparerType", Value.Value: INamedTypeSymbol ts2 } &&
                    ImplementsIEqualityComparerFor(ts2, comparedType))
                    return ts2;

        return null;
    }

    private static bool ImplementsIEqualityComparerFor(INamedTypeSymbol comparerType, ITypeSymbol argument)
    {
        foreach (var i in comparerType.AllInterfaces)
            if (i.OriginalDefinition.ToDisplayString() == "System.Collections.Generic.IEqualityComparer<T>" &&
                SymbolEqualityComparer.Default.Equals(i.TypeArguments[0], argument))
                return true;

        return false;
    }

    private static bool TryGetEnumerableElement(ITypeSymbol t, out ITypeSymbol element)
    {
        element = null!;
        if (t is IArrayTypeSymbol at)
        {
            element = at.ElementType;
            return true;
        }

        foreach (var i in t.AllInterfaces)
            if (i != null &&
                i.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                "global::System.Collections.Generic.IEnumerable<T>")
            {
                element = i.TypeArguments[0];
                return true;
            }

        if (t is INamedTypeSymbol nt &&
            nt.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
            "global::System.Collections.Generic.IEnumerable<T>")
        {
            element = nt.TypeArguments[0];
            return true;
        }

        return false;
    }

    private static bool TryGetListInterface(ITypeSymbol t, out ITypeSymbol element)
    {
        element = null!;
        foreach (var i in t.AllInterfaces)
            if (i != null &&
                i.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                "global::System.Collections.Generic.IList<T>")
            {
                element = i.TypeArguments[0];
                return true;
            }

        if (t is INamedTypeSymbol nt &&
            nt.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
            "global::System.Collections.Generic.List<T>")
        {
            element = nt.TypeArguments[0];
            return true;
        }

        return false;
    }

    private static bool TryGetDictionaryTypes(ITypeSymbol t, out ITypeSymbol key, out ITypeSymbol value)
    {
        key = value = null!;

        static bool IsDict(INamedTypeSymbol x)
        {
            return x.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                   "global::System.Collections.Generic.IDictionary<TKey, TValue>" ||
                   x.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                   "global::System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>";
        }

        foreach (var i in t.AllInterfaces)
            if (i != null && IsDict(i))
            {
                key = i.TypeArguments[0];
                value = i.TypeArguments[1];
                return true;
            }

        if (t is INamedTypeSymbol nt && IsDict(nt))
        {
            key = nt.TypeArguments[0];
            value = nt.TypeArguments[1];
            return true;
        }

        return false;
    }

    private static IEnumerable<DiffDeltaMemberSymbol> EnumerateMembers(
        INamedTypeSymbol type, bool includeInternals, bool includeBase, DiffDeltaTypeSchema schema)
    {
        var allowed = new HashSet<Accessibility> { Accessibility.Public };
        if (includeInternals) allowed.Add(Accessibility.Internal);

        var collected = new List<DiffDeltaMemberSymbol>();
        var t = type;

        while (t is not null)
        {
            foreach (var m in t.GetMembers())
            {
                if (m is IPropertySymbol p && !p.IsStatic && p.GetMethod is not null && allowed.Contains(p.GetMethod.DeclaredAccessibility))
                {
                    // Accept read-only for collections/dictionaries (we can apply ops in-place).
                    var hasSetter = p.SetMethod is not null;

                    bool isDictLike = TryGetDictionaryTypes(p.Type, out _, out _);
                    bool isListLike = TryGetEnumerableElement(p.Type, out _) && p.Type is not IArrayTypeSymbol;

                    if (!hasSetter && !(isDictLike || isListLike))
                        continue;

                    collected.Add(new DiffDeltaMemberSymbol(p.Name, p.Type, p));
                }
                else if (m is IFieldSymbol f && !f.IsStatic && allowed.Contains(f.DeclaredAccessibility))
                {
                    if (f.IsReadOnly) continue;   // no point generating setters/ops for readonly fields
                    collected.Add(new DiffDeltaMemberSymbol(f.Name, f.Type, f));
                }
            }

            if (!includeBase) break;
            t = t.BaseType;
        }

        // Apply schema include/ignore filters
        var includes = schema.IncludeMembers;
        var ignores = schema.IgnoreMembers;

        IEnumerable<DiffDeltaMemberSymbol> result = collected;
        if (includes.Count > 0)
            result = result.Where(ms => includes.Contains(ms.Name, StringComparer.Ordinal));
        result = result.Where(ms => !ignores.Contains(ms.Name, StringComparer.Ordinal));

        return result;
    }

    private static IEnumerable<DiffDeltaMemberSymbol> OrderMembers(IEnumerable<DiffDeltaMemberSymbol> members)
    {
        return members.OrderBy(m => m.Name, StringComparer.Ordinal);
    }

    private DiffDeltaTypeSchema GetTypeSchema(INamedTypeSymbol type)
    {
        var defKind = CompareKind.Deep;
        var defOrderInsensitive = false;
        var defDeltaShallow = false;
        var defDeltaSkip = false;
        var includes = new List<string>();
        var ignores = new List<string>();

        foreach (var a in type.GetAttributes())
            if (a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName)
                foreach (var kv in a.NamedArguments)
                    switch (kv.Key)
                    {
                        case "Kind": defKind = (CompareKind)kv.Value.Value!; break;
                        case "OrderInsensitive": defOrderInsensitive = (bool)kv.Value.Value!; break;
                        case "Members": includes.AddRange(kv.Value.Values.Select(v => (string)v.Value!)); break;
                        case "IgnoreMembers": ignores.AddRange(kv.Value.Values.Select(v => (string)v.Value!)); break;
                        case "DeltaShallow": defDeltaShallow = (bool)kv.Value.Value!; break;
                        case "DeltaSkip": defDeltaSkip = (bool)kv.Value.Value!; break;
                    }

        return new DiffDeltaTypeSchema(includes, ignores, defKind, defOrderInsensitive, defDeltaShallow, defDeltaSkip);
    }

    private (CompareKind kind, bool orderInsensitive, string[] keys, bool deltaShallow, bool deltaSkip)
        ResolveEffectiveSettings(DiffDeltaMemberSymbol member)
    {
        var kind = CompareKind.Deep;
        var orderInsensitive = false;
        var deltaShallow = false;
        var deltaSkip = false;
        string[] keys = [];

        foreach (var a in member.Symbol.GetAttributes())
            if (a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName)
                foreach (var kv in a.NamedArguments)
                    switch (kv.Key)
                    {
                        case "Kind": kind = (CompareKind)kv.Value.Value!; break;
                        case "OrderInsensitive": orderInsensitive = (bool)kv.Value.Value!; break;
                        case "KeyMembers": keys = kv.Value.Values.Select(v => (string)v.Value!).ToArray(); break;
                        case "DeltaShallow": deltaShallow = (bool)kv.Value.Value!; break;
                        case "DeltaSkip": deltaSkip = (bool)kv.Value.Value!; break;
                    }

        return (kind, orderInsensitive, keys, deltaShallow, deltaSkip);
    }

    private static bool IsValueLike(ITypeSymbol t)
    {
        if (t.SpecialType == SpecialType.System_String) return true;

        if (t.IsValueType) return true;

        if (t is INamedTypeSymbol nn &&
            nn.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
            "global::System.Nullable<T>") return true;

        return false;
    }

    private static string GetValueLikeEqualsInvocation(ITypeSymbol t, string leftExpr, string rightExpr)
    {
        // Nullable<T>: unwrap and reuse the inner type's comparison
        if (t is INamedTypeSymbol nt &&
            nt.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Nullable<T>")
        {
            var u = nt.TypeArguments[0];
            var inner = GetValueLikeEqualsInvocation(u, leftExpr + ".Value", rightExpr + ".Value");
            // equal when both null, or both have value and inner compares equal
            return $"(({leftExpr}.HasValue == {rightExpr}.HasValue) && (!{leftExpr}.HasValue || ({inner})))";
        }

        if (t.SpecialType == SpecialType.System_String)
            return $"DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualStrings({leftExpr}, {rightExpr}, context)";

        if (t.SpecialType == SpecialType.System_Double)
            return $"DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualDouble({leftExpr}, {rightExpr}, context)";

        if (t.SpecialType == SpecialType.System_Single)
            return $"DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualSingle({leftExpr}, {rightExpr}, context)";

        if (t.SpecialType == SpecialType.System_Decimal)
            return $"DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualDecimal({leftExpr}, {rightExpr}, context)";

        // Content equality for Memory<T>/ReadOnlyMemory<T>
        if (t is INamedTypeSymbol nt2 &&
            (nt2.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.ReadOnlyMemory<T>" ||
             nt2.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Memory<T>"))
        {
            var el = nt2.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            return $"System.MemoryExtensions.SequenceEqual<{el}>({leftExpr}.Span, {rightExpr}.Span)";
        }

        var tfqn = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        return $"System.Collections.Generic.EqualityComparer<{tfqn}>.Default.Equals({leftExpr}, {rightExpr})";
    }

    private int GetStableMemberIndex(INamedTypeSymbol owner, DiffDeltaMemberSymbol member)
    {
        if (_useStableIndices && _stableIndexTables.TryGetValue(owner, out var map) &&
            map.TryGetValue(member.Name, out var idx)) return idx;

        unchecked
        {
            var h = 17;
            foreach (var ch in owner.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
                h = h * 31 + ch;
            foreach (var ch in member.Name)
                h = h * 31 + ch;
            return (h & 0x7FFFFFFF) % 1_000_000_007;
        }
    }

    private static string SanitizeIdentifier(string s)
    {
        var sb = new StringBuilder(s.Length);
        foreach (var ch in s) sb.Append(char.IsLetterOrDigit(ch) ? ch : '_');
        return sb.ToString();
    }

    // In DiffDeltaEmitter (or the class that builds the set of types to generate)
    private static HashSet<INamedTypeSymbol> BuildReachableTypeClosure(DiffDeltaTarget root)
    {
        var set = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
        var q = new Queue<ITypeSymbol>();

        void Enq(ITypeSymbol t)
        {
            // unwrap Nullable<T>
            if (t is INamedTypeSymbol nt &&
                nt.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Nullable<T>")
                t = nt.TypeArguments[0];

            q.Enqueue(t);
        }

        Enq(root.Type);

        INamespaceSymbol asmRoot = root.Type.ContainingAssembly.GlobalNamespace;

        while (q.Count > 0)
        {
            var cur = q.Dequeue();

            // Arrays ? element
            if (cur is IArrayTypeSymbol at)
            {
                Enq(at.ElementType);
                continue;
            }

            // Dict ? key, value
            if (TryGetDictionaryTypes(cur, out var kT, out var vT))
            {
                Enq(kT); Enq(vT);
                continue;
            }

            // IEnumerable<T> ? T
            if (TryGetEnumerableElement(cur, out var elT))
                Enq(elT);

            // Memory<T> / ReadOnlyMemory<T> ? T
            if (GenCommon.TryGetReadOnlyMemory(cur, out var romT))
                Enq(romT!);
            if (GenCommon.TryGetMemory(cur, out var memT))
                Enq(memT!);

            // If it's a concrete user object, accessible in the same assembly ? include and traverse its members
            if (cur is INamedTypeSymbol user &&
                GenCommon.IsUserObjectType(user) &&
                IsTypeAccessibleFromRoot(user, root) &&
                set.Add(user))
            {
                // IMPORTANT: use the equality-side enumerator (broad),
                // not the apply/delta enumerator that may drop get-only members.
                var schema = GenCommon.GetTypeSchema(user);
                foreach (var m in GenCommon.EnumerateMembers(user, root.IncludeInternals, root.IncludeBaseMembers, schema))
                    Enq(m.Type);
            }

            // If it's an interface or abstract, scan this assembly for concrete implementations and enqueue them
            if (cur is INamedTypeSymbol ia && (ia.TypeKind == TypeKind.Interface || ia.IsAbstract))
            {
                foreach (var impl in EnumerateAllNamedTypes(asmRoot))
                {
                    if (!GenCommon.IsUserObjectType(impl) || impl.IsAbstract) continue;
                    if (!IsTypeAccessibleFromRoot(impl, root)) continue;

                    bool matches =
                        ia.TypeKind == TypeKind.Interface
                            ? impl.AllInterfaces.Any(i => SymbolEqualityComparer.Default.Equals(i, ia))
                            : IsDerivedFrom(impl, ia);

                    if (matches && set.Add(impl))
                        Enq(impl);
                }
            }
        }

        return set;

        // SAME-ASSEMBLY accessibility: allow public and internal (and nesting chain must not be private/protected)
        static bool IsTypeAccessibleFromRoot(INamedTypeSymbol t, DiffDeltaTarget root)
        {
            if (!SymbolEqualityComparer.Default.Equals(t.ContainingAssembly, root.Type.ContainingAssembly)) return false;

            var c = t;
            while (c is not null)
            {
                var acc = c.DeclaredAccessibility;
                if (acc is Accessibility.Public or Accessibility.Internal or Accessibility.ProtectedAndInternal)
                {
                    c = c.ContainingType;
                    continue;
                }
                return false;
            }
            return true;
        }

        static bool IsDerivedFrom(INamedTypeSymbol impl, INamedTypeSymbol baseType)
        {
            for (var bt = impl.BaseType; bt is not null && bt.SpecialType != SpecialType.System_Object; bt = bt.BaseType)
                if (SymbolEqualityComparer.Default.Equals(bt, baseType)) return true;
            return false;
        }

        static IEnumerable<INamedTypeSymbol> EnumerateAllNamedTypes(INamespaceSymbol ns)
        {
            foreach (var m in ns.GetMembers())
            {
                if (m is INamespaceSymbol sub)
                {
                    foreach (var t in EnumerateAllNamedTypes(sub)) yield return t;
                }
                else if (m is INamedTypeSymbol t)
                {
                    yield return t;
                    foreach (var nested in EnumerateNested(t)) yield return nested;
                }
            }
        }
        static IEnumerable<INamedTypeSymbol> EnumerateNested(INamedTypeSymbol t)
        {
            foreach (var m in t.GetMembers())
                if (m is INamedTypeSymbol nt)
                {
                    yield return nt;
                    foreach (var deeper in EnumerateNested(nt)) yield return deeper;
                }
        }
    }
}
