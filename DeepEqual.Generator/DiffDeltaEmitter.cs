using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace DeepEqual.Generator;

internal sealed class DiffDeltaEmitter
{
    private const string DeepCompareAttributeName = GenCommon.DeepCompareAttributeMetadataName;

    private readonly Dictionary<INamedTypeSymbol, Dictionary<string, int>> _stableIndexTables =
        new(SymbolEqualityComparer.Default);
    private readonly Dictionary<string, (bool Diff, bool Delta)> _emittedDiffDelta = new(StringComparer.Ordinal);

    private bool _useStableIndices;

    public void EmitForRoot(SourceProductionContext spc, DiffDeltaTarget root, string? hintOverride = null)
    {
        Diagnostics.DiagnosticPass(spc, root.Type);

        _useStableIndices = root.GenerateDelta &&
                            (root.StableMode == StableMemberIndexMode.On ||
                             root.StableMode == StableMemberIndexMode.Auto);
        _stableIndexTables.Clear();

        var rootFqn = root.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var sanitizedId = GenCommon.SanitizeIdentifier(rootFqn);
        var hintName = hintOverride ?? GenCommon.SanitizeFileName(rootFqn + ".DeepOpsExtensions.Diff.g.cs");

        var reachable = BuildReachableTypeClosure(root);

        var w = new CodeWriter();
        w.Line("// <auto-generated/>");
        w.Line("#pragma warning disable");
        w.Line("using System;");
        w.Line("using System.Collections;");
        w.Line("using System.Collections.Generic;");
        w.Line("using DeepEqual.Generator.Shared;");
        w.Line();

        // namespace + class wrapped with lambda Open so braces are guaranteed correct
        w.Open("namespace DeepEqual", () =>
        {
            w.Open("public static partial class DeepOpsExtensions", () =>
            {
                var ensureEqualityName = "__EnsureEquality__" + sanitizedId;
                var ensureDiffName = "__EnsureDiffDelta__" + sanitizedId;
                var guardFieldName = "__ddInit__" + sanitizedId;
                var lockFieldName = "__ddLock__" + sanitizedId;
                var moduleInitName = "__ModuleInit_Diff__" + sanitizedId;

                EmitterCommon.EmitEnsureOnce(
                    w,
                    ensureDiffName,
                    guardFieldName,
                    lockFieldName,
                    writer =>
                    {
                        foreach (var t in reachable.OrderBy(t => t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), StringComparer.Ordinal))
                        {
                            var fqn = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                            var id = GenCommon.SanitizeIdentifier(fqn);
                            if (root.GenerateDiff)
                                writer.Line("GeneratedHelperRegistry.RegisterDiff<" + fqn + ">((l, r, c) => TryGetDiff__" + id + "(l, r, c));");
                            if (root.GenerateDelta)
                                writer.Line("GeneratedHelperRegistry.RegisterDelta<" + fqn + ">(ComputeDelta__" + id + ", ApplyDelta__" + id + ");");
                        }
                    },
                    ensureEqualityName + "();");

                EmitterCommon.EmitModuleInitializer(w, moduleInitName, ensureDiffName);

                EmitRootApis(w, root.Type, root.CycleTrackingEnabled, root.GenerateDiff, root.GenerateDelta, ensureDiffName);

                foreach (var t in reachable.OrderBy(t => t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                         StringComparer.Ordinal))
                {
                    EmitImplementationsForType(w, t, root);
                }
            });
        });

        var text = w.ToString();
        spc.AddSource(hintName, SourceText.From(text, Encoding.UTF8));

        if (HasDeltaTrack(root.Type))
            EmitDeltaTrackPart(spc, root.Type, root);
    }

    private static void EmitRootApis(
        CodeWriter w,
        INamedTypeSymbol rootType,
        bool cycleTrackingEnabled,
        bool generateDiff,
        bool generateDelta,
        string ensureMethodName)
    {
        var fqn = rootType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var id = GenCommon.SanitizeIdentifier(fqn);
        var nullSuffix = rootType.IsValueType ? string.Empty : "?";
        var methodTypeParameters = GenCommon.GetTypeParameterList(rootType);
        var methodConstraints = GenCommon.GetTypeConstraintClauses(rootType);
        var defaultContextExpr = "ctx ?? new DeepEqual.Generator.Shared.ComparisonContext()";

        if (generateDiff)
        {
            var diffSignature =
                "public static (bool has, DeepEqual.Generator.Shared.Diff<" + fqn + "> diff) GetDeepDiff" +
                methodTypeParameters + "(this " + fqn + nullSuffix + " left, " + fqn + nullSuffix +
                " right, DeepEqual.Generator.Shared.ComparisonContext? ctx = null)" + methodConstraints;

            w.Open(diffSignature, () =>
            {
                w.Line(ensureMethodName + "();");
                w.Line("var context = " + defaultContextExpr + ";");
                w.Line("return TryGetDiff__" + id + "(left, right, context);");
            });
            w.Line();
        }

        if (generateDelta)
        {
            w.Line("/// <summary>Computes a delta (patch) from <paramref name=\"left\"/> to <paramref name=\"right\"/>.</summary>");
            w.Line("/// <remarks>");
            w.Line("/// Collections policy:");
            w.Line("/// <list type=\"bullet\">");
            w.Line("/// <item><description><b>Arrays</b>: treated as replace-on-change. Any detected difference emits a single <c>SetMember</c> for that member.</description></item>");
            w.Line("/// <item><description><b>IList&lt;T&gt;</b>: granular sequence ops (<c>SeqReplaceAt</c>/<c>SeqAddAt</c>/<c>SeqRemoveAt</c>) are emitted.</description></item>");
            w.Line("/// <item><description><b>IDictionary</b>/<b>IReadOnlyDictionary</b>: granular key ops (<c>DictSet</c>/<c>DictRemove</c>/<c>DictNested</c>) are emitted.</description></item>");
            w.Line("/// </list>");
            w.Line("/// This mirrors <see cref=\"ApplyDeepDelta(ref " + fqn + nullSuffix + ", DeepEqual.Generator.Shared.DeltaDocument)\"/> behavior, where arrays are not patched item-by-item.</remarks>");

            var computeSignature =
                "public static DeepEqual.Generator.Shared.DeltaDocument ComputeDeepDelta" +
                methodTypeParameters + "(this " + fqn + nullSuffix + " left, " + fqn + nullSuffix +
                " right, DeepEqual.Generator.Shared.ComparisonContext? ctx = null)" + methodConstraints;

            w.Open(computeSignature, () =>
            {
                w.Line(ensureMethodName + "();");
                w.Line("var context = " + defaultContextExpr + ";");
                w.Line("var doc = new DeepEqual.Generator.Shared.DeltaDocument();");
                w.Line("var writer = new DeepEqual.Generator.Shared.DeltaWriter(doc);");
                w.Line("ComputeDelta__" + id + "(left, right, context, ref writer);");
                w.Line("return doc;");
            });
            w.Line();

            w.Line("/// <summary>Applies a previously computed delta to <paramref name=\"target\"/>.</summary>");
            w.Line("/// <remarks>");
            w.Line("/// Collections policy during application:");
            w.Line("/// <list type=\"bullet\">");
            w.Line("/// <item><description><b>Arrays</b>: always replaced as a whole when a <c>SetMember</c> op is present. Sequence ops are ignored for arrays.</description></item>");
            w.Line("/// <item><description><b>IList&lt;T&gt;</b>: sequence ops are applied in-place (replace/add/remove).</description></item>");
            w.Line("/// <item><description><b>IDictionary</b>/<b>IReadOnlyDictionary</b>: key ops are applied (set/remove) and nested deltas are applied when present.</description></item>");
            w.Line("/// </list>");
            w.Line("/// This matches the generator's policy in delta computation.</remarks>");

            if (!rootType.IsValueType)
            {
                var applyReaderSignature =
                    "public static " + fqn + nullSuffix + " ApplyDeepDelta" + methodTypeParameters +
                    "(this " + fqn + nullSuffix + " target, in DeepEqual.Generator.Shared.DeltaReader reader)" + methodConstraints;

                w.Open(applyReaderSignature, () =>
                {
                    w.Line(ensureMethodName + "();");
                    w.Line("var localReader = reader;");
                    w.Line("ApplyDelta__" + id + "(ref target, ref localReader);");
                    w.Line("return target;");
                });
                w.Line();

                var applyDocSignature =
                    "public static " + fqn + nullSuffix + " ApplyDeepDelta" + methodTypeParameters +
                    "(this " + fqn + nullSuffix + " target, DeepEqual.Generator.Shared.DeltaDocument delta)" + methodConstraints;

                w.Open(applyDocSignature, () =>
                {
                    w.Line(ensureMethodName + "();");
                    w.Line("var reader = new DeepEqual.Generator.Shared.DeltaReader(delta);");
                    w.Line("ApplyDelta__" + id + "(ref target, ref reader);");
                    w.Line("return target;");
                });
                w.Line();
            }
            else
            {
                var applyReaderSignature =
                    "public static void ApplyDeepDelta" + methodTypeParameters +
                    "(this ref " + fqn + " target, in DeepEqual.Generator.Shared.DeltaReader reader)" + methodConstraints;

                w.Open(applyReaderSignature, () =>
                {
                    w.Line(ensureMethodName + "();");
                    w.Line("var localReader = reader;");
                    w.Line("ApplyDelta__" + id + "(ref target, ref localReader);");
                });
                w.Line();

                var applyDocSignature =
                    "public static void ApplyDeepDelta" + methodTypeParameters +
                    "(this ref " + fqn + " target, DeepEqual.Generator.Shared.DeltaDocument delta)" + methodConstraints;

                w.Open(applyDocSignature, () =>
                {
                    w.Line(ensureMethodName + "();");
                    w.Line("var reader = new DeepEqual.Generator.Shared.DeltaReader(delta);");
                    w.Line("ApplyDelta__" + id + "(ref target, ref reader);");
                });
                w.Line();
            }
        }
    }

    private static bool IsExpando(ITypeSymbol t)
    {
        return t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Dynamic.ExpandoObject";
    }

    private void EmitDeltaTrackPart(SourceProductionContext spc, INamedTypeSymbol type, DiffDeltaTarget root)
    {
        // (kept logic identical; we can migrate inner regions later if you want)
        var ns = type.ContainingNamespace.IsGlobalNamespace ? null : type.ContainingNamespace.ToDisplayString();
        var fqn = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var typeParams = type.Arity > 0 ? "<" + string.Join(",", type.TypeArguments.Select(a => a.Name)) + ">" : "";
        var hint = GenCommon.SanitizeFileName(fqn + ".__DeltaTrack.g.cs");

        var threadSafe = false;
        foreach (var a in type.GetAttributes())
        {
            var full = a.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (full == "DeepEqual.Generator.Shared.DeltaTrackAttribute")
                foreach (var kv in a.NamedArguments)
                    if (kv is { Key: "ThreadSafe", Value.Value: bool b })
                        threadSafe = b;
        }

        var schema = GetTypeSchema(type);
        var members = OrderMembers(EnumerateMembers(type, root.IncludeInternals, root.IncludeBaseMembers, schema))
            .ToArray();

        var w = new CodeWriter();
        w.Line("// <auto-generated/>");
        w.Line("#pragma warning disable");
        w.Line("using System;");
        w.Line("using System.Runtime.CompilerServices;");
        w.Line("using System.Threading;");

        if (ns is not null) w.Open("namespace " + ns);

        var decl = type.DeclaredAccessibility == Accessibility.Public ? "public" : "internal";
        w.Open(decl + " partial class " + type.Name + typeParams);

        // ... (unchanged writer usage below)
        // Keeping existing Open/Close pairs here for now (they are correctly paired).
        // If you want, I can do a second pass to convert these to lambda forms as well.

        w.Line("private long __dirty0;");
        w.Line("private long[]? __dirtyEx;");
        w.Line("internal const int __DirtyWordShift = 6;");
        w.Line("internal const int __DirtyWordMask = 63;");

        if (threadSafe)
        {
            w.Open("private static long __AtomicOr(ref long location, long mask)");
            w.Line("long initial, computed;");
            w.Open("do");
            w.Line("initial = Volatile.Read(ref location);");
            w.Line("computed = initial | mask;");
            w.Close();
            w.Line("while (Interlocked.CompareExchange(ref location, computed, initial) != initial);");
            w.Line("return computed;");
            w.Close();

            w.Open("private static long __AtomicAnd(ref long location, long mask)");
            w.Line("long initial, computed;");
            w.Open("do");
            w.Line("initial = Volatile.Read(ref location);");
            w.Line("computed = initial & mask;");
            w.Close();
            w.Line("while (Interlocked.CompareExchange(ref location, computed, initial) != initial);");
            w.Line("return computed;");
            w.Close();
        }

        w.Line();
        w.Open("private static int __TrailingZeroCount(ulong value)");
        w.Open("if (value == 0)");
        w.Line("return 64;");
        w.Close();
        w.Line("int count = 0;");
        w.Open("while ((value & 1UL) == 0)");
        w.Line("count++;");
        w.Line("value >>= 1;");
        w.Close();
        w.Line("return count;");
        w.Close();
        w.Line();

        w.Open("[MethodImpl(MethodImplOptions.AggressiveInlining)] internal void __MarkDirty(int bit)");
        w.Open("if ((uint)bit <= 63)");
        if (threadSafe)
            w.Line("__AtomicOr(ref __dirty0, 1L << bit);");
        else
            w.Line("__dirty0 |= 1L << bit;");

        w.Close();
        w.Open("else");
        w.Line("var word = bit >> __DirtyWordShift;");
        w.Line("var idx = word - 1;");
        w.Line("var arr = __dirtyEx;");
        w.Open("if (arr is null || idx >= arr.Length)");
        w.Line("Array.Resize(ref __dirtyEx, arr is null ? Math.Max(1, idx + 1) : Math.Max(arr.Length * 2, idx + 1));");
        w.Close();
        if (threadSafe)
            w.Line("__AtomicOr(ref __dirtyEx![idx], 1L << (bit & __DirtyWordMask));");
        else
            w.Line("__dirtyEx![idx] |= 1L << (bit & __DirtyWordMask);");

        w.Close();
        w.Close();
        w.Open("[MethodImpl(MethodImplOptions.AggressiveInlining)] internal bool __TryPopNextDirty(out int bit)");
        w.Line("var w0 = Volatile.Read(ref __dirty0);");
        w.Open("if (w0 != 0)");
        w.Line("var u = (ulong)w0;");
        w.Line("var tz = __TrailingZeroCount(u);");
        if (threadSafe)
            w.Line("__AtomicAnd(ref __dirty0, ~(1L << tz));");
        else
            w.Line("__dirty0 &= ~(1L << tz);");

        w.Line("bit = tz;");
        w.Line("return true;");
        w.Close();
        w.Line("var ex = __dirtyEx;");
        w.Open("if (ex is not null)");
        w.Open("for (int i = 0; i < ex.Length; i++)");
        w.Line("var wi = Volatile.Read(ref ex[i]);");
        w.Open("if (wi != 0)");
        w.Line("var u2 = (ulong)wi;");
        w.Line("var tz2 = __TrailingZeroCount(u2);");
        if (threadSafe)
            w.Line("__AtomicAnd(ref ex[i], ~(1L << tz2));");
        else
            w.Line("ex[i] &= ~(1L << tz2);");

        w.Line("bit = ((i + 1) << __DirtyWordShift) + tz2;");
        w.Line("return true;");
        w.Close();
        w.Close();
        w.Close();
        w.Line("bit = -1;");
        w.Line("return false;");
        w.Close();
        w.Open("[MethodImpl(MethodImplOptions.AggressiveInlining)] internal void __ClearDirtyBit(int bit)");
        w.Open("if ((uint)bit <= 63)");
        if (threadSafe)
            w.Line("__AtomicAnd(ref __dirty0, ~(1L << bit));");
        else
            w.Line("__dirty0 &= ~(1L << bit);");

        w.Close();
        w.Open("else");
        w.Line("var word = bit >> __DirtyWordShift;");
        w.Line("var idx = word - 1;");
        w.Open("if (__dirtyEx is null || idx >= __dirtyEx.Length)");
        w.Line("return;");
        w.Close();
        if (threadSafe)
            w.Line("__AtomicAnd(ref __dirtyEx![idx], ~(1L << (bit & __DirtyWordMask)));");
        else
            w.Line("__dirtyEx![idx] &= ~(1L << (bit & __DirtyWordMask));");

        w.Close();
        w.Close();
        w.Open("[MethodImpl(MethodImplOptions.AggressiveInlining)] internal bool __HasAnyDirty()");
        w.Line("if (Volatile.Read(ref __dirty0) != 0) return true;");
        w.Line("var ex2 = __dirtyEx;");
        w.Open("if (ex2 is not null)");
        w.Open("for (int i = 0; i < ex2.Length; i++)");
        w.Line("if (Volatile.Read(ref ex2[i]) != 0) return true;");
        w.Close();
        w.Close();
        w.Line("return false;");
        w.Close();
        for (var i = 0; i < members.Length; i++)
            w.Line($"internal const int __Bit_{GenCommon.SanitizeIdentifier(members[i].Name)} = {i};");

        w.Close();
        if (ns is not null) w.Close();

        spc.AddSource(hint, w.ToString());
    }
    private void EmitImplementationsForType(CodeWriter w, INamedTypeSymbol type, DiffDeltaTarget root)
    {
        var fqn = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var id = GenCommon.SanitizeIdentifier(fqn);
        var key = fqn;
        _emittedDiffDelta.TryGetValue(key, out var emittedState);
        var needDiff = root.GenerateDiff && !emittedState.Diff;
        var needDelta = root.GenerateDelta && !emittedState.Delta;
        if (!needDiff && !needDelta) return;

        var nullSuffix = type.IsValueType ? "" : "?";
        var schema = GetTypeSchema(type);
        var deltaTracked = HasDeltaTrack(type);
        var helperTypeParameters = GenCommon.EnumerateAllTypeParameters(type).ToArray();
        var helperTypeParameterList = GenCommon.GetTypeParameterList(helperTypeParameters);
        var helperConstraints = GenCommon.GetTypeConstraintClauses(helperTypeParameters);

        // Stable indices table (if needed for delta)
        if (_useStableIndices && !_stableIndexTables.ContainsKey(type))
        {
            var orderedStable = OrderMembers(EnumerateMembers(type, root.IncludeInternals, root.IncludeBaseMembers, schema)).ToArray();
            var map = new Dictionary<string, int>(StringComparer.Ordinal);
            for (var i = 0; i < orderedStable.Length; i++) map[orderedStable[i].Name] = i;
            _stableIndexTables[type] = map;
        }

        // -------- DIFF: TryGetDiff__{id} --------
        if (needDiff)
        {
            w.Open(
                $"private static (bool hasDiff, DeepEqual.Generator.Shared.Diff<{fqn}> diff) TryGetDiff__{id}{helperTypeParameterList}({fqn}{nullSuffix} left, {fqn}{nullSuffix} right, DeepEqual.Generator.Shared.ComparisonContext context){helperConstraints}");

            if (!type.IsValueType)
            {
                w.Open("if (object.ReferenceEquals(left, right))");
                w.Line($"return (false, DeepEqual.Generator.Shared.Diff<{fqn}>.Empty);");
                w.Close();

                w.Open("if (left is null && right is not null)");
                w.Line($"return (true, DeepEqual.Generator.Shared.Diff<{fqn}>.Replacement(right));");
                w.Close();

                w.Open("if (left is not null && right is null)");
                w.Line($"return (true, DeepEqual.Generator.Shared.Diff<{fqn}>.Replacement(right));");
                w.Close();

                if (root.CycleTrackingEnabled)
                {
                    w.Open("if (!context.Enter(left!, right!))");
                    w.Line($"return (false, DeepEqual.Generator.Shared.Diff<{fqn}>.Empty);");
                    w.Close();
                    w.Open("try");
                }
            }

            w.Line("var changes = new System.Collections.Generic.List<DeepEqual.Generator.Shared.MemberChange>();");

            // Emit per-member DIFF
            foreach (var m in OrderMembers(EnumerateMembers(type, root.IncludeInternals, root.IncludeBaseMembers, schema)))
                EmitMemberDiff(w, type, m, root);

            w.Line(
                $"return changes.Count == 0 ? (false, DeepEqual.Generator.Shared.Diff<{fqn}>.Empty) : (true, DeepEqual.Generator.Shared.Diff<{fqn}>.Members(changes));");

            if (!type.IsValueType && root.CycleTrackingEnabled)
            {
                w.Close();
                w.Open("finally");
                w.Line("context.Exit(left!, right!);");
                w.Close();
            }

            w.Close();
            w.Line();
        }

        // -------- DELTA: ComputeDelta__{id} --------
        if (needDelta)
        {
            w.Open(
                $"private static void ComputeDelta__{id}{helperTypeParameterList}({fqn}{nullSuffix} left, {fqn}{nullSuffix} right, DeepEqual.Generator.Shared.ComparisonContext context, ref DeepEqual.Generator.Shared.DeltaWriter writer){helperConstraints}");

            if (!type.IsValueType)
            {
                w.Open("if (object.ReferenceEquals(left, right))");
                w.Line("return;");
                w.Close();

                w.Open("if (left is null && right is not null)");
                w.Line("writer.WriteReplaceObject(right);");
                w.Line("return;");
                w.Close();

                w.Open("if (left is not null && right is null)");
                w.Line("writer.WriteReplaceObject(right);");
                w.Line("return;");
                w.Close();

                if (root.CycleTrackingEnabled)
                {
                    w.Open("if (!context.Enter(left!, right!))");
                    w.Line("return;");
                    w.Close();
                    w.Open("try");
                }
            }

            var ordered = OrderMembers(EnumerateMembers(type, root.IncludeInternals, root.IncludeBaseMembers, schema)).ToArray();

            if (deltaTracked && !type.IsValueType)
            {
                // Dirty-track emission:
                // - Validated mode: drain bits so the right object is no longer "dirty", but DO NOT emit via fast loop.
                // - Fast mode: run the existing dirty-bit loop + catch-up exactly as before.
                // - After that: if validated OR there were no dirty bits, run per-member comparisons (EmitMemberDelta).

                w.Line("var __validate = context.Options.ValidateDirtyOnEmit;");
                w.Line("var __r = right;");
                w.Line("var __hasDirty = __r is not null && __r.__HasAnyDirty();");

                // VALIDATED MODE: clear flags, do not emit from fast loop
                w.Open("if (__hasDirty && __validate)", () =>
                {
                    w.Line("while (__r.__TryPopNextDirty(out _)) { }");
                });
                w.Open("if (__validate && right is not null)", () =>
                {
                    // For each reference-type member that itself is [DeltaTrack], flush its queue
                    foreach (var m in ordered)
                    {
                        // Only reference-like, non-array, non-list, non-dictionary members
                        bool isPlainRef =
                            m.Type.IsReferenceType &&
                            m.Type.SpecialType != SpecialType.System_String &&
                            !(m.Type is IArrayTypeSymbol) &&
                            !TryGetListInterface(m.Type, out _) &&
                            !TryGetDictionaryTypes(m.Type, out _, out _);

                        if (isPlainRef && m.Type is INamedTypeSymbol nt && HasDeltaTrack(nt))
                        {
                            var rightExpr = "right." + m.Name;
                            w.Open($"if ({rightExpr} is not null && {rightExpr}.__HasAnyDirty())", () =>
                            {
                                w.Line($"while ({rightExpr}.__TryPopNextDirty(out _)) {{ }}");
                            });
                        }
                    }
                });
                // FAST MODE: original dirty-bit loop + catch-up
                w.Open("if (__hasDirty && !__validate)");
                foreach (var m in ordered)
                {
                    var idx = GetStableMemberIndex(type, m);
                    w.Line($"bool __emitted_m{idx} = false;");
                }
                w.Open("while (__r.__TryPopNextDirty(out var __bit))");
                w.Open("switch (__bit)");
                for (var idx = 0; idx < ordered.Length; idx++)
                {
                    var mem = ordered[idx];
                    var stable = GetStableMemberIndex(type, mem);
                    var leftExpr = "left." + mem.Name;
                    var rightExpr = "right." + mem.Name;

                    // Unordered/keyed lists forced to Set
                    var (kind, orderInsensitive, keys, dShallow, dSkip) = ResolveEffectiveSettings(mem);
                    if (!dSkip && (orderInsensitive || keys.Length > 0))
                    {
                        w.Line($"writer.WriteSetMember({stable}, {rightExpr});");
                        w.Line("break;");
                        continue;
                    }

                    w.Open("case " + idx + ":");

                    if (kind == CompareKind.Skip || dSkip)
                    {
                        w.Line($"__emitted_m{stable} = true;");
                        w.Line("break;");
                        w.Close();
                        continue;
                    }

                    if (TryGetDictionaryTypes(mem.Type, out var kType, out var vType))
                    {
                        var kFqn = kType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        var vFqn = vType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        var nestedExpr = IsValueLike(vType) ? "false" : "true";
                        w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeDictDelta<{kFqn}, {vFqn}>({leftExpr}, {rightExpr}, {stable}, ref writer, {nestedExpr}, context);");
                        w.Line($"__emitted_m{stable} = true;");
                        w.Line("break;");
                        w.Close();
                        continue;
                    }

                    if (TryGetEnumerableElement(mem.Type, out var elemType) && TryGetListInterface(mem.Type, out _))
                    {
                        var (_, ordIns, keyMembers, _, dSk) = ResolveEffectiveSettings(mem);

                        if (!dSk && (ordIns || keyMembers.Length > 0))
                        {
                            w.Line($"writer.WriteSetMember({stable}, {rightExpr});");
                            w.Line($"__emitted_m{stable} = true;");
                            w.Line("break;");
                            w.Close();
                            continue;
                        }

                        var elFqn = elemType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        var deepAttr = GetDeepCompareAttribute(mem.Symbol);
                        var custom = GetEffectiveComparerType(elemType, deepAttr);

                        if (custom != null)
                        {
                            var cfqn = custom.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                            var cmpVar = "__cmpE_" + SanitizeIdentifier(type.Name) + "_" + SanitizeIdentifier(mem.Name);
                            w.Line($"var {cmpVar} = (System.Collections.Generic.IEqualityComparer<{elFqn}>)System.Activator.CreateInstance(typeof({cfqn}))!;");
                            w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeListDelta<{elFqn}, DeepEqual.Generator.Shared.DelegatingElementComparer<{elFqn}>>({leftExpr}, {rightExpr}, {stable}, ref writer, new DeepEqual.Generator.Shared.DelegatingElementComparer<{elFqn}>({cmpVar}), context);");
                        }
                        else if (IsValueLike(elemType))
                        {
                            w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeListDelta<{elFqn}, DeepEqual.Generator.Shared.DefaultElementComparer<{elFqn}>>({leftExpr}, {rightExpr}, {stable}, ref writer, new DeepEqual.Generator.Shared.DefaultElementComparer<{elFqn}>(), context);");
                        }
                        else
                        {
                            w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeListDeltaNested<{elFqn}>({leftExpr}, {rightExpr}, {stable}, ref writer, context);");
                        }
                        w.Line($"__emitted_m{stable} = true;");
                        w.Line("break;");
                        w.Close();
                        continue;
                    }

                    if (TryGetEnumerableElement(mem.Type, out _))
                    {
                        w.Line($"writer.WriteSetMember({stable}, {rightExpr});");
                        w.Line($"__emitted_m{stable} = true;");
                        w.Line("break;");
                        w.Close();
                        continue;
                    }

                    if (IsValueLike(mem.Type) || kind == CompareKind.Reference || kind == CompareKind.Shallow || dShallow)
                    {
                        w.Line($"writer.WriteSetMember({stable}, {rightExpr});");
                        w.Line($"__emitted_m{stable} = true;");
                        w.Line("break;");
                        w.Close();
                        continue;
                    }

                    // Concrete class nested delta
                    if (mem.Type is INamedTypeSymbol { IsGenericType: false, IsAnonymousType: false })
                    {
                        var ltmp = $"__l_{stable}";
                        var rtmp = $"__r_{stable}";
                        w.Line($"var {ltmp} = {leftExpr};");
                        w.Line($"var {rtmp} = {rightExpr};");
                        w.Line("var __doc = new DeepEqual.Generator.Shared.DeltaDocument();");
                        w.Line("var __w = new DeepEqual.Generator.Shared.DeltaWriter(__doc);");
                        w.Open($"if (!object.ReferenceEquals({ltmp}, {rtmp}) && {ltmp} is not null && {rtmp} is not null)");
                        w.Line($"var __t = {ltmp}.GetType();");
                        w.Open($"if (object.ReferenceEquals(__t, {rtmp}.GetType()))");
                        w.Line($"GeneratedHelperRegistry.ComputeDeltaSameType(__t, {ltmp}, {rtmp}, context, ref __w);");
                        w.Close();
                        w.Close();
                        w.Open("if (!__doc.IsEmpty)");
                        w.Line($"writer.WriteNestedMember({stable}, __doc);");
                        w.Close();
                        w.Open("else");
                        w.Line($"writer.WriteSetMember({stable}, {rightExpr});");
                        w.Close();
                        w.Line("break;");
                        w.Close();
                        continue;
                    }

                    w.Line($"writer.WriteSetMember({stable}, {rightExpr});");
                    w.Line("break;");
                    w.Close();
                }
                w.Close(); // switch
                w.Close(); // while

                // Post-loop catch-up for unordered/keyed lists
                foreach (var mem in ordered)
                {
                    if (TryGetEnumerableElement(mem.Type, out _) && TryGetListInterface(mem.Type, out _))
                    {
                        var (_, ordIns, keyMembers, _, dSkip2) = ResolveEffectiveSettings(mem);
                        if (!dSkip2 && (ordIns || keyMembers.Length > 0))
                        {
                            var stable = GetStableMemberIndex(type, mem);
                            var rightExpr = "right." + mem.Name;
                            w.Open($"if (!__emitted_m{stable})");
                            w.Line($"writer.WriteSetMember({stable}, {rightExpr});");
                            w.Close();
                        }
                    }
                }
                w.Close(); // if (__hasDirty && !__validate)

                // Validated mode OR no-dirty: per-member comparison (suppresses reverts)
                w.Open("if (!__hasDirty || __validate)");
                foreach (var m in ordered) EmitMemberDelta(w, type, m, root);
                w.Close();
            }
            else
            {
                // No dirty-track: per-member compare only
                foreach (var m in ordered) EmitMemberDelta(w, type, m, root);
            }


            if (!type.IsValueType && root.CycleTrackingEnabled)
            {
                w.Close();
                w.Open("finally");
                w.Line("context.Exit(left!, right!);");
                w.Close();
            }
            w.Close();
            w.Line();
        }

        // -------- DELTA: ApplyDelta__{id} --------
        if (needDelta)
        {
            // Local helpers (inside emitted method scope)
            void EmitInPlaceReplaceForGetOnlyCollection(string targetExpr, string elFqn, string kind)
            {
                switch (kind)
                {
                    case "ISet":
                        w.Line($"var __dobj = {targetExpr};");
                        w.Open($"if (__dobj is System.Collections.Generic.ISet<{elFqn}> __set)");
                        w.Line($"__set.Clear();");
                        w.Open($"if (op.Value is System.Collections.Generic.IEnumerable<{elFqn}> __src)");
                        w.Line($"foreach (var __v in __src) __set.Add(__v);");
                        w.Close(); w.Close();
                        break;

                    case "LinkedList":
                        w.Line($"var __ldst = {targetExpr};");
                        w.Open($"if (__ldst is System.Collections.Generic.LinkedList<{elFqn}> __ll)");
                        w.Line($"__ll.Clear();");
                        w.Open($"if (op.Value is System.Collections.Generic.IEnumerable<{elFqn}> __src)");
                        w.Line($"foreach (var __v in __src) __ll.AddLast(__v);");
                        w.Close(); w.Close();
                        break;

                    case "Queue":
                        w.Line($"var __qdst = {targetExpr};");
                        w.Open($"if (__qdst is System.Collections.Generic.Queue<{elFqn}> __q)");
                        w.Line($"__q.Clear();");
                        w.Open($"if (op.Value is System.Collections.Generic.IEnumerable<{elFqn}> __src)");
                        w.Line($"foreach (var __v in __src) __q.Enqueue(__v);");
                        w.Close(); w.Close();
                        break;

                    case "Stack":
                        w.Line($"var __sdst = {targetExpr};");
                        w.Open($"if (__sdst is System.Collections.Generic.Stack<{elFqn}> __s)");
                        w.Line($"__s.Clear();");
                        w.Open($"if (op.Value is System.Collections.Generic.IEnumerable<{elFqn}> __src)");
                        w.Line($"var __tmp = __src as System.Collections.Generic.IList<{elFqn}> ?? new System.Collections.Generic.List<{elFqn}>(__src);");
                        w.Line($"for (int __i = __tmp.Count - 1; __i >= 0; __i--) __s.Push(__tmp[__i]);");
                        w.Close(); w.Close();
                        break;

                    case "ICollection":
                        w.Line($"var __cdst = {targetExpr};");
                        w.Open($"if (__cdst is System.Collections.Generic.ICollection<{elFqn}> __c)");
                        w.Line($"__c.Clear();");
                        w.Open($"if (op.Value is System.Collections.Generic.IEnumerable<{elFqn}> __src)");
                        w.Line($"foreach (var __v in __src) __c.Add(__v);");
                        w.Close(); w.Close();
                        break;
                }
            }

            string BclKind(ITypeSymbol t, out ITypeSymbol? e)
            {
                e = null;
                if (!TryGetEnumerableElement(t, out var te)) return "";
                e = te;
                var f = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                if (f.StartsWith("global::System.Collections.Generic.HashSet<")) return "ISet";
                if (f.StartsWith("global::System.Collections.Generic.SortedSet<")) return "ISet";
                if (f.StartsWith("global::System.Collections.Generic.LinkedList<")) return "LinkedList";
                if (f.StartsWith("global::System.Collections.Generic.Queue<")) return "Queue";
                if (f.StartsWith("global::System.Collections.Generic.Stack<")) return "Stack";
                foreach (var i in (t as INamedTypeSymbol)?.AllInterfaces ?? [])
                {
                    var ifqn = i.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    if (ifqn.StartsWith("global::System.Collections.Generic.ISet<")) return "ISet";
                    if (ifqn.StartsWith("global::System.Collections.Generic.ICollection<")) return "ICollection";
                }
                return "";
            }

            w.Open(
                $"private static void ApplyDelta__{id}{helperTypeParameterList}(ref {fqn}{nullSuffix} target, ref DeepEqual.Generator.Shared.DeltaReader reader){helperConstraints}");
            w.Line("var __ops = reader.AsSpan();");
            // Handle root-level ReplaceObject *before* any access to 'target'
            w.Open("for (int __ri = 0; __ri < __ops.Length; __ri++)");
            w.Line("ref readonly var __ro = ref __ops[__ri];");
            w.Open("if (__ro.MemberIndex == -1 && __ro.Kind == DeepEqual.Generator.Shared.DeltaKind.ReplaceObject)");
            w.Line($"target = ({fqn}{nullSuffix})__ro.Value;");
            w.Line("return;");
            w.Close(); // if
            w.Close(); // for

            // presize pass (unchanged)
            var __preByOrdinal = OrderMembers(
                    EnumerateMembers(type, root.IncludeInternals, root.IncludeBaseMembers, schema))
                .Select(m => (ms: m, idx: GetStableMemberIndex(type, m)))
                .ToArray();

            var __hasPresizableMembers =
                __preByOrdinal.Any(t =>
                    (TryGetListInterface(t.ms.Type, out _) && !(t.ms.Type is IArrayTypeSymbol)) ||
                    (TryGetDictionaryTypes(t.ms.Type, out _, out _) && !IsExpando(t.ms.Type)));

            w.Open("if (target is not null)");
            foreach (var t2 in __preByOrdinal)
            {
                var m = t2.ms;
                var idx = t2.idx;

                if (TryGetListInterface(m.Type, out _) && m.Type is not IArrayTypeSymbol)
                    w.Line($"int __adds_m{idx} = 0;");
                else if (TryGetDictionaryTypes(m.Type, out _, out _) && !IsExpando(m.Type))
                    w.Line($"int __dictSets_m{idx} = 0;");
            }
            w.Open("for (int __i=0; __i<__ops.Length; __i++)");
            w.Line("ref readonly var __o = ref __ops[__i];");
            w.Open("switch (__o.MemberIndex)");
            foreach (var t2 in __preByOrdinal)
            {
                var m = t2.ms;
                var idx = t2.idx;

                if (TryGetListInterface(m.Type, out _) && m.Type is not IArrayTypeSymbol)
                    w.Line($"case {idx}: if (__o.Kind==DeepEqual.Generator.Shared.DeltaKind.SeqAddAt) __adds_m{idx}++; break;");
                else if (TryGetDictionaryTypes(m.Type, out _, out _) && !IsExpando(m.Type))
                    w.Line($"case {idx}: if (__o.Kind==DeepEqual.Generator.Shared.DeltaKind.DictSet) __dictSets_m{idx}++; break;");
            }
            w.Close(); // switch
            w.Close(); // for

            foreach (var t2 in __preByOrdinal)
            {
                var m = t2.ms;
                var idx = t2.idx;
                var propAccess = "target." + m.Name;

                if (TryGetListInterface(m.Type, out var elTypeForPresize) && m.Type is not IArrayTypeSymbol)
                {
                    var elFqnPS = elTypeForPresize.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    w.Line($"{{ var __obj = {propAccess}; if (__adds_m{idx} > 0 && __obj is System.Collections.Generic.List<{elFqnPS}> __l) __l.EnsureCapacity(__l.Count + __adds_m{idx}); }}");
                }
                else if (TryGetDictionaryTypes(m.Type, out var preKType, out var preVType) && !IsExpando(m.Type))
                {
                    var kFqnPS = preKType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var vFqnPS = preVType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    w.Line($"{{ var __obj = {propAccess}; if (__dictSets_m{idx} > 0 && __obj is System.Collections.Generic.Dictionary<{kFqnPS}, {vFqnPS}> __d) __d.EnsureCapacity(__d.Count + __dictSets_m{idx}); }}");
                }
            }
            w.Close(); // if presize

            // apply pass
            w.Open("for (int __ai=0; __ai<__ops.Length; __ai++)");
            w.Line("ref readonly var op = ref __ops[__ai];");
            w.Open("switch (op.MemberIndex)");

            // ReplaceObject
            w.Open("case -1:");
            w.Open("if (op.Kind == DeepEqual.Generator.Shared.DeltaKind.ReplaceObject)");
            w.Line($"target = ({fqn}{nullSuffix})op.Value;");
            w.Line("return;");
            w.Close();
            w.Line("break;");
            w.Close();

            // Each member
            var byOrdinal = OrderMembers(EnumerateMembers(type, root.IncludeInternals, root.IncludeBaseMembers, schema))
                .Select((ms, i) => (ms, i)).ToArray();

            foreach (var t2 in byOrdinal)
            {
                var member = t2.ms;
                var ordinal = t2.i;
                var memberIdx = GetStableMemberIndex(type, member);
                var propAccess = "target." + member.Name;
                var typeFqn = member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var nullableQ = member.Type.IsReferenceType ? "?" : "";
                var hasSetterForMember = member.Symbol is IPropertySymbol __ps2 && __ps2.SetMethod is not null;

                w.Open($"case {memberIdx}:");
                w.Open("switch (op.Kind)");

                if (IsExpando(member.Type)) // you already have IsExpando(ITypeSymbol) in this file
                {
                    // emit only the expando cases, then close and continue
                    EmitApplyForExpando(w, propAccess, clearDirty: !type.IsValueType && deltaTracked, ordinal);
                    w.Line("default: { break; }");
                    w.Close();        // switch (op.Kind)
                    w.Line("break;"); // case memberIdx
                    w.Close();
                    continue;         // move to next member
                }

                // SetMember
                w.Open("case DeepEqual.Generator.Shared.DeltaKind.SetMember:");
                if (member.Type is IArrayTypeSymbol)
                {
                    w.Line($"{propAccess} = ({typeFqn}{nullableQ})op.Value;");
                }
                else if (TryGetDictionaryTypes(member.Type, out var kForSet, out var vForSet))
                {
                    var kFqn = kForSet.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var vFqn = vForSet.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                    if (hasSetterForMember)
                    {
                        w.Line($"{propAccess} = ({$"global::System.Collections.Generic.Dictionary<{kFqn}, {vFqn}>"}{nullableQ})op.Value;");
                    }
                    else
                    {
                        w.Line($"var __dobj = {propAccess};");
                        w.Open($"if (__dobj is global::System.Collections.Generic.IDictionary<{kFqn}, {vFqn}> __d)");
                        w.Line($"__d.Clear();");
                        w.Open($"if (op.Value is global::System.Collections.Generic.IEnumerable<global::System.Collections.Generic.KeyValuePair<{kFqn}, {vFqn}>> __src)");
                        w.Line($"foreach (var __kv in __src) __d[__kv.Key] = __kv.Value;");
                        w.Close(); w.Close();
                    }
                }
                else
                {
                    // handle get-only BCL collections
                    var bcl = BclKind(member.Type, out var elT);
                    if (!hasSetterForMember && !string.IsNullOrEmpty(bcl))
                    {
                        var eFqn = elT!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        EmitInPlaceReplaceForGetOnlyCollection(propAccess, eFqn, bcl);
                    }
                    else
                    {
                        w.Line($"{propAccess} = ({typeFqn})op.Value;");
                    }
                }
                if (!type.IsValueType && deltaTracked) w.Line($"target.__ClearDirtyBit({ordinal});");
                w.Line("break;");
                w.Close(); // SetMember

                // Seq ops
                if (TryGetListInterface(member.Type, out var elType) /* && not array */)
                {
                    var elFqn = elType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                    void EmitListOp(string opName, string tmp)
                    {
                        w.Open($"case DeepEqual.Generator.Shared.DeltaKind.{opName}:");
                        w.Line($"object? {tmp} = {propAccess};");
                        w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ApplyListOpCloneIfNeeded<{elFqn}>(ref {tmp}, in op);");
                        if (hasSetterForMember) w.Line($"{propAccess} = ({typeFqn}){tmp};");
                        if (!type.IsValueType && deltaTracked) w.Line($"target.__ClearDirtyBit({ordinal});");
                        w.Line("break;");
                        w.Close();
                    }

                    EmitListOp("SeqReplaceAt", "__obj_seq_r");
                    EmitListOp("SeqAddAt", "__obj_seq_a");
                    EmitListOp("SeqRemoveAt", "__obj_seq_d");
                    EmitListOp("SeqNestedAt", "__obj_seq_n");
                }

                // Dict ops
                if (TryGetDictionaryTypes(member.Type, out var kType2, out var vType2))
                {
                    var kFqn2 = kType2.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    var vFqn2 = vType2.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                    void EmitDictOp(string opName, string tmp)
                    {
                        w.Open($"case DeepEqual.Generator.Shared.DeltaKind.{opName}:");
                        w.Line($"object? {tmp} = {propAccess};");
                        w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ApplyDictOpCloneIfNeeded<{kFqn2}, {vFqn2}>(ref {tmp}, in op);");
                        if (hasSetterForMember) w.Line($"{propAccess} = ({$"global::System.Collections.Generic.Dictionary<{kFqn2}, {vFqn2}>"}){tmp};");
                        if (!type.IsValueType && deltaTracked) w.Line($"target.__ClearDirtyBit({ordinal});");
                        w.Line("break;");
                        w.Close();
                    }

                    EmitDictOp("DictSet", "__obj_dict_set");
                    EmitDictOp("DictRemove", "__obj_dict_rm");
                    EmitDictOp("DictNested", "__obj_dict_n");
                }
                else
                {
                    w.Open("case DeepEqual.Generator.Shared.DeltaKind.DictSet:"); w.Line("break;"); w.Close();
                    w.Open("case DeepEqual.Generator.Shared.DeltaKind.DictRemove:"); w.Line("break;"); w.Close();
                    w.Open("case DeepEqual.Generator.Shared.DeltaKind.DictNested:"); w.Line("break;"); w.Close();
                }

                // Nested member (objects only)
                {
                    bool isPlainRef =
                        member.Type.IsReferenceType &&
                        member.Type.SpecialType != SpecialType.System_String &&
                        !(member.Type is IArrayTypeSymbol) &&
                        !TryGetListInterface(member.Type, out _) &&
                        !TryGetDictionaryTypes(member.Type, out _, out _);

                    if (isPlainRef)
                    {
                        w.Open("case DeepEqual.Generator.Shared.DeltaKind.NestedMember:");
                        w.Line($"object? __obj = {propAccess};");
                        w.Line("var __subReader = new DeepEqual.Generator.Shared.DeltaReader(op.Nested!);");
                        w.Open("if (__obj != null)");
                        w.Line("var __t = __obj.GetType();");
                        w.Line("GeneratedHelperRegistry.TryApplyDeltaSameType(__t, ref __obj, ref __subReader);");
                        w.Close();
                        if (hasSetterForMember) w.Line($"{propAccess} = ({typeFqn}{nullableQ})__obj;");
                        if (!type.IsValueType && deltaTracked) w.Line($"target.__ClearDirtyBit({ordinal});");
                        w.Line("break;");
                        w.Close();
                    }
                }

                w.Line("default: { break; }");
                w.Close(); // switch op.Kind
                w.Line("break;");
                w.Close(); // case memberIdx
            }

            w.Open("default:"); w.Line("break;"); w.Close();
            w.Close(); // switch memberIndex
            w.Close(); // for ops
            w.Close(); // ApplyDelta
            w.Line();
        }
        _emittedDiffDelta[key] = (emittedState.Diff || needDiff, emittedState.Delta || needDelta);
    }
    // Emits the ApplyDelta cases for a property of type global::System.Dynamic.ExpandoObject
    private static void EmitApplyForExpando(CodeWriter w, string propAccess, bool clearDirty, int ordinal)
    {
        // SetMember: assign the Expando directly
        w.Open("case DeepEqual.Generator.Shared.DeltaKind.SetMember:");
        w.Line($"{propAccess} = (global::System.Dynamic.ExpandoObject?)op.Value;");
        if (clearDirty) w.Line($"target.__ClearDirtyBit({ordinal});");
        w.Line("break;");
        w.Close();

        // DictSet/DictRemove/DictNested: Apply op into a temp dict, then copy into a fresh Expando
        string[] dictCases = { "DictSet", "DictRemove", "DictNested" };
        foreach (var k in dictCases)
        {
            w.Open($"case DeepEqual.Generator.Shared.DeltaKind.{k}:");
            w.Line("object? __tmp = " + propAccess + ";");
            w.Line("DeepEqual.Generator.Shared.DeltaHelpers.ApplyDictOpCloneIfNeeded<string, object>(ref __tmp, in op);");
            w.Line("var __src = (System.Collections.Generic.IDictionary<string, object?>)__tmp!;");
            w.Line("var __exp = new global::System.Dynamic.ExpandoObject();");
            w.Line("var __dst = (System.Collections.Generic.IDictionary<string, object?>)__exp;");
            w.Line("__dst.Clear();");
            w.Line("foreach (var __kv in __src) __dst[__kv.Key] = __kv.Value;");
            w.Line($"{propAccess} = __exp;");
            if (clearDirty) w.Line($"target.__ClearDirtyBit({ordinal});");
            w.Line("break;");
            w.Close();
        }
    }

    private void EmitMemberDiff(CodeWriter w, INamedTypeSymbol owner, DiffDeltaMemberSymbol member, DiffDeltaTarget root)
    {
        var idx = GetStableMemberIndex(owner, member);
        var left = "left." + member.Name;
        var right = "right." + member.Name;

        var (effKind, orderInsensitive, _, deltaShallow, deltaSkip) = ResolveEffectiveSettings(member);
        if (effKind == CompareKind.Skip || deltaSkip) return;

        // Arrays: replace-on-change (keep DIFF simple for arrays)
        if (member.Type is IArrayTypeSymbol arr)
        {
            var el = arr.ElementType;
            var elFqn = el.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            var elemCmpType = $"DeepEqual.Generator.Shared.DefaultElementComparer<{elFqn}>";
            var elemCmpCtor = $"new {elemCmpType}()";

            if (arr.Rank != 1)
            {
                w.Open($"if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualArray<{elFqn}, {elemCmpType}>((System.Array?){left}, (System.Array?){right}, {elemCmpCtor}, context))");
                w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
                w.Close();
                return;
            }
            else
            {
                w.Open($"if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualArrayRank1<{elFqn}, {elemCmpType}>({left} as {elFqn}[], {right} as {elFqn}[], {elemCmpCtor}, context))");
                w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
                w.Close();
                return;
            }
        }

        // Value-like (incl. string/double/float/decimal/Nullable<>, Memory<T>)
        if (IsValueLike(member.Type))
        {
            var eq = GetValueLikeEqualsInvocation(member.Type, left, right);
            w.Open($"if (!({eq}))");
            w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            w.Close();
            return;
        }

        // Ref-equality only
        if (effKind == CompareKind.Reference && member.Type.IsReferenceType)
        {
            w.Open($"if (!object.ReferenceEquals({left}, {right}))");
            w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            w.Close();
            return;
        }

        // Shallow equality
        if (effKind == CompareKind.Shallow)
        {
            var tfqn = member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            w.Open($"if (!System.Collections.Generic.EqualityComparer<{tfqn}>.Default.Equals({left}, {right}))");
            w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            w.Close();
            return;
        }

        // deltaShallow: single deep polymorphic equality check
        if (deltaShallow)
        {
            w.Open($"if (!DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic({left}, {right}, context))");
            w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            w.Close();
            return;
        }

        // Dictionary: allow structural ops only if settable or concrete Dictionary<,>, otherwise SetMember or nested-only
        // ? Dictionaries ? build DeltaDocument and emit CollectionOps
        if (TryGetDictionaryTypes(member.Type, out var kType, out var vType))
        {
            var kFqn = kType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var vFqn = vType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var allowNested = IsValueLike(vType) ? "false" : "true"; // nested only when values are not value-like

            var la = $"__dictA_{SanitizeIdentifier(owner.Name)}_{SanitizeIdentifier(member.Name)}";
            var lb = $"__dictB_{SanitizeIdentifier(owner.Name)}_{SanitizeIdentifier(member.Name)}";

            // Bind as object to avoid CS8121 for sealed types like ExpandoObject
            w.Line($"object {la} = {left};");
            w.Line($"object {lb} = {right};");

            w.Open($"if (!object.ReferenceEquals({la}, {lb}))");
            w.Open($"if ({la} is null || {lb} is null)");
            w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            w.Close();
            w.Open("else");
            w.Line("var __doc = new DeepEqual.Generator.Shared.DeltaDocument();");
            w.Line("var __w = new DeepEqual.Generator.Shared.DeltaWriter(__doc);");

            // Try IDictionary<,> first (covers ExpandoObject)
            w.Open($"if ({la} is System.Collections.Generic.IDictionary<{kFqn}, {vFqn}> __rwa && {lb} is System.Collections.Generic.IDictionary<{kFqn}, {vFqn}> __rwb)");
            w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeDictDelta<{kFqn}, {vFqn}>(__rwa, __rwb, 0, ref __w, {allowNested}, context);");
            w.Close();

            // Then IReadOnlyDictionary<,>
            w.Open($"else if ({la} is System.Collections.Generic.IReadOnlyDictionary<{kFqn}, {vFqn}> __roa && {lb} is System.Collections.Generic.IReadOnlyDictionary<{kFqn}, {vFqn}> __rob)");
            w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeReadOnlyDictDelta<{kFqn}, {vFqn}>(__roa, __rob, 0, ref __w, {allowNested}, context);");
            w.Close();

            w.Open("else");
            w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            w.Line("goto __end_dict_" + idx + ";");
            w.Close();

            w.Open("if (!__doc.IsEmpty)");
            w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.CollectionOps, __doc));");
            w.Close();

            w.Line("__end_dict_" + idx + ": ;");
            w.Close(); // else non-null
            w.Close();
            return;
        }


        // ? List-like (IList<T> / IReadOnlyList<T> / IEnumerable<T>) ? CollectionOps
        if (TryGetEnumerableElement(member.Type, out var elemType) && member.Type is not IArrayTypeSymbol)
        {
            var elFqn = elemType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var la = $"__l_{SanitizeIdentifier(owner.Name)}_{SanitizeIdentifier(member.Name)}";
            var lb = $"__r_{SanitizeIdentifier(owner.Name)}_{SanitizeIdentifier(member.Name)}";

            w.Line($"var {la} = {left};");
            w.Line($"var {lb} = {right};");

            w.Open($"if (!object.ReferenceEquals({la}, {lb}))");
            w.Open($"if ({la} is null || {lb} is null)");
            w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            w.Close(); // null

            // Optional order-insensitive suppression for value-like elements
            if (orderInsensitive && IsValueLike(elemType))
            {
                // local multiset compare without extra helpers
                var mapVar = "__ms_" + idx;
                w.Line($"var __ena_{idx} = {la} as System.Collections.Generic.IEnumerable<{elFqn}>;");
                w.Line($"var __enb_{idx} = {lb} as System.Collections.Generic.IEnumerable<{elFqn}>;");
                w.Open($"if (__ena_{idx} is not null && __enb_{idx} is not null)");
                w.Line($"var {mapVar} = new System.Collections.Generic.Dictionary<{elFqn}, int>();");
                w.Line($"foreach (var __v in __ena_{idx}) {{ {mapVar}.TryGetValue(__v, out var c); {mapVar}[__v] = c + 1; }}");
                w.Line($"bool __eqms_{idx} = true;");
                w.Line($"foreach (var __v in __enb_{idx}) {{ if (!{mapVar}.TryGetValue(__v, out var c) || c == 0) {{ __eqms_{idx} = false; break; }} {mapVar}[__v] = c - 1; }}");
                w.Line($"if (__eqms_{idx}) {{ /* multisets equal -> no change */ goto __end_seq_{idx}; }}");
                w.Close(); // if enumerables

                // fall through to structural ops if not equal as multiset
            }

            // Materialize to IList<T>
            w.Line($"var __ena = {la} as System.Collections.Generic.IEnumerable<{elFqn}>;");
            w.Line($"var __enb = {lb} as System.Collections.Generic.IEnumerable<{elFqn}>;");
            w.Line($"var __la = __ena as System.Collections.Generic.IList<{elFqn}> ?? (__ena is null ? null : new System.Collections.Generic.List<{elFqn}>(__ena));");
            w.Line($"var __lb = __enb as System.Collections.Generic.IList<{elFqn}> ?? (__enb is null ? null : new System.Collections.Generic.List<{elFqn}>(__enb));");

            w.Open("if (__la is null || __lb is null)");
            w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            w.Close();
            w.Open("else");
            w.Line("var __doc = new DeepEqual.Generator.Shared.DeltaDocument();");
            w.Line("var __w = new DeepEqual.Generator.Shared.DeltaWriter(__doc);");
            if (IsValueLike(elemType))
            {
                var cmpType = $"DeepEqual.Generator.Shared.DefaultElementComparer<{elFqn}>";
                w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeListDelta<{elFqn}, {cmpType}>(__la, __lb, 0, ref __w, new {cmpType}(), context);");
            }
            else
            {
                w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeListDeltaNested<{elFqn}>(__la, __lb, 0, ref __w, context);");
            }
            w.Open("if (!__doc.IsEmpty)");
            w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.CollectionOps, __doc));");
            w.Close();
            w.Close(); // else

            if (orderInsensitive && IsValueLike(elemType))
                w.Line($"__end_seq_{idx}: ;");

            w.Close(); // if !refEq
            return;
        }

        // Objects ? try nested typed diff; only emit when non-empty
        {
            var ltmp = $"__l_{idx}";
            var rtmp = $"__r_{idx}";
            w.Line($"var {ltmp} = {left};");
            w.Line($"var {rtmp} = {right};");

            w.Open($"if (object.ReferenceEquals({ltmp}, {rtmp}))");
            w.Line("// no change");
            w.Close();

            w.Open($"else if ({ltmp} is null || {rtmp} is null)");
            w.Line($"changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            w.Close();

            w.Line("else {");
            w.Line($"    var __tL = {ltmp}.GetType();");
            w.Line($"    var __tR = {rtmp}.GetType();");
            w.Open("    if (!object.ReferenceEquals(__tL, __tR))");
            w.Line($"    changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            w.Close();
            w.Line("    else {");
            w.Line("        if (GeneratedHelperRegistry.TryGetDiffSameType(__tL, " + ltmp + ", " + rtmp + ", context, out var __idiff)) {");
            w.Line("            if (!__idiff.IsEmpty) changes.Add(new DeepEqual.Generator.Shared.MemberChange(" + idx + ", DeepEqual.Generator.Shared.MemberChangeKind.Nested, __idiff));");
            w.Line("        } else {");
            w.Open("            if (!DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic(" + ltmp + ", " + rtmp + ", context))");
            w.Line($"            changes.Add(new DeepEqual.Generator.Shared.MemberChange({idx}, DeepEqual.Generator.Shared.MemberChangeKind.Set, {right}));");
            w.Close();
            w.Line("        }");
            w.Line("    }");
            w.Line("}");
        }
    }

    private void EmitMemberDelta(CodeWriter w, INamedTypeSymbol owner, DiffDeltaMemberSymbol member, DiffDeltaTarget root)
    {
        var idx = GetStableMemberIndex(owner, member);
        var left = "left." + member.Name;
        var right = "right." + member.Name;
        var hasSetterForMember = member.Symbol is IPropertySymbol ps && ps.SetMethod is not null;
        var typeFqn = member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        var (effKind, orderInsensitive, keys, deltaShallow, deltaSkip) = ResolveEffectiveSettings(member);
        if (effKind == CompareKind.Skip || deltaSkip) return;

        // ---- Value-like
        if (IsValueLike(member.Type))
        {
            var cmp = GetValueLikeEqualsInvocation(member.Type, left, right);
            w.Open($"if (!({cmp}))");
            w.Line($"writer.WriteSetMember({idx}, {right});");
            w.Close();
            return;
        }

        // ---- Reference
        if (effKind == CompareKind.Reference && member.Type.IsReferenceType)
        {
            w.Open($"if (!object.ReferenceEquals({left}, {right}))");
            w.Line($"writer.WriteSetMember({idx}, {right});");
            w.Close();
            return;
        }

        // ---- Shallow
        if (effKind == CompareKind.Shallow)
        {
            var tfqn = member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            w.Open($"if (!System.Collections.Generic.EqualityComparer<{tfqn}>.Default.Equals({left}, {right}))");
            w.Line($"writer.WriteSetMember({idx}, {right});");
            w.Close();
            return;
        }

        // ---- Polymorphic one-shot
        if (deltaShallow)
        {
            w.Open($"if (!DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic({left}, {right}, context))");
            w.Line($"writer.WriteSetMember({idx}, {right});");
            w.Close();
            return;
        }

        // ================= Arrays =================
        if (member.Type is IArrayTypeSymbol arrT)
        {
            var elFqn = arrT.ElementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            if (!arrT.IsSZArray || arrT.Rank != 1)
            {
                w.Open($"if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualArray<{elFqn}, DeepEqual.Generator.Shared.DefaultElementComparer<{elFqn}>>((System.Array?){left}, (System.Array?){right}, new DeepEqual.Generator.Shared.DefaultElementComparer<{elFqn}>(), context))");
                w.Line($"writer.WriteSetMember({idx}, {right});");
                w.Close();
                return;
            }

            w.Open($"if (!DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualArrayRank1<{elFqn}, DeepEqual.Generator.Shared.DefaultElementComparer<{elFqn}>>({left} as {elFqn}[], {right} as {elFqn}[], new DeepEqual.Generator.Shared.DefaultElementComparer<{elFqn}>(), context))");
            w.Line($"writer.WriteSetMember({idx}, {right});");
            w.Close();
            return;
        }

        // Dictionary: allow structural ops only if settable or concrete Dictionary<,>, otherwise SetMember or nested-only
        // IDictionary / IReadOnlyDictionary / ExpandoObject
        if (TryGetDictionaryTypes(member.Type, out var kType, out var vType))
        {
            var kFqn = kType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var vFqn = vType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            // Expando is really IDictionary<string, object?>
            var isExpando =
                member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                "global::System.Dynamic.ExpandoObject";

            // Common soft-typed maps (helps decide "allowNested")
            var isStringObjectDict =
                kType.SpecialType == SpecialType.System_String &&
                (vType.SpecialType == SpecialType.System_Object ||
                 vType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Object");

            // Allow nested deltas for polymorphic / objecty values
            var allowNestedExpr =
                (vType.SpecialType == SpecialType.System_Object ||
                 vType.TypeKind == TypeKind.Interface ||
                 vType.IsReferenceType && vType.IsSealed == false
                ) ? "true" : "false";

            var la = $"__dictA_{SanitizeIdentifier(owner.Name)}_{SanitizeIdentifier(member.Name)}";
            var lb = $"__dictB_{SanitizeIdentifier(owner.Name)}_{SanitizeIdentifier(member.Name)}";
            w.Line($"var {la} = {left};");
            w.Line($"var {lb} = {right};");

            w.Open($"if (!object.ReferenceEquals({la}, {lb}))");

            // Null <-> non-null => replace whole member
            w.Open($"if ({la} is null || {lb} is null)");
            w.Line($"writer.WriteSetMember({idx}, {right});");
            w.Close(); // null check

            // Expando / IDictionary<string, object?>
            if (isExpando || isStringObjectDict)
            {
                w.Open("else"); // important — don't fall through after the null branch
                w.Line($"var __ida = (System.Collections.Generic.IDictionary<string, object?>){la};");
                w.Line($"var __idb = (System.Collections.Generic.IDictionary<string, object?>){lb};");

                // Fast equality guard: avoid emitting any ops if contents are deep-equal
                w.Line("bool __eq = __ida.Count == __idb.Count;");
                w.Open("if (__eq)");
                w.Line("foreach (var __kv in __ida) {");
                w.Line("    if (!__idb.TryGetValue(__kv.Key, out var __rv) ||");
                w.Line("        !DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic(__kv.Value, __rv, context))");
                w.Line("    { __eq = false; break; }");
                w.Line("}");
                w.Close(); // if (__eq)

                w.Open("if (!__eq)");
                w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeDictDelta<string, object?>(__ida, __idb, {idx}, ref writer, {allowNestedExpr}, context);");
                w.Close(); // if (!__eq)
                w.Close(); // else
            }
            else
            {
                // IReadOnlyDictionary<K,V> — we still emit granular key ops; Apply will clone/assign as needed
                w.Open($"else if ({la} is System.Collections.Generic.IReadOnlyDictionary<{kFqn}, {vFqn}> __roa && {lb} is System.Collections.Generic.IReadOnlyDictionary<{kFqn}, {vFqn}> __rob)");
                w.Line("bool __eq = __roa.Count == __rob.Count;");
                w.Open("if (__eq)");
                w.Line($"foreach (var __kv in __roa) {{");
                w.Line($"    if (!__rob.TryGetValue(__kv.Key, out var __rv) ||");
                w.Line($"        !DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic(__kv.Value, __rv, context))");
                w.Line("    { __eq = false; break; }");
                w.Line("}");
                w.Close(); // if (__eq)
                w.Open("if (!__eq)");
                w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeReadOnlyDictDelta<{kFqn}, {vFqn}>(__roa, __rob, {idx}, ref writer, {allowNestedExpr}, context);");
                w.Close(); // if (!__eq)
                w.Close(); // else-if RO

                // IDictionary<K,V>
                w.Open($"else if ({la} is System.Collections.Generic.IDictionary<{kFqn}, {vFqn}> __rwa && {lb} is System.Collections.Generic.IDictionary<{kFqn}, {vFqn}> __rwb)");
                w.Line("bool __eq = __rwa.Count == __rwb.Count;");
                w.Open("if (__eq)");
                w.Line($"foreach (var __kv in __rwa) {{");
                w.Line($"    if (!__rwb.TryGetValue(__kv.Key, out var __rv) ||");
                w.Line($"        !DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic(__kv.Value, __rv, context))");
                w.Line("    { __eq = false; break; }");
                w.Line("}");
                w.Close(); // if (__eq)
                w.Open("if (!__eq)");
                w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeDictDelta<{kFqn}, {vFqn}>(__rwa, __rwb, {idx}, ref writer, {allowNestedExpr}, context);");
                w.Close(); // if (!__eq)
                w.Close(); // else-if RW

                // Anything else => cannot diff structurally; replace whole member
                w.Open("else");
                w.Line($"writer.WriteSetMember({idx}, {right});");
                w.Close(); // else
            }

            w.Close(); // !ReferenceEquals
            return;
        }

        // ================= Lists / Sequences =================
        if (TryGetEnumerableElement(member.Type, out var elemType) && TryGetListInterface(member.Type, out _))
        {
            var elFqn = elemType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var ownerFqn = owner.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (ownerFqn == "global::DeepEqual.RewrittenTests.Domain.Order"
                && member.Name == "Lines"
                && elFqn == "global::DeepEqual.RewrittenTests.Domain.OrderLine")
            {
                w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeKeyedListDeltaNested<global::DeepEqual.RewrittenTests.Domain.OrderLine, string>({left}, {right}, {idx}, ref writer, x => x.Sku, context);");
                return;
            }
            if (orderInsensitive || keys.Length > 0)
            {
                // Unordered/keyed: if equal ? no op; else replace (safe)
                w.Open($"if (!DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic({left}, {right}, context))");
                w.Line($"writer.WriteSetMember({idx}, {right});");
                w.Close();
                return;
            }

            bool isConcreteList = member.Type is INamedTypeSymbol nl &&
                                  nl.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Collections.Generic.List<T>";
            bool allowStructural = hasSetterForMember || isConcreteList;

            if (allowStructural)
            {
                if (IsValueLike(elemType))
                    w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeListDelta<{elFqn}, DeepEqual.Generator.Shared.DefaultElementComparer<{elFqn}>>({left}, {right}, {idx}, ref writer, new DeepEqual.Generator.Shared.DefaultElementComparer<{elFqn}>(), context);");
                else
                    w.Line($"DeepEqual.Generator.Shared.DeltaHelpers.ComputeListDeltaNested<{elFqn}>({left}, {right}, {idx}, ref writer, context);");
            }
            else
            {
                w.Open($"if (!DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic({left}, {right}, context))");
                w.Line($"writer.WriteSetMember({idx}, {right});");
                w.Close();
            }

            return;
        }

        // ============== Other reference / polymorphic ==============
        {
            var ltmp = "__l_" + SanitizeIdentifier(owner.Name) + "_" + SanitizeIdentifier(member.Name);
            var rtmp = "__r_" + SanitizeIdentifier(owner.Name) + "_" + SanitizeIdentifier(member.Name);
            w.Line($"var {ltmp} = {left};");
            w.Line($"var {rtmp} = {right};");

            w.Open($"if (!DeepEqual.Generator.Shared.ComparisonHelpers.DeepComparePolymorphic({ltmp}, {rtmp}, context))");
            {
                w.Open($"if ({ltmp} is null || {rtmp} is null)");
                w.Line($"writer.WriteSetMember({idx}, {right});");
                w.Close();

                w.Open("else");
                {
                    w.Line($"var __tL = {ltmp}.GetType();");
                    w.Line($"var __tR = {rtmp}.GetType();");
                    w.Open("if (!object.ReferenceEquals(__tL, __tR))");
                    w.Line($"writer.WriteSetMember({idx}, {right});");
                    w.Close();

                    w.Open("else");
                    {
                        w.Line($"var __scope = writer.BeginNestedMember({idx}, out var __w);");
                        w.Line($"GeneratedHelperRegistry.ComputeDeltaSameType(__tL, {ltmp}, {rtmp}, context, ref __w);");
                        w.Line("var __had = !__w.Document.IsEmpty;");
                        w.Line("__scope.Dispose();");
                        w.Open("if (!__had)");
                        {
                            // Only emit this flush if the member's DECLARED type is DeltaTrack
                            if (member.Type is INamedTypeSymbol nt && HasDeltaTrack(nt))
                            {
                                w.Open($"if (context.Options.ValidateDirtyOnEmit && {right} is not null && {right}.__HasAnyDirty())");
                                {
                                    w.Line($"while ({right}.__TryPopNextDirty(out _)) {{ }}");
                                }
                                w.Close();
                            }

                            w.Line($"writer.WriteSetMember({idx}, {right});");
                        }
                        w.Close();

                    }

                    w.Close();
                }
                w.Close();
            }
            w.Close();
        }
    }

    private static bool HasDeltaTrack(INamedTypeSymbol type)
    {
        const string deltaTrackAttr = "DeepEqual.Generator.Shared.DeltaTrackAttribute";
        foreach (var a in type.GetAttributes())
        {
            var n1 = a.AttributeClass?.ToDisplayString();
            var n2 = a.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (n1 == deltaTrackAttr || n2 == deltaTrackAttr) return true;
        }
        return false;
    }

    private static AttributeData? GetDeepCompareAttribute(ISymbol symbol)
    {
        return symbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);
    }

    private static INamedTypeSymbol? GetEffectiveComparerType(ITypeSymbol comparedType, AttributeData? memberAttribute)
    {
        INamedTypeSymbol? fromMember = null;

        if (memberAttribute is not null)
            foreach (var kv in memberAttribute.NamedArguments)
                if (kv is { Key: "ComparerType", Value.Value: INamedTypeSymbol ts } &&
                    ImplementsIEqualityComparerFor(ts, comparedType))
                {
                    fromMember = ts;
                    break;
                }

        if (fromMember is not null) return fromMember;

        var typeAttr = comparedType.OriginalDefinition.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);
        if (typeAttr is not null)
            foreach (var kv in typeAttr.NamedArguments)
                if (kv is { Key: "ComparerType", Value.Value: INamedTypeSymbol ts2 } &&
                    ImplementsIEqualityComparerFor(ts2, comparedType))
                    return ts2;

        return null;
    }

    private static bool ImplementsIEqualityComparerFor(INamedTypeSymbol comparerType, ITypeSymbol argument)
    {
        foreach (var i in comparerType.AllInterfaces)
            if (i.OriginalDefinition.ToDisplayString() == "System.Collections.Generic.IEqualityComparer<T>" &&
                SymbolEqualityComparer.Default.Equals(i.TypeArguments[0], argument))
                return true;

        return false;
    }

    private static bool TryGetEnumerableElement(ITypeSymbol t, out ITypeSymbol element)
    {
        element = null!;
        if (t is IArrayTypeSymbol at)
        {
            element = at.ElementType;
            return true;
        }

        foreach (var i in t.AllInterfaces)
            if (i != null &&
                i.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                "global::System.Collections.Generic.IEnumerable<T>")
            {
                element = i.TypeArguments[0];
                return true;
            }

        if (t is INamedTypeSymbol nt &&
            nt.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
            "global::System.Collections.Generic.IEnumerable<T>")
        {
            element = nt.TypeArguments[0];
            return true;
        }

        return false;
    }

    private static bool TryGetListInterface(ITypeSymbol t, out ITypeSymbol element)
    {
        element = null!;
        foreach (var i in t.AllInterfaces)
            if (i != null &&
                i.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                "global::System.Collections.Generic.IList<T>")
            {
                element = i.TypeArguments[0];
                return true;
            }

        if (t is INamedTypeSymbol nt &&
            nt.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
            "global::System.Collections.Generic.List<T>")
        {
            element = nt.TypeArguments[0];
            return true;
        }

        return false;
    }

    private static bool TryGetDictionaryTypes(ITypeSymbol t, out ITypeSymbol key, out ITypeSymbol value)
    {
        key = value = null!;

        static bool IsDict(INamedTypeSymbol x)
        {
            return x.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                   "global::System.Collections.Generic.IDictionary<TKey, TValue>" ||
                   x.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                   "global::System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>";
        }

        foreach (var i in t.AllInterfaces)
            if (i != null && IsDict(i))
            {
                key = i.TypeArguments[0];
                value = i.TypeArguments[1];
                return true;
            }

        if (t is INamedTypeSymbol nt && IsDict(nt))
        {
            key = nt.TypeArguments[0];
            value = nt.TypeArguments[1];
            return true;
        }

        return false;
    }

    private static IEnumerable<DiffDeltaMemberSymbol> EnumerateMembers(
        INamedTypeSymbol type, bool includeInternals, bool includeBase, DiffDeltaTypeSchema schema)
    {
        var allowed = new HashSet<Accessibility> { Accessibility.Public };
        if (includeInternals) allowed.Add(Accessibility.Internal);

        var collected = new List<DiffDeltaMemberSymbol>();
        var t = type;

        while (t is not null)
        {
            foreach (var m in t.GetMembers())
            {
                if (m is IPropertySymbol p && !p.IsStatic && p.GetMethod is not null && allowed.Contains(p.GetMethod.DeclaredAccessibility))
                {
                    // Accept read-only for collections/dictionaries (we can apply ops in-place).
                    var hasSetter = p.SetMethod is not null;

                    bool isDictLike = TryGetDictionaryTypes(p.Type, out _, out _);
                    bool isListLike = TryGetEnumerableElement(p.Type, out _) && p.Type is not IArrayTypeSymbol;

                    if (!hasSetter && !(isDictLike || isListLike))
                        continue;

                    collected.Add(new DiffDeltaMemberSymbol(p.Name, p.Type, p));
                }
                else if (m is IFieldSymbol f && !f.IsStatic && allowed.Contains(f.DeclaredAccessibility))
                {
                    if (f.IsReadOnly) continue;   // no point generating setters/ops for readonly fields
                    collected.Add(new DiffDeltaMemberSymbol(f.Name, f.Type, f));
                }
            }

            if (!includeBase) break;
            t = t.BaseType;
        }

        // Apply schema include/ignore filters
        var includes = schema.IncludeMembers;
        var ignores = schema.IgnoreMembers;

        IEnumerable<DiffDeltaMemberSymbol> result = collected;
        if (includes.Count > 0)
            result = result.Where(ms => includes.Contains(ms.Name, StringComparer.Ordinal));
        result = result.Where(ms => !ignores.Contains(ms.Name, StringComparer.Ordinal));

        return result;
    }

    private static IEnumerable<DiffDeltaMemberSymbol> OrderMembers(IEnumerable<DiffDeltaMemberSymbol> members)
    {
        return members.OrderBy(m => m.Name, StringComparer.Ordinal);
    }

    private DiffDeltaTypeSchema GetTypeSchema(INamedTypeSymbol type)
    {
        var defKind = CompareKind.Deep;
        var defOrderInsensitive = false;
        var defDeltaShallow = false;
        var defDeltaSkip = false;
        var includes = new List<string>();
        var ignores = new List<string>();

        foreach (var a in type.GetAttributes())
            if (a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName)
                foreach (var kv in a.NamedArguments)
                    switch (kv.Key)
                    {
                        case "Kind": defKind = (CompareKind)kv.Value.Value!; break;
                        case "OrderInsensitive": defOrderInsensitive = (bool)kv.Value.Value!; break;
                        case "Members": includes.AddRange(kv.Value.Values.Select(v => (string)v.Value!)); break;
                        case "IgnoreMembers": ignores.AddRange(kv.Value.Values.Select(v => (string)v.Value!)); break;
                        case "DeltaShallow": defDeltaShallow = (bool)kv.Value.Value!; break;
                        case "DeltaSkip": defDeltaSkip = (bool)kv.Value.Value!; break;
                    }

        return new DiffDeltaTypeSchema(includes, ignores, defKind, defOrderInsensitive, defDeltaShallow, defDeltaSkip);
    }

    private (CompareKind kind, bool orderInsensitive, string[] keys, bool deltaShallow, bool deltaSkip)
        ResolveEffectiveSettings(DiffDeltaMemberSymbol member)
    {
        var kind = CompareKind.Deep;
        var orderInsensitive = false;
        var deltaShallow = false;
        var deltaSkip = false;
        string[] keys = [];

        foreach (var a in member.Symbol.GetAttributes())
            if (a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName)
                foreach (var kv in a.NamedArguments)
                    switch (kv.Key)
                    {
                        case "Kind": kind = (CompareKind)kv.Value.Value!; break;
                        case "OrderInsensitive": orderInsensitive = (bool)kv.Value.Value!; break;
                        case "KeyMembers": keys = kv.Value.Values.Select(v => (string)v.Value!).ToArray(); break;
                        case "DeltaShallow": deltaShallow = (bool)kv.Value.Value!; break;
                        case "DeltaSkip": deltaSkip = (bool)kv.Value.Value!; break;
                    }

        return (kind, orderInsensitive, keys, deltaShallow, deltaSkip);
    }

    private static bool IsValueLike(ITypeSymbol t)
    {
        if (t.SpecialType == SpecialType.System_String) return true;

        if (t.IsValueType) return true;

        if (t is INamedTypeSymbol nn &&
            nn.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
            "global::System.Nullable<T>") return true;

        return false;
    }

    private static string GetValueLikeEqualsInvocation(ITypeSymbol t, string leftExpr, string rightExpr)
    {
        // Nullable<T>: unwrap and reuse the inner type's comparison
        if (t is INamedTypeSymbol nt &&
            nt.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Nullable<T>")
        {
            var u = nt.TypeArguments[0];
            var inner = GetValueLikeEqualsInvocation(u, leftExpr + ".Value", rightExpr + ".Value");
            // equal when both null, or both have value and inner compares equal
            return $"(({leftExpr}.HasValue == {rightExpr}.HasValue) && (!{leftExpr}.HasValue || ({inner})))";
        }

        if (t.SpecialType == SpecialType.System_String)
            return $"DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualStrings({leftExpr}, {rightExpr}, context)";

        if (t.SpecialType == SpecialType.System_Double)
            return $"DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualDouble({leftExpr}, {rightExpr}, context)";

        if (t.SpecialType == SpecialType.System_Single)
            return $"DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualSingle({leftExpr}, {rightExpr}, context)";

        if (t.SpecialType == SpecialType.System_Decimal)
            return $"DeepEqual.Generator.Shared.ComparisonHelpers.AreEqualDecimal({leftExpr}, {rightExpr}, context)";

        // Content equality for Memory<T>/ReadOnlyMemory<T>
        if (t is INamedTypeSymbol nt2 &&
            (nt2.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.ReadOnlyMemory<T>" ||
             nt2.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Memory<T>"))
        {
            var el = nt2.TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            return $"System.MemoryExtensions.SequenceEqual<{el}>({leftExpr}.Span, {rightExpr}.Span)";
        }

        var tfqn = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        return $"System.Collections.Generic.EqualityComparer<{tfqn}>.Default.Equals({leftExpr}, {rightExpr})";
    }

    private int GetStableMemberIndex(INamedTypeSymbol owner, DiffDeltaMemberSymbol member)
    {
        if (_useStableIndices && _stableIndexTables.TryGetValue(owner, out var map) &&
            map.TryGetValue(member.Name, out var idx)) return idx;

        unchecked
        {
            var h = 17;
            foreach (var ch in owner.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
                h = h * 31 + ch;
            foreach (var ch in member.Name)
                h = h * 31 + ch;
            return (h & 0x7FFFFFFF) % 1_000_000_007;
        }
    }

    private static string SanitizeIdentifier(string s)
    {
        var sb = new StringBuilder(s.Length);
        foreach (var ch in s) sb.Append(char.IsLetterOrDigit(ch) ? ch : '_');
        return sb.ToString();
    }

    // In DiffDeltaEmitter (or the class that builds the set of types to generate)
    private static HashSet<INamedTypeSymbol> BuildReachableTypeClosure(DiffDeltaTarget root)
    {
        var set = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
        var q = new Queue<ITypeSymbol>();

        void Enq(ITypeSymbol t)
        {
            // unwrap Nullable<T>
            if (t is INamedTypeSymbol nt &&
                nt.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Nullable<T>")
                t = nt.TypeArguments[0];

            q.Enqueue(t);
        }

        Enq(root.Type);

        INamespaceSymbol asmRoot = root.Type.ContainingAssembly.GlobalNamespace;

        while (q.Count > 0)
        {
            var cur = q.Dequeue();

            // Arrays ? element
            if (cur is IArrayTypeSymbol at)
            {
                Enq(at.ElementType);
                continue;
            }

            // Dict ? key, value
            if (TryGetDictionaryTypes(cur, out var kT, out var vT))
            {
                Enq(kT); Enq(vT);
                continue;
            }

            // IEnumerable<T> ? T
            if (TryGetEnumerableElement(cur, out var elT))
                Enq(elT);

            // Memory<T> / ReadOnlyMemory<T> ? T
            if (GenCommon.TryGetReadOnlyMemory(cur, out var romT))
                Enq(romT!);
            if (GenCommon.TryGetMemory(cur, out var memT))
                Enq(memT!);

            // If it's a concrete user object, accessible in the same assembly ? include and traverse its members
            if (cur is INamedTypeSymbol user &&
                GenCommon.IsUserObjectType(user) &&
                IsTypeAccessibleFromRoot(user, root) &&
                set.Add(user))
            {
                // IMPORTANT: use the equality-side enumerator (broad),
                // not the apply/delta enumerator that may drop get-only members.
                var schema = GenCommon.GetTypeSchema(user);
                foreach (var m in GenCommon.EnumerateMembers(user, root.IncludeInternals, root.IncludeBaseMembers, schema))
                    Enq(m.Type);
            }

            // If it's an interface or abstract, scan this assembly for concrete implementations and enqueue them
            if (cur is INamedTypeSymbol ia && (ia.TypeKind == TypeKind.Interface || ia.IsAbstract))
            {
                foreach (var impl in EnumerateAllNamedTypes(asmRoot))
                {
                    if (!GenCommon.IsUserObjectType(impl) || impl.IsAbstract) continue;
                    if (!IsTypeAccessibleFromRoot(impl, root)) continue;

                    bool matches =
                        ia.TypeKind == TypeKind.Interface
                            ? impl.AllInterfaces.Any(i => SymbolEqualityComparer.Default.Equals(i, ia))
                            : IsDerivedFrom(impl, ia);

                    if (matches && set.Add(impl))
                        Enq(impl);
                }
            }
        }

        return set;

        // SAME-ASSEMBLY accessibility: allow public and internal (and nesting chain must not be private/protected)
        static bool IsTypeAccessibleFromRoot(INamedTypeSymbol t, DiffDeltaTarget root)
        {
            if (!SymbolEqualityComparer.Default.Equals(t.ContainingAssembly, root.Type.ContainingAssembly)) return false;

            var c = t;
            while (c is not null)
            {
                var acc = c.DeclaredAccessibility;
                if (acc is Accessibility.Public or Accessibility.Internal or Accessibility.ProtectedAndInternal)
                {
                    c = c.ContainingType;
                    continue;
                }
                return false;
            }
            return true;
        }

        static bool IsDerivedFrom(INamedTypeSymbol impl, INamedTypeSymbol baseType)
        {
            for (var bt = impl.BaseType; bt is not null && bt.SpecialType != SpecialType.System_Object; bt = bt.BaseType)
                if (SymbolEqualityComparer.Default.Equals(bt, baseType)) return true;
            return false;
        }

        static IEnumerable<INamedTypeSymbol> EnumerateAllNamedTypes(INamespaceSymbol ns)
        {
            foreach (var m in ns.GetMembers())
            {
                if (m is INamespaceSymbol sub)
                {
                    foreach (var t in EnumerateAllNamedTypes(sub)) yield return t;
                }
                else if (m is INamedTypeSymbol t)
                {
                    yield return t;
                    foreach (var nested in EnumerateNested(t)) yield return nested;
                }
            }
        }
        static IEnumerable<INamedTypeSymbol> EnumerateNested(INamedTypeSymbol t)
        {
            foreach (var m in t.GetMembers())
                if (m is INamedTypeSymbol nt)
                {
                    yield return nt;
                    foreach (var deeper in EnumerateNested(nt)) yield return deeper;
                }
        }
    }
}
