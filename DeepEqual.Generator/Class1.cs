// DeepEqual.Generator/DeepEqualGenerator.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DeepEqual.Generator;

[Generator(LanguageNames.CSharp)]
public sealed class DeepEqualGenerator : IIncrementalGenerator
{
    private const string DeepComparableAttributeName = "DeepEqual.Generator.Attributes.DeepComparableAttribute";
    private const string DeepCompareAttributeName = "DeepEqual.Generator.Attributes.DeepCompareAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var candidates = context.SyntaxProvider.CreateSyntaxProvider(
            static (node, _) => node is TypeDeclarationSyntax { AttributeLists.Count: > 0 },
            static (ctx, _) => GetTarget(ctx)
        ).Where(t => t is not null);

        var inputs = candidates.Combine(context.CompilationProvider);

        context.RegisterSourceOutput(inputs, static (spc, pair) =>
        {
            var (target, compilation) = pair;
            if (target is null)
            {
                return;
            }

            EmitForRoot(spc, target.Value, compilation);
        });
    }

    private static Target? GetTarget(GeneratorSyntaxContext context)
    {
        if (context.Node is not TypeDeclarationSyntax typeSyntax)
        {
            return null;
        }

        if (context.SemanticModel.GetDeclaredSymbol(typeSyntax) is not INamedTypeSymbol typeSymbol)
        {
            return null;
        }

        var deepComparable = typeSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepComparableAttributeName);

        if (deepComparable is null)
        {
            return null;
        }

        var includeInternals = GetNamedBool(deepComparable, "IncludePrivateMembers"); // treated as "include internals"
        var orderInsensitiveCollections = GetNamedBool(deepComparable, "OrderInsensitiveCollections");

        return new Target(typeSymbol, includeInternals, orderInsensitiveCollections);
    }

    private static bool GetNamedBool(AttributeData attribute, string name)
    {
        foreach (var kv in attribute.NamedArguments)
        {
            if (kv.Key == name && kv.Value.Value is true)
            {
                return true;
            }
        }
        return false;
    }

    private static void EmitForRoot(SourceProductionContext spc, Target root, Compilation compilation)
    {
        var ns = root.Type.ContainingNamespace.IsGlobalNamespace ? null : root.Type.ContainingNamespace.ToDisplayString();
        var rootFullName = root.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var rootName = root.Type.Name;
        var helperClassName = $"{rootName}DeepEqual";
        var hintName = SanitizeFileName($"{rootFullName}_DeepEqual.g.cs");

        var reachableTypes = BuildReachableTypeClosure(compilation, root);

        var code = new StringBuilder();
        code.AppendLine("// <auto-generated />");
        code.AppendLine("#nullable enable");
        code.AppendLine("using System;");
        code.AppendLine("using System.Collections.Generic;");
        code.AppendLine("using DeepEqual.Generator.Attributes;");

        if (ns is not null)
        {
            code.AppendLine($"namespace {ns}");
            code.AppendLine("{");
        }

        code.AppendLine($"    public static class {helperClassName}");
        code.AppendLine("    {");
        code.AppendLine(root.Type.IsValueType
            ? $"        public static bool AreDeepEqual({rootFullName} left, {rootFullName} right)"
            : $"        public static bool AreDeepEqual({rootFullName}? left, {rootFullName}? right)");
        code.AppendLine("        {");
        if (!root.Type.IsValueType)
        {
            code.AppendLine("            if (object.ReferenceEquals(left, right)) { return true; }");
            code.AppendLine("            if (left is null || right is null) { return false; }");
        }
        code.AppendLine("            var comparisonContext = new ComparisonContext();");
        code.AppendLine($"            return {GetHelperMethodName(root.Type)}(left, right, comparisonContext);");
        code.AppendLine("        }");
        code.AppendLine();

        foreach (var type in reachableTypes.OrderBy(t => t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), StringComparer.Ordinal))
        {
            EmitHelperForType(code, type, root, compilation);
        }

        code.AppendLine("    }");

        if (ns is not null)
        {
            code.AppendLine("}");
        }

        spc.AddSource(hintName, code.ToString());
    }

    private static void EmitHelperForType(StringBuilder code, INamedTypeSymbol type, Target root, Compilation compilation)
    {
        var fullName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var helperName = GetHelperMethodName(type);

        code.AppendLine($"        private static bool {helperName}({fullName} left, {fullName} right, ComparisonContext context)");
        code.AppendLine("        {");
        if (!type.IsValueType)
        {
            code.AppendLine("            if (object.ReferenceEquals(left, right)) { return true; }");
            code.AppendLine("            if (left is null || right is null) { return false; }");
            code.AppendLine("            if (!context.Enter(left, right)) { return true; }");
        }

        foreach (var member in EnumerateComparableMembers(type, root.IncludeInternals).OrderBy(m => m.Name, StringComparer.Ordinal))
        {
            EmitMemberComparison(code, member, root, compilation);
        }

        if (!type.IsValueType)
        {
            code.AppendLine("            context.Exit(left, right);");
        }

        code.AppendLine("            return true;");
        code.AppendLine("        }");
        code.AppendLine();
    }

    private static IEnumerable<MemberSymbol> EnumerateComparableMembers(INamedTypeSymbol type, bool includeInternals)
    {
        static bool IsAccessibleFromHelper(ISymbol symbol, bool includeInternalsFlag)
        {
            return symbol.DeclaredAccessibility switch
            {
                Accessibility.Public => true,
                Accessibility.Internal => includeInternalsFlag,
                Accessibility.ProtectedAndInternal => includeInternalsFlag,
                _ => false
            };
        }

        foreach (var prop in type.GetMembers().OfType<IPropertySymbol>())
        {
            if (prop.IsStatic)
            {
                continue;
            }
            if (prop.Parameters.Length != 0)
            {
                continue;
            }
            if (!IsAccessibleFromHelper(prop, includeInternals))
            {
                continue;
            }
            if (prop.GetMethod is null)
            {
                continue;
            }

            yield return new MemberSymbol(prop.Name, prop.Type, prop);
        }

        foreach (var field in type.GetMembers().OfType<IFieldSymbol>())
        {
            if (field.IsStatic)
            {
                continue;
            }
            if (field.IsConst)
            {
                continue;
            }
            if (field.IsImplicitlyDeclared)
            {
                continue;
            }
            if (field.AssociatedSymbol is not null)
            {
                continue;
            }
            if (field.Name.StartsWith("<", StringComparison.Ordinal))
            {
                continue;
            }
            if (!IsAccessibleFromHelper(field, includeInternals))
            {
                continue;
            }

            yield return new MemberSymbol(field.Name, field.Type, field);
        }
    }

    private static void EmitMemberComparison(StringBuilder code, MemberSymbol member, Target root, Compilation compilation)
    {
        var leftAccess = $"left.{member.Name}";
        var rightAccess = $"right.{member.Name}";
        var memberType = member.Type;

        var deepCompareAttr = GetDeepCompareAttribute(member.Symbol);
        var comparisonKind = GetEffectiveKind(memberType, deepCompareAttr);

        var localBase = $"member_{member.Name}";
        var leftLocal = $"{localBase}_left";
        var rightLocal = $"{localBase}_right";

        code.AppendLine($"            var {leftLocal} = {leftAccess};");
        code.AppendLine($"            var {rightLocal} = {rightAccess};");

        if (comparisonKind == EffectiveKind.Skip)
        {
            return;
        }

        if (!memberType.IsValueType)
        {
            code.AppendLine($"            if (!object.ReferenceEquals({leftLocal}, {rightLocal}))");
            code.AppendLine("            {");
            code.AppendLine($"                if ({leftLocal} is null || {rightLocal} is null) {{ return false; }}");
            code.AppendLine("            }");
        }

        if (comparisonKind == EffectiveKind.Reference)
        {
            code.AppendLine(memberType.IsReferenceType
                ? $"            if (!object.ReferenceEquals({leftLocal}, {rightLocal})) {{ return false; }}"
                : $"            if (!{leftLocal}.Equals({rightLocal})) {{ return false; }}");
            return;
        }

        if (comparisonKind == EffectiveKind.Shallow)
        {
            if (memberType.SpecialType == SpecialType.System_String)
            {
                code.AppendLine($"            if (!ComparisonHelpers.AreEqualStrings({leftLocal}, {rightLocal})) {{ return false; }}");
            }
            else if (memberType.IsValueType)
            {
                code.AppendLine($"            if (!{leftLocal}.Equals({rightLocal})) {{ return false; }}");
            }
            else
            {
                code.AppendLine($"            if (!object.Equals({leftLocal}, {rightLocal})) {{ return false; }}");
            }
            return;
        }

        if (memberType.SpecialType == SpecialType.System_String)
        {
            code.AppendLine($"            if (!ComparisonHelpers.AreEqualStrings({leftLocal}, {rightLocal})) {{ return false; }}");
            return;
        }

        if (memberType.TypeKind == TypeKind.Enum)
        {
            code.AppendLine($"            if (!ComparisonHelpers.AreEqualEnum({leftLocal}, {rightLocal})) {{ return false; }}");
            return;
        }

        if (memberType.IsValueType && memberType.SpecialType != SpecialType.None)
        {
            code.AppendLine($"            if (!{leftLocal}.Equals({rightLocal})) {{ return false; }}");
            return;
        }

        if (memberType is IArrayTypeSymbol arrayType)
        {
            var elementType = arrayType.ElementType;
            var elementKind = GetEffectiveKind(elementType, null);
            var unordered = ResolveOrderInsensitive(root, deepCompareAttr, elementType);
            var elementLambda = BuildElementComparerLambda(compilation, elementType, elementKind);
            var api = unordered ? "AreEqualSequencesUnordered" : "AreEqualSequencesOrdered";
            var elementFullName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            code.AppendLine($"            if (!ComparisonHelpers.{api}<{elementFullName}>({leftLocal}, {rightLocal}, {elementLambda}, context)) {{ return false; }}");
            return;
        }

        if (TryGetDictionaryInterface(memberType, out var keyType, out var valueType))
        {
            var keyFullName = keyType!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var valueFullName = valueType!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var valueKind = GetEffectiveKind(valueType, null);
            var valueLambda = BuildElementComparerLambda(compilation, valueType, valueKind);

            code.AppendLine($"            if (!ComparisonHelpers.AreEqualDictionaries<{keyFullName}, {valueFullName}>(");
            code.AppendLine($"                {leftLocal} as global::System.Collections.Generic.IDictionary<{keyFullName}, {valueFullName}>,");
            code.AppendLine($"                {rightLocal} as global::System.Collections.Generic.IDictionary<{keyFullName}, {valueFullName}> ,");
            code.AppendLine($"                {valueLambda}, context)) {{ return false; }}");
            return;
        }

        if (TryGetEnumerableInterface(memberType, out var enumerableElementType))
        {
            var elementKind = GetEffectiveKind(enumerableElementType!, null);
            var unordered = ResolveOrderInsensitive(root, deepCompareAttr, enumerableElementType!);
            var elementLambda = BuildElementComparerLambda(compilation, enumerableElementType!, elementKind);
            var api = unordered ? "AreEqualSequencesUnordered" : "AreEqualSequencesOrdered";
            var elementFullName = enumerableElementType!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            code.AppendLine($"            if (!ComparisonHelpers.{api}<{elementFullName}>(");
            code.AppendLine($"                {leftLocal} as global::System.Collections.Generic.IEnumerable<{elementFullName}>,");
            code.AppendLine($"                {rightLocal} as global::System.Collections.Generic.IEnumerable<{elementFullName}>,");
            code.AppendLine($"                {elementLambda}, context)) {{ return false; }}");
            return;
        }

        if (memberType is INamedTypeSymbol namedType)
        {
            if (IsUserObjectType(namedType) && IsFromCurrentCompilation(namedType, compilation))
            {
                code.AppendLine($"            if (!{GetHelperMethodName(namedType)}({leftLocal}, {rightLocal}, context)) {{ return false; }}");
            }
            else
            {
                code.AppendLine($"            if (!object.Equals({leftLocal}, {rightLocal})) {{ return false; }}");
            }
            return;
        }

        code.AppendLine($"            if (!object.Equals({leftLocal}, {rightLocal})) {{ return false; }}");
    }

    private static string BuildElementComparerLambda(Compilation compilation, ITypeSymbol elementType, EffectiveKind elementKind)
    {
        if (elementType.SpecialType == SpecialType.System_String)
        {
            return "(l, r, c) => object.ReferenceEquals(l, r) ? true : (l is null || r is null ? false : ComparisonHelpers.AreEqualStrings(l, r))";
        }

        if (elementType.TypeKind == TypeKind.Enum)
        {
            return "(l, r, c) => ComparisonHelpers.AreEqualEnum(l, r)";
        }

        if (elementType.IsValueType && elementType.SpecialType != SpecialType.None)
        {
            return "(l, r, c) => l.Equals(r)";
        }

        if (elementKind == EffectiveKind.Shallow)
        {
            return "(l, r, c) => object.Equals(l, r)";
        }

        if (elementKind == EffectiveKind.Reference)
        {
            return "(l, r, c) => object.ReferenceEquals(l, r)";
        }

        if (elementType is INamedTypeSymbol nts && IsUserObjectType(nts) && IsFromCurrentCompilation(nts, compilation))
        {
            var helper = GetHelperMethodName(nts);
            return $"(l, r, c) => object.ReferenceEquals(l, r) ? true : (l is null || r is null ? false : {helper}(l, r, c))";
        }

        return "(l, r, c) => object.Equals(l, r)";
    }

    private static HashSet<INamedTypeSymbol> BuildReachableTypeClosure(Compilation compilation, Target root)
    {
        var set = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
        var queue = new Queue<INamedTypeSymbol>();

        set.Add(root.Type);
        queue.Enqueue(root.Type);

        while (queue.Count > 0)
        {
            var current = queue.Dequeue();

            foreach (var member in EnumerateComparableMembers(current, root.IncludeInternals))
            {
                var kind = GetEffectiveKind(member.Type, GetDeepCompareAttribute(member.Symbol));
                if (kind == EffectiveKind.Skip || kind == EffectiveKind.Shallow || kind == EffectiveKind.Reference)
                {
                    continue;
                }

                Accumulate(member.Type);
            }
        }

        return set;

        void Accumulate(ITypeSymbol type)
        {
            if (type is IArrayTypeSymbol arrayType)
            {
                Accumulate(arrayType.ElementType);
                return;
            }

            if (TryGetDictionaryInterface(type, out _, out var valueType))
            {
                Accumulate(valueType!);
                return;
            }

            if (TryGetEnumerableInterface(type, out var elementType))
            {
                Accumulate(elementType!);
                return;
            }

            if (type is INamedTypeSymbol named && IsUserObjectType(named) && IsFromCurrentCompilation(named, compilation) && set.Add(named))
            {
                queue.Enqueue(named);
            }
        }
    }

    private static bool TryGetEnumerableInterface(ITypeSymbol type, out ITypeSymbol? elementType)
    {
        foreach (var i in type.AllInterfaces)
        {
            if (i.OriginalDefinition.ToDisplayString() == "System.Collections.Generic.IEnumerable<T>")
            {
                elementType = i.TypeArguments[0];
                return true;
            }
        }

        elementType = null;
        return false;
    }

    private static bool TryGetDictionaryInterface(ITypeSymbol type, out ITypeSymbol? keyType, out ITypeSymbol? valueType)
    {
        foreach (var i in type.AllInterfaces)
        {
            if (i.OriginalDefinition.ToDisplayString() == "System.Collections.Generic.IDictionary<TKey, TValue>")
            {
                keyType = i.TypeArguments[0];
                valueType = i.TypeArguments[1];
                return true;
            }
        }

        keyType = null;
        valueType = null;
        return false;
    }

    private static string GetHelperMethodName(INamedTypeSymbol type)
    {
        var fullName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        return $"AreDeepEqual__{SanitizeIdentifier(fullName)}";
    }

    private static string SanitizeIdentifier(string value)
    {
        var sb = new StringBuilder(value.Length + 8);
        foreach (var ch in value)
        {
            sb.Append(char.IsLetterOrDigit(ch) ? ch : '_');
        }
        return sb.ToString();
    }

    private static string SanitizeFileName(string value)
    {
        var invalid = System.IO.Path.GetInvalidFileNameChars();
        var arr = value.Select(ch => invalid.Contains(ch) ? '_' : ch).ToArray();
        return new string(arr);
    }

    private static AttributeData? GetDeepCompareAttribute(ISymbol symbol)
    {
        return symbol.GetAttributes().FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);
    }

    private enum EffectiveKind { Deep = 0, Shallow = 1, Reference = 2, Skip = 3 }

    private static EffectiveKind GetEffectiveKind(ITypeSymbol type, AttributeData? memberAttribute)
    {
        if (memberAttribute is not null)
        {
            var val = memberAttribute.NamedArguments.FirstOrDefault(p => p.Key == "Kind").Value.Value;
            if (val is int mk)
            {
                return (EffectiveKind)mk;
            }
        }

        var typeAttr = type.OriginalDefinition.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);

        if (typeAttr is not null)
        {
            var val = typeAttr.NamedArguments.FirstOrDefault(p => p.Key == "Kind").Value.Value;
            if (val is int tk)
            {
                return (EffectiveKind)tk;
            }
        }

        return EffectiveKind.Deep;
    }

    private static bool ResolveOrderInsensitive(Target root, AttributeData? memberAttribute, ITypeSymbol elementType)
    {
        if (memberAttribute is not null)
        {
            var opt = memberAttribute.NamedArguments.FirstOrDefault(a => a.Key == "OrderInsensitive").Value;
            if (opt.Value is bool b)
            {
                return b;
            }
        }

        var typeAttr = elementType.OriginalDefinition.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == DeepCompareAttributeName);

        if (typeAttr is not null)
        {
            var opt = typeAttr.NamedArguments.FirstOrDefault(a => a.Key == "OrderInsensitive").Value;
            if (opt.Value is bool b)
            {
                return b;
            }
        }

        return root.OrderInsensitiveCollections;
    }

    private static bool IsFromCurrentCompilation(INamedTypeSymbol symbol, Compilation compilation)
    {
        return SymbolEqualityComparer.Default.Equals(symbol.ContainingAssembly, compilation.Assembly);
    }

    private static bool IsUserObjectType(ITypeSymbol type)
    {
        return (type.TypeKind is TypeKind.Class or TypeKind.Struct) &&
               type.SpecialType == SpecialType.None &&
               type is not IArrayTypeSymbol;
    }

    private readonly record struct Target(
        INamedTypeSymbol Type,
        bool IncludeInternals,
        bool OrderInsensitiveCollections
    );

    private readonly record struct MemberSymbol(
        string Name,
        ITypeSymbol Type,
        ISymbol Symbol
    );
}