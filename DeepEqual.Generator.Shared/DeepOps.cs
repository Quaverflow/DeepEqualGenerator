// <auto-generated/>
#nullable enable
using System;
using DeepEqual.Generator.Shared;

namespace DeepEqual
{
    /// <summary>
    /// Runtime object facade that dispatches by runtime type via the generated registry.
    /// </summary>
    public static class DeepOps
    {
        public static bool AreEqual(object? a, object? b, ComparisonOptions? opts = null)
        {
            var ctx = opts is null ? new ComparisonContext() : new ComparisonContext(opts);
            if (ReferenceEquals(a, b)) return true;
            if (a is null || b is null) return false;

            var ta = a.GetType();
            if (!ReferenceEquals(ta, b.GetType())) return false;

            if (GeneratedHelperRegistry.TryCompareSameType(ta, a, b, ctx, out var eq))
                return eq;

            // Fallback: value-like compare & dynamic container support
            return DynamicDeepComparer.AreEqualDynamic(a, b, ctx);
        }
        private static (bool has, DeepEqual.Generator.Shared.IDiff diff)
            GetDiffCore(object? a, object? b, DeepEqual.Generator.Shared.ComparisonContext ctx)
        {
            if (ReferenceEquals(a, b)) return (false, DeepEqual.Generator.Shared.Diff.Empty);

            if (a is null && b is not null) return (true, DeepEqual.Generator.Shared.Diff<object>.Replacement(b));
            if (a is not null && b is null) return (true, DeepEqual.Generator.Shared.Diff<object>.Replacement(b));

            var ta = a!.GetType();
            var tb = b!.GetType();
            if (!ReferenceEquals(ta, tb))
                return (true, DeepEqual.Generator.Shared.Diff<object>.Replacement(b));

            if (DeepEqual.Generator.Shared.GeneratedHelperRegistry.TryGetDiffSameType(ta, a, b, ctx, out var id))
                return (!id.IsEmpty, id);

            var equal = AreEqual(a, b, ctx.Options);
            return equal
                ? (false, DeepEqual.Generator.Shared.Diff.Empty)
                : (true, DeepEqual.Generator.Shared.Diff<object>.Replacement(b));
        }

        public static (bool has, DeepEqual.Generator.Shared.IDiff diff)
            GetDiff(object? a, object? b, DeepEqual.Generator.Shared.ComparisonOptions? opts = null)
        {
            var ctx = opts is null ? new DeepEqual.Generator.Shared.ComparisonContext()
                : new DeepEqual.Generator.Shared.ComparisonContext(opts);
            return GetDiffCore(a, b, ctx);
        }

        public static (bool has, DeepEqual.Generator.Shared.IDiff diff)
            GetDiff(object? a, object? b, DeepEqual.Generator.Shared.ComparisonContext? ctx)
        {
            return GetDiffCore(a, b, ctx ?? new DeepEqual.Generator.Shared.ComparisonContext());
        }


        public static DeltaDocument ComputeDelta(object? a, object? b, ComparisonOptions? opts = null)
        {
            var ctx = opts is null ? new ComparisonContext() : new ComparisonContext(opts);
            var doc = new DeltaDocument();
            var w = new DeltaWriter(doc);

            if (ReferenceEquals(a, b)) return doc;

            var ta = a?.GetType();
            var tb = b?.GetType();
            if (ta is null || tb is null || !ReferenceEquals(ta, tb))
            {
                w.WriteReplaceObject(b);
                return doc;
            }

            GeneratedHelperRegistry.ComputeDeltaSameType(ta, a, b, ctx, ref w);
            return doc;
        }

        public static void ApplyDelta(ref object? target, DeltaDocument delta, ComparisonOptions? opts = null)
        {
            var reader = new DeltaReader(delta);
            if (target is null) return;

            var t = target.GetType();
            if (!GeneratedHelperRegistry.TryApplyDeltaSameType(t, ref target, ref reader))
            {
                // nothing registered â€“ best we can do is full replace if present
                foreach (ref readonly var op in reader.AsSpan())
                {
                    if (op.Kind == DeltaKind.ReplaceObject)
                    {
                        target = op.Value;
                        break;
                    }
                }
            }
        }
    }
}