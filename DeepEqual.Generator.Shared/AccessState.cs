// <auto-generated/>
#nullable enable
using System;
using System.Buffers;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.Json;
using System.Threading;

namespace DeepEqual.Generator.Shared
{
    [Flags]
    public enum AccessMemberFlags : byte
    {
        None = 0,
        Track = 1 << 0,
        Counts = 1 << 1,
        Last = 1 << 2,
        Caller = 1 << 3,
    }

    [Flags]
    public enum AccessLogPolicy : byte
    {
        None = 0,
        Allowed = 1 << 0,
        Forced = 1 << 1,
    }

    public sealed class AccessDescriptor
    {
        public AccessDescriptor(
            string typeName,
            string[] memberNames,
            AccessMemberFlags[] memberFlags,
            AccessLogPolicy[] memberLogPolicies,
            int typeLogCapacity,
            int[] memberForcedLogCapacities)
        {
            ArgumentNullException.ThrowIfNull(typeName);
            ArgumentNullException.ThrowIfNull(memberNames);
            ArgumentNullException.ThrowIfNull(memberFlags);
            ArgumentNullException.ThrowIfNull(memberLogPolicies);
            ArgumentNullException.ThrowIfNull(memberForcedLogCapacities);

            if (memberNames.Length != memberFlags.Length || memberNames.Length != memberLogPolicies.Length || memberNames.Length != memberForcedLogCapacities.Length)
                throw new ArgumentException("Access descriptor arrays must have matching length.");

            TypeName = typeName;
            MemberNames = memberNames;
            MemberFlags = memberFlags;
            MemberLogPolicies = memberLogPolicies;
            MemberForcedLogCapacities = memberForcedLogCapacities;
            TypeLogCapacity = typeLogCapacity;
            MemberCount = memberNames.Length;

            var combined = AccessMemberFlags.None;
            var tracked = 0;
            for (var i = 0; i < memberFlags.Length; i++)
            {
                combined |= memberFlags[i];
                if ((memberFlags[i] & AccessMemberFlags.Track) != 0) tracked++;
            }

            CombinedFlags = combined;
            TrackedMemberCount = tracked;
        }

        public string TypeName { get; }
        public string[] MemberNames { get; }
        public AccessMemberFlags[] MemberFlags { get; }
        public AccessLogPolicy[] MemberLogPolicies { get; }
        public int[] MemberForcedLogCapacities { get; }
        public int TypeLogCapacity { get; }
        public int MemberCount { get; }
        public int TrackedMemberCount { get; }
        public AccessMemberFlags CombinedFlags { get; }
        public bool HasTrackedMembers => TrackedMemberCount > 0;
    }

    public readonly struct MappingInfo
    {
        public MappingInfo(string typeName, string[] memberNames) { TypeName = typeName; MemberNames = memberNames; }
        public string TypeName { get; }
        public string[] MemberNames { get; }
    }

    public enum EventValueKind : byte { None = 0, Scalar = 1, String = 2, Collection = 3 }

    internal sealed class CollectionValue
    {
        public string TypeName = "";
        public int Count;
        public bool Truncated;
        public Array? Full;
        public Array? Head;
        public Array? Tail;
    }

    public readonly struct AccessEvent
    {
        public AccessEvent(ushort memberIndex, long ticks, int callerId, EventValueKind valueKind, object? oldVal, object? newVal)
        { MemberIndex = memberIndex; Ticks = ticks; CallerId = callerId; ValueKind = valueKind; OldValue = oldVal; NewValue = newVal; }
        public ushort MemberIndex { get; }
        public long Ticks { get; }
        public int CallerId { get; }
        public EventValueKind ValueKind { get; }
        public object? OldValue { get; }
        public object? NewValue { get; }
    }

    internal struct AccessTopEntry { public int CallerId; public int Count; }

    public struct AccessState
    {
#if ACCESS_TRACK
        private const int TopK = 4;

        private AccessDescriptor? _descriptor;
        private int _appliedConfigVersion;
        private int _instanceId;
        private DateTimeOffset _since;
        private long _sinceTicks;

        private ulong _writeBits0;
        private ulong[]? _writeBitsEx;

#if ACCESS_TRACK_COUNTS
        private int[]? _counts;
#endif
#if ACCESS_TRACK_LAST
        private long[]? _last;
#endif
        private AccessTopEntry[]? _topCallers;

#if ACCESS_TRACK_LOG
        private AccessEvent[]? _log;
        private bool[]? _logMembers;
        private int _logCursor;
        private int _logCount;

        private IMemberAccessor[]? _accessors;
        private object?[]? _lastSnapshots;

        private long _snapshotBudgetBytes;
        private bool _budgetExceeded;
#endif
        private object? _owner;

        public void EnsureConfigured(AccessDescriptor descriptor, object owner)
        {
            _descriptor = descriptor;
            var current = AccessTracking.ConfigurationVersion;
            if (_appliedConfigVersion == current && _owner is not null) return;
            ApplyConfiguration(owner);
            _appliedConfigVersion = current;
        }

        private void ApplyConfiguration(object owner)
        {
            _owner = owner;
            _instanceId = RuntimeHelpers.GetHashCode(owner);
            _since = DateTimeOffset.UtcNow;
            _sinceTicks = Stopwatch.GetTimestamp();

            var d = _descriptor!;
            var n = d.MemberCount;

            if (n <= 64) _writeBitsEx = null;
            else
            {
                var extra = (n - 64 + 63) / 64;
                _writeBitsEx = _writeBitsEx is { Length: var ex } && ex == extra ? _writeBitsEx : new ulong[extra];
            }
            _writeBits0 = 0;

#if ACCESS_TRACK_COUNTS
            _counts = AccessTracking.CountsEnabled && d.HasTrackedMembers ? (_counts is { Length: var lc } && lc == n ? _counts : new int[n]) : null;
#endif
#if ACCESS_TRACK_LAST
            _last = AccessTracking.LastEnabled && d.HasTrackedMembers ? (_last is { Length: var ll } && ll == n ? _last : new long[n]) : null;
#endif
            _topCallers = AccessTracking.CallersEnabled && d.HasTrackedMembers
                ? (_topCallers is { Length: var tlen } && tlen == n * TopK ? _topCallers : new AccessTopEntry[n * TopK])
                : null;

#if ACCESS_TRACK_LOG
            // include global default when the descriptor has 0
            var forcedPerMember = (d.MemberForcedLogCapacities.Length > 0)
                ? d.MemberForcedLogCapacities.Max()
                : 0;

            // if the type-level capacity is zero, use the global default
            var typeOrGlobal = d.TypeLogCapacity > 0 ? d.TypeLogCapacity : AccessTracking.DefaultLogCapacity;

            // final capacity is the max of (type/global) and any forced per-member capacity
            var cap = Math.Max(typeOrGlobal, forcedPerMember);

            if (AccessTracking.LogEnabled && cap > 0 && d.HasTrackedMembers)
            {
                _log = _log is { Length: var c } && c == cap ? _log : new AccessEvent[cap];
                _logCursor = 0;
                _logCount = 0;

                _logMembers = _logMembers is { Length: var lm } && lm == n ? _logMembers : new bool[n];
                for (var i = 0; i < n; i++)
                {
                    var p = d.MemberLogPolicies[i];
                    var isTracked = (d.MemberFlags[i] & AccessMemberFlags.Track) != 0;

                    // Treat None as allowed when effective cap > 0, so global config works.
                    var policyAllows = p == AccessLogPolicy.Forced
                                       || p == AccessLogPolicy.Allowed
                                       || p == AccessLogPolicy.None;

                    _logMembers[i] = isTracked && policyAllows && cap > 0;
                }
                _accessors = BuildAccessors(owner.GetType(), d.MemberNames);
                _lastSnapshots = _lastSnapshots is { Length: var ls } && ls == n ? _lastSnapshots : new object?[n];

                _snapshotBudgetBytes = AccessTracking.SnapshotByteBudgetPerInstanceDef;
                _budgetExceeded = false;
            }
            else
            {
                _log = null;
                _logMembers = null;
                _accessors = null;
                _lastSnapshots = null;
                _logCursor = _logCount = 0;
                _snapshotBudgetBytes = 0;
                _budgetExceeded = false;
            }
#endif
        }

        public void RecordWrite(int memberIndex)
        {
            var d = _descriptor;
            if (d is null) return;
            if ((uint)memberIndex >= (uint)d.MemberCount) return;

            var flags = d.MemberFlags[memberIndex];
            if ((flags & AccessMemberFlags.Track) == 0) return;

            var mask = AccessTracking.EnabledFeatures;
            if ((mask & AccessMemberFlags.Track) == 0) return;

            SetWriteBit(memberIndex);

#if ACCESS_TRACK_COUNTS
            if ((flags & AccessMemberFlags.Counts) != 0 && (mask & AccessMemberFlags.Counts) != 0 && _counts is { } counts)
            {
                Interlocked.Increment(ref counts[memberIndex]);
            }
#endif
#if ACCESS_TRACK_LAST
            if ((flags & AccessMemberFlags.Last) != 0 && (mask & AccessMemberFlags.Last) != 0 && _last is { } last)
            {
                last[memberIndex] = Stopwatch.GetTimestamp();
            }
#endif
            if ((mask & AccessMemberFlags.Caller) != 0 && _topCallers is { } top)
            {
                // NEW: attribute write to ALL active scopes (inner -> outer), not just the innermost
                Span<int> ids = stackalloc int[8];
                var n = AccessTracking.EnumerateActiveCallers(ids);
                for (int i = 0; i < n; i++)
                {
                    var caller = ids[i];
                    if (caller > 0) UpdateTopK(top, memberIndex, caller);
                }
            }

#if ACCESS_TRACK_LOG
            if (_log is not null && _logMembers is { } allow && allow[memberIndex] && _accessors is { } getters)
            {
                var getter = getters[memberIndex];
                object? newVal = null;
                try { newVal = getter.Get(_owner!); } catch { /* ignore */ }

                var oldSnap = _lastSnapshots![memberIndex];
                var newSnap = CreateSnapshot(newVal, ref _snapshotBudgetBytes, out var kind);

                _lastSnapshots[memberIndex] = newSnap;
                AppendEvent(memberIndex, kind, oldSnap, newSnap);
            }
#endif
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void SetWriteBit(int idx)
        {
            if (idx < 64) { Volatile.Write(ref _writeBits0, _writeBits0 | (1UL << idx)); return; }
            var exIndex = (idx - 64) >> 6;
            var bit = 1UL << ((idx - 64) & 63);
            _writeBitsEx![exIndex] |= bit;
        }

        private static void UpdateTopK(AccessTopEntry[] table, int memberIndex, int callerId)
        {
            const int K = TopK;
            var start = memberIndex * K;
            var minIdx = start;
            var minCount = int.MaxValue;

            for (var i = 0; i < K; i++)
            {
                ref var e = ref table[start + i];
                if (e.CallerId == callerId) { e.Count++; return; }
                if (e.CallerId == 0) { e.CallerId = callerId; e.Count = 1; return; }
                if (e.Count < minCount) { minCount = e.Count; minIdx = start + i; }
            }

            table[minIdx].CallerId = callerId;
            table[minIdx].Count = 1;
        }

#if ACCESS_TRACK_LOG
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void AppendEvent(int memberIndex, EventValueKind kind, object? oldSnap, object? newSnap)
        {
            var ev = new AccessEvent(
                memberIndex: (ushort)memberIndex,
                ticks: Stopwatch.GetTimestamp(),
                callerId: AccessTracking.CurrentCallerId, // innermost scope for the event
                valueKind: kind,
                oldVal: oldSnap,
                newVal: newSnap);

            var buf = _log!;
            var cursor = _logCursor;
            buf[cursor] = ev;
            _logCursor = (cursor + 1) % buf.Length;
            if (_logCount < buf.Length) _logCount++;
        }
#endif

        public string DumpJson(in MappingInfo map, int? topN = null, bool reset = false)
        {
            var d = _descriptor;
            if (d is null) return "{}";

            var options = new JsonWriterOptions { Indented = false, SkipValidation = true };
             var buffer = new ArrayBufferWriter<byte>(16 * 1024);
            using (var writer = new Utf8JsonWriter(buffer, options))
            {
                writer.WriteStartObject();

                writer.WriteString("type", map.TypeName);
                writer.WriteNumber("instance", _instanceId);
                writer.WriteBoolean("enabled", AccessTracking.IsTrackingEnabled);
                writer.WriteString("since", _since.ToString("O"));
#if ACCESS_TRACK_LOG
                writer.WriteNumber("logCapacity", _log?.Length ?? 0);
                writer.WriteBoolean("budgetExceeded", _budgetExceeded);
#else
                writer.WriteNumber("logCapacity", 0);
                writer.WriteBoolean("budgetExceeded", false);
#endif

                writer.WritePropertyName("members");
                writer.WriteStartArray();
                for (var i = 0; i < d.MemberCount; i++)
                {
                    var flags = d.MemberFlags[i];
                    writer.WriteStartObject();
                    writer.WriteString("name", map.MemberNames[i]);
                    writer.WriteBoolean("tracked", (flags & AccessMemberFlags.Track) != 0);
                    writer.WriteBoolean("written", GetWriteBit(i));
#if ACCESS_TRACK_COUNTS
                    if ((flags & AccessMemberFlags.Counts) != 0 && AccessTracking.CountsEnabled && _counts is { } counts)
                        writer.WriteNumber("count", counts[i]);
#endif
#if ACCESS_TRACK_LAST
                    if ((flags & AccessMemberFlags.Last) != 0 && AccessTracking.LastEnabled && _last is { } last)
                    {
                        var t = last[i];
                        writer.WriteString("last", t == 0
                            ? "—"
                            : (_since + TimeSpan.FromSeconds((t - _sinceTicks) / (double)Stopwatch.Frequency)).ToString("O"));
                    }
#endif
                    if (AccessTracking.CallersEnabled && _topCallers is { } top)
                    {
                        writer.WritePropertyName("callers");
                        writer.WriteStartArray();
                        var start = i * TopK;
                        for (var k = 0; k < TopK; k++)
                        {
                            var e = top[start + k];
                            if (e.CallerId == 0) continue;
                            writer.WriteStartObject();
                            writer.WriteNumber("id", e.CallerId);
                            writer.WriteNumber("count", e.Count);
                            if (AccessTracking.TryGetCallerInfo(e.CallerId, out var info))
                            {
                                if (info.Label is not null) writer.WriteString("label", info.Label);
                                writer.WriteString("member", info.Member);
                                writer.WriteString("file", info.File);
                                writer.WriteNumber("line", info.Line);
                            }
                            writer.WriteEndObject();
                        }
                        writer.WriteEndArray();
                    }
                    writer.WriteEndObject();
                }
                writer.WriteEndArray();

#if ACCESS_TRACK_LOG
                if (_logCount > 0 && _log is { } log)
                {
                    writer.WritePropertyName("events");
                    writer.WriteStartArray();

                    var count = _logCount;
                    for (var i = 0; i < count; i++)
                    {
                        var idx = (_logCursor - 1 - i);
                        if (idx < 0) idx += log.Length;
                        var e = log[idx];

                        writer.WriteStartObject();
                        writer.WriteString("t", (_since + TimeSpan.FromSeconds((e.Ticks - _sinceTicks) / (double)Stopwatch.Frequency)).ToString("O"));
                        writer.WriteString("member", map.MemberNames[e.MemberIndex]);

                        if (e.CallerId > 0 && AccessTracking.TryGetCallerInfo(e.CallerId, out var info))
                        {
                            if (info.Label is not null) writer.WriteString("label", info.Label);
                            writer.WriteNumber("callerId", info.Id);
                            writer.WriteString("callerMember", info.Member);
                            writer.WriteString("callerFile", info.File);
                            writer.WriteNumber("callerLine", info.Line);
                        }

                        WriteEventValueJson(writer, e);
                        writer.WriteEndObject();
                    }

                    writer.WriteEndArray();
                }
#endif
                writer.WriteEndObject();
            }

            var json = Encoding.UTF8.GetString(buffer.WrittenSpan);
            if (reset) Reset();
            return json;
        }

        public string DumpText(in MappingInfo map, int? topN = null, bool reset = false)
        {
            var d = _descriptor;
            if (d is null) return string.Empty;

            var sb = new StringBuilder();
            sb.Append("Type: ").Append(map.TypeName).Append(", Instance: ").Append(_instanceId).AppendLine();
            sb.Append("Enabled: ").Append(AccessTracking.IsTrackingEnabled)
              .Append(", Since: ").Append(_since.ToString("O")).AppendLine();

            sb.AppendLine("Members:");
            for (var i = 0; i < d.MemberCount; i++)
            {
                var name = map.MemberNames[i];
                var written = GetWriteBit(i) ? "written" : "-";
#if ACCESS_TRACK_COUNTS
                var cnt = (_counts is { } c) ? c[i].ToString() : "-";
#else
                var cnt = "-";
#endif
#if ACCESS_TRACK_LAST
                var ts = (_last is { } l && l[i] != 0)
                    ? (_since + TimeSpan.FromSeconds((l[i] - _sinceTicks) / (double)Stopwatch.Frequency)).ToString("O")
                    : "—";
#else
                var ts = "—";
#endif
                sb.Append("  • ").Append(name).Append(": ").Append(written).Append(", count=").Append(cnt).Append(", last=").Append(ts).AppendLine();
            }

#if ACCESS_TRACK_LOG
            if (_logCount > 0 && _log is { } log)
            {
                sb.AppendLine("Events (newest first):");
                var count = _logCount;
                for (var i = 0; i < count; i++)
                {
                    var idx = (_logCursor - 1 - i);
                    if (idx < 0) idx += log.Length;
                    var e = log[idx];
                    var when = _since + TimeSpan.FromSeconds((e.Ticks - _sinceTicks) / (double)Stopwatch.Frequency);
                    sb.Append("  ").Append(when.ToString("O"))
                      .Append("  ").Append(map.MemberNames[e.MemberIndex]);
                    if (e.CallerId > 0 && AccessTracking.TryGetCallerInfo(e.CallerId, out var info))
                        sb.Append("  caller=").Append(info.Label ?? info.Member);
                    sb.AppendLine();
                }
            }
#endif
            var txt = sb.ToString();
            if (reset) Reset();
            return txt;
        }

        public void Reset()
        {
            _writeBits0 = 0;
            if (_writeBitsEx is not null) Array.Clear(_writeBitsEx, 0, _writeBitsEx.Length);
#if ACCESS_TRACK_COUNTS
            if (_counts is not null) Array.Clear(_counts, 0, _counts.Length);
#endif
#if ACCESS_TRACK_LAST
            if (_last is not null) Array.Clear(_last, 0, _last.Length);
#endif
            if (_topCallers is not null) Array.Clear(_topCallers, 0, _topCallers.Length);
#if ACCESS_TRACK_LOG
            _logCursor = 0; _logCount = 0; _budgetExceeded = false;
            if (_lastSnapshots is not null) Array.Clear(_lastSnapshots, 0, _lastSnapshots.Length);
#endif
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private bool GetWriteBit(int idx)
        {
            if (idx < 64) return (_writeBits0 & (1UL << idx)) != 0;
            var exIndex = (idx - 64) >> 6;
            var bit = 1UL << ((idx - 64) & 63);
            return (_writeBitsEx![exIndex] & bit) != 0;
        }

#if ACCESS_TRACK_LOG
        private static bool IsScalarType(Type t)
        {
            if (t.IsEnum) return true;
            return t == typeof(bool) || t == typeof(byte) || t == typeof(sbyte) ||
                   t == typeof(short) || t == typeof(ushort) || t == typeof(int) || t == typeof(uint) ||
                   t == typeof(long) || t == typeof(ulong) || t == typeof(char) ||
                   t == typeof(float) || t == typeof(double) || t == typeof(decimal) ||
                   t == typeof(DateTime) || t == typeof(DateTimeOffset) || t == typeof(TimeSpan) ||
                   t == typeof(Guid);
        }

        private object? CreateSnapshot(object? value, ref long budgetBytes, out EventValueKind kind)
        {
            if (value is null) { kind = EventValueKind.None; return null; }
            var t = value.GetType();

            if (t == typeof(string)) { kind = EventValueKind.String; return value; }
            if (IsScalarType(t)) { kind = EventValueKind.Scalar; return value; }

            if ((AccessTracking.SnapshotModeDefault & (ValueSnapshotMode.Collections | ValueSnapshotMode.Full)) != 0)
            {
                var cv = new CollectionValue { TypeName = FriendlyTypeName(t) };

                if (t.IsArray)
                {
                    var arr = (Array)value;
                    var len = arr.Length;
                    cv.Count = len;

                    var full = (AccessTracking.SnapshotModeDefault & ValueSnapshotMode.Full) != 0 ||
                               len <= AccessTracking.CollectionFullThresholdDefault;

                    if (full)
                    {
                        cv.Full = (Array)arr.Clone();
                        budgetBytes -= EstimateArrayBytes(cv.Full);
                    }
                    else
                    {
                        var h = Math.Min(len, AccessTracking.CollectionSliceHeadDefault);
                        var tt = Math.Min(len - h, AccessTracking.CollectionSliceTailDefault);
                        if (tt < 0) tt = 0;

                        var et = t.GetElementType() ?? typeof(object);
                        if (h > 0)
                        {
                            cv.Head = Array.CreateInstance(et, h);
                            Array.Copy(arr, 0, cv.Head, 0, h);
                            budgetBytes -= EstimateArrayBytes(cv.Head);
                        }
                        if (tt > 0)
                        {
                            cv.Tail = Array.CreateInstance(et, tt);
                            Array.Copy(arr, len - tt, cv.Tail, 0, tt);
                            budgetBytes -= EstimateArrayBytes(cv.Tail);
                        }
                        cv.Truncated = (h + tt) < len;
                    }

                    if (budgetBytes < 0) _budgetExceeded = true;
                    kind = EventValueKind.Collection; return cv;
                }

                if (value is IDictionary dict)
                {
                    var count = dict.Count;
                    cv.Count = count;

                    var full = (AccessTracking.SnapshotModeDefault & ValueSnapshotMode.Full) != 0 ||
                               count <= AccessTracking.CollectionFullThresholdDefault;

                    if (full)
                    {
                        var arr = new KeyValuePair<object?, object?>[count];
                        var i = 0;
                        foreach (DictionaryEntry e in dict)
                            arr[i++] = new KeyValuePair<object?, object?>(e.Key, e.Value);
                        cv.Full = arr;
                        budgetBytes -= EstimateArrayBytes(arr);
                    }
                    else
                    {
                        var headCnt = Math.Min(count, AccessTracking.CollectionSliceHeadDefault);
                        var tailCnt = Math.Min(Math.Max(0, count - headCnt), AccessTracking.CollectionSliceTailDefault);

                        var head = new KeyValuePair<object?, object?>[headCnt];
                        var tail = new KeyValuePair<object?, object?>[tailCnt];

                        var idx = 0;
                        foreach (DictionaryEntry e in dict)
                        {
                            if (idx < headCnt) head[idx] = new KeyValuePair<object?, object?>(e.Key, e.Value);
                            else if (idx >= count - tailCnt) tail[idx - (count - tailCnt)] = new KeyValuePair<object?, object?>(e.Key, e.Value);
                            idx++;
                        }

                        if (headCnt > 0) budgetBytes -= EstimateArrayBytes(head);
                        if (tailCnt > 0) budgetBytes -= EstimateArrayBytes(tail);

                        cv.Head = headCnt > 0 ? head : null;
                        cv.Tail = tailCnt > 0 ? tail : null;
                        cv.Truncated = (headCnt + tailCnt) < count;
                    }

                    if (budgetBytes < 0) _budgetExceeded = true;
                    kind = EventValueKind.Collection; return cv;
                }

                if (value is IEnumerable enumerable)
                {
                    var list = new List<object?>();
                    foreach (var it in enumerable) list.Add(it);
                    var count = list.Count;
                    cv.Count = count;

                    var full = (AccessTracking.SnapshotModeDefault & ValueSnapshotMode.Full) != 0 ||
                               count <= AccessTracking.CollectionFullThresholdDefault;

                    if (full)
                    {
                        var arr = list.ToArray();
                        cv.Full = arr;
                        budgetBytes -= EstimateArrayBytes(arr);
                    }
                    else
                    {
                        var headCnt = Math.Min(count, AccessTracking.CollectionSliceHeadDefault);
                        var tailCnt = Math.Min(Math.Max(0, count - headCnt), AccessTracking.CollectionSliceTailDefault);

                        var head = new object?[headCnt];
                        var tail = new object?[tailCnt];

                        if (headCnt > 0) list.CopyTo(0, head, 0, headCnt);
                        if (tailCnt > 0) list.CopyTo(count - tailCnt, tail, 0, tailCnt);

                        cv.Head = headCnt > 0 ? head : null;
                        cv.Tail = tailCnt > 0 ? tail : null;
                        cv.Truncated = (headCnt + tailCnt) < count;

                        if (headCnt > 0) budgetBytes -= EstimateArrayBytes(head);
                        if (tailCnt > 0) budgetBytes -= EstimateArrayBytes(tail);
                    }

                    if (budgetBytes < 0) _budgetExceeded = true;
                    kind = EventValueKind.Collection; return cv;
                }
            }

            kind = EventValueKind.String;
            return value.ToString();
        }

        private static long EstimateArrayBytes(Array arr)
        {
            var len = arr.Length;
            var et = arr.GetType().GetElementType();
            int elemSize =
                et == typeof(bool) || et == typeof(byte) || et == typeof(sbyte) ? 1 :
                et == typeof(short) || et == typeof(ushort) || et == typeof(char) ? 2 :
                et == typeof(int) || et == typeof(uint) || et == typeof(float) ? 4 :
                et == typeof(long) || et == typeof(ulong) || et == typeof(double) ? 8 :
                et == typeof(decimal) ? 16 : 8;
            return 24 + (long)elemSize * len;
        }

        private static string FriendlyTypeName(Type t)
        {
            if (!t.IsGenericType) return t.Name;
            var name = t.Name;
            var tick = name.IndexOf('`');
            if (tick >= 0) name = name[..tick];
            var args = string.Join(",", t.GetGenericArguments().Select(FriendlyTypeName));
            return $"{name}<{args}>";
        }

        private static void WriteEventValueJson(Utf8JsonWriter writer, AccessEvent e)
        {
            if (e.ValueKind == EventValueKind.None) return;

            writer.WritePropertyName("value");
            writer.WriteStartObject();

            switch (e.ValueKind)
            {
                case EventValueKind.Scalar:
                    writer.WritePropertyName("scalar");
                    writer.WriteStartObject();
                    writer.WritePropertyName("old"); JsonSerializer.Serialize(writer, e.OldValue);
                    writer.WritePropertyName("new"); JsonSerializer.Serialize(writer, e.NewValue);
                    writer.WriteEndObject();
                    break;
                case EventValueKind.String:
                    writer.WritePropertyName("string");
                    writer.WriteStartObject();
                    writer.WriteString("old", e.OldValue as string);
                    writer.WriteString("new", e.NewValue as string);
                    writer.WriteEndObject();
                    break;
                case EventValueKind.Collection:
                    writer.WritePropertyName("collection");
                    writer.WriteStartObject();
                    var oldC = e.OldValue as CollectionValue;
                    var newC = e.NewValue as CollectionValue;
                    if (newC is not null) { writer.WriteString("type", newC.TypeName); writer.WriteNumber("countNew", newC.Count); writer.WriteBoolean("truncated", newC.Truncated); }
                    if (oldC is not null) writer.WriteNumber("countOld", oldC.Count);
                    writer.WritePropertyName("old"); WriteCollectionSnapshot(writer, oldC);
                    writer.WritePropertyName("new"); WriteCollectionSnapshot(writer, newC);
                    writer.WriteEndObject();
                    break;
            }

            writer.WriteEndObject();
        }

        private static void WriteCollectionSnapshot(Utf8JsonWriter writer, CollectionValue? cv)
        {
            if (cv is null) { writer.WriteNullValue(); return; }
            writer.WriteStartObject();
            if (cv.Full is not null) { writer.WritePropertyName("full"); WriteArray(writer, cv.Full); }
            else
            {
                if (cv.Head is not null) { writer.WritePropertyName("head"); WriteArray(writer, cv.Head); }
                if (cv.Tail is not null) { writer.WritePropertyName("tail"); WriteArray(writer, cv.Tail); }
            }
            writer.WriteEndObject();
        }

        private static void WriteArray(Utf8JsonWriter writer, Array arr)
        {
            writer.WriteStartArray();
            foreach (var it in arr) JsonSerializer.Serialize(writer, it);
            writer.WriteEndArray();
        }

        private interface IMemberAccessor { object? Get(object instance); }
        private sealed class PropertyAccessor : IMemberAccessor
        {
            private readonly PropertyInfo _p; public PropertyAccessor(PropertyInfo p) => _p = p;
            public object? Get(object instance) => _p.GetValue(instance);
        }
        private sealed class FieldAccessor : IMemberAccessor
        {
            private readonly FieldInfo _f; public FieldAccessor(FieldInfo f) => _f = f;
            public object? Get(object instance) => _f.GetValue(instance);
        }
        private static IMemberAccessor[] BuildAccessors(Type type, string[] memberNames)
        {
            var accessors = new IMemberAccessor[memberNames.Length];
            var flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;
            for (var i = 0; i < memberNames.Length; i++)
            {
                var name = memberNames[i];
                var p = type.GetProperty(name, flags);
                if (p is not null) { accessors[i] = new PropertyAccessor(p); continue; }
                var f = type.GetField(name, flags);
                if (f is not null) { accessors[i] = new FieldAccessor(f); continue; }
                accessors[i] = new FallbackAccessor();
            }
            return accessors;
        }
        private sealed class FallbackAccessor : IMemberAccessor { public object? Get(object instance) => null; }
#endif
        // -------- NO-TRACK build fallbacks --------
#else
        public void EnsureConfigured(AccessDescriptor descriptor, object owner) { _ = descriptor; _ = owner; }
        public void RecordWrite(int memberIndex) { _ = memberIndex; }
        public string DumpJson(in MappingInfo map, int? topN = null, bool reset = false) { _ = map; _ = topN; _ = reset; return "{}"; }
        public string DumpText(in MappingInfo map, int? topN = null, bool reset = false) { _ = map; _ = topN; _ = reset; return string.Empty; }
        public void Reset() { }
#endif
    }
}
