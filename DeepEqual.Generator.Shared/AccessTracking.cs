// <auto-generated/>
#nullable enable
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;

namespace DeepEqual.Generator.Shared
{
    /// <summary>Value snapshot mode for event payloads (used by runtime only).</summary>
    [Flags]
    public enum ValueSnapshotMode
    {
        None = 0,
        ScalarsAndStrings = 1 << 0,
        Collections = 1 << 1,
        Full = 1 << 2, // force full collection snapshots
    }

    /// <summary>Ambient access tracking configuration and caller scopes.</summary>
    public static class AccessTracking
    {
#if ACCESS_TRACK
        // ---------- Caller scopes (HIERARCHICAL) ----------
        private sealed class ScopeFrame
        {
            public ScopeFrame(int id, ScopeFrame? parent) { Id = id; Parent = parent; }
            public int Id { get; }
            public ScopeFrame? Parent { get; }
        }

        private sealed class ScopeHandle : IDisposable
        {
            private readonly ScopeFrame? _previous;
            private bool _disposed;
            public ScopeHandle(ScopeFrame? previous) => _previous = previous;
            public void Dispose()
            {
                if (_disposed) return;
                _disposed = true;
                s_frame.Value = _previous;
            }
        }

        private static readonly AsyncLocal<ScopeFrame?> s_frame = new();

        private readonly struct CallerKey : IEquatable<CallerKey>
        {
            public CallerKey(string? label, string member, string file, int line)
            { Label = label; Member = member; File = file; Line = line; }
            public string? Label { get; }
            public string Member { get; }
            public string File { get; }
            public int Line { get; }
            public bool Equals(CallerKey other)
            {
                // if a label is provided, it is the canonical identity
                if (Label is not null || other.Label is not null)
                    return string.Equals(Label, other.Label, StringComparison.Ordinal);

                // otherwise use member/file/line
                return Line == other.Line &&
                       string.Equals(Member, other.Member, StringComparison.Ordinal) &&
                       string.Equals(File, other.File, StringComparison.Ordinal);
            }
            public override bool Equals(object? obj) => obj is CallerKey other && Equals(other);

            public override int GetHashCode()
            {
                if (Label is not null)
                    return Label.GetHashCode(StringComparison.Ordinal);

                unchecked
                {
                    var h = 17;
                    h = (h * 31) + Member.GetHashCode(StringComparison.Ordinal);
                    h = (h * 31) + File.GetHashCode(StringComparison.Ordinal);
                    h = (h * 31) + Line;
                    return h;
                }
            }
        }

        private static readonly object s_callerLock = new();
        private static readonly Dictionary<CallerKey, int> s_callerIds = new();
        private static readonly List<CallerInfo> s_callerInfos = new() { default! }; // index 0 unused
        private static int s_nextCallerId;

        // ---------- Global feature toggles ----------
        private static volatile bool s_trackingEnabled = true;
        private static volatile bool s_countsEnabled = true;
        private static volatile bool s_lastEnabled = true;
        private static volatile bool s_logEnabled = true;
        private static volatile bool s_callersEnabled = true;

        private static volatile AccessMode s_defaultMode = AccessMode.Write;
        private static volatile AccessGranularity s_defaultGranularity = AccessGranularity.CountsAndLast;
        private static volatile int s_defaultLogCapacity = 0;

        // ---------- Snapshot defaults ----------
        private static volatile ValueSnapshotMode s_snapshotModeDefault = ValueSnapshotMode.ScalarsAndStrings | ValueSnapshotMode.Collections;
        private static volatile int s_collectionFullThresholdDefault = 64;
        private static volatile int s_collectionSliceHeadDefault = 32;
        private static volatile int s_collectionSliceTailDefault = 32;
        private static volatile int s_snapshotByteBudgetPerInstanceDefault = 262_144; // 256 KB

        private static int s_configVersion;

        // ---------- Public surface ----------
        public static int CurrentCallerId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => s_frame.Value?.Id ?? 0;
        }

        /// <summary>Enumerate active caller IDs from innermost → outermost into the provided buffer. Returns count written.</summary>
        internal static int EnumerateActiveCallers(Span<int> buffer)
        {
            var f = s_frame.Value;
            var i = 0;
            while (f is not null && i < buffer.Length)
            {
                buffer[i++] = f.Id;
                f = f.Parent;
            }
            return i;
        }

        /// <summary>Push a caller scope; disposing restores the previous chain.</summary>
        public static IDisposable PushScope(string? label = null,
            [CallerMemberName] string? member = null,
            [CallerFilePath] string? file = null,
            [CallerLineNumber] int line = 0)
        {
            member ??= string.Empty;
            file ??= string.Empty;

            var previous = s_frame.Value;
            if (!s_callersEnabled || !s_trackingEnabled)
                return new ScopeHandle(previous);

            // Assign (or retrieve) a stable id for this caller frame
            var key = new CallerKey(label, member, file, line);
            int id;
            lock (s_callerLock)
            {
                if (!s_callerIds.TryGetValue(key, out id))
                {
                    id = ++s_nextCallerId;
                    s_callerIds[key] = id;
                    s_callerInfos.Add(new CallerInfo(id, label, member, file, line));
                }
            }

            s_frame.Value = new ScopeFrame(id, previous);
            return new ScopeHandle(previous);
        }

        /// <summary>Legacy Configure (kept for compatibility).</summary>
        public static void Configure(
            AccessMode defaultMode,
            AccessGranularity defaultGranularity,
            int defaultLogCapacity,
            bool trackingEnabled = true,
            bool countsEnabled = true,
            bool lastEnabled = true,
            bool logEnabled = true,
            bool callersEnabled = true)
        {
            s_defaultMode = defaultMode;
            s_defaultGranularity = defaultGranularity;
            s_defaultLogCapacity = Math.Max(0, defaultLogCapacity);
            s_trackingEnabled = trackingEnabled;
            s_countsEnabled = countsEnabled;
            s_lastEnabled = lastEnabled;
            s_logEnabled = logEnabled;
            s_callersEnabled = callersEnabled;
            RaiseConfigurationChanged();
        }

        /// <summary>Configure snapshot defaults (optional).</summary>
        public static void ConfigureSnapshots(
            ValueSnapshotMode snapshotModeDefault = ValueSnapshotMode.ScalarsAndStrings | ValueSnapshotMode.Collections,
            int collectionFullThreshold = 64,
            int collectionSliceHead = 32,
            int collectionSliceTail = 32,
            int snapshotByteBudgetPerInstance = 262_144)
        {
            s_snapshotModeDefault = snapshotModeDefault;
            s_collectionFullThresholdDefault = Math.Max(0, collectionFullThreshold);
            s_collectionSliceHeadDefault = Math.Max(0, collectionSliceHead);
            s_collectionSliceTailDefault = Math.Max(0, collectionSliceTail);
            s_snapshotByteBudgetPerInstanceDefault = Math.Max(0, snapshotByteBudgetPerInstance);
            RaiseConfigurationChanged();
        }

        // ---------- Internal access ----------
        internal static void RaiseConfigurationChanged() => Interlocked.Increment(ref s_configVersion);
        internal static int ConfigurationVersion => Volatile.Read(ref s_configVersion);

        internal static AccessMemberFlags EnabledFeatures
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                if (!s_trackingEnabled) return AccessMemberFlags.None;
                var mask = AccessMemberFlags.Track;
                if (s_countsEnabled) mask |= AccessMemberFlags.Counts;
                if (s_lastEnabled) mask |= AccessMemberFlags.Last;
                if (s_callersEnabled) mask |= AccessMemberFlags.Caller;
                return mask;
            }
        }

        internal static bool IsTrackingEnabled => s_trackingEnabled;
        internal static bool CountsEnabled => s_countsEnabled && s_trackingEnabled;
        internal static bool LastEnabled => s_lastEnabled && s_trackingEnabled;
        internal static bool CallersEnabled => s_callersEnabled && s_trackingEnabled;
        internal static bool LogEnabled => s_logEnabled && s_trackingEnabled;

        internal static AccessMode DefaultMode => s_defaultMode;
        internal static AccessGranularity DefaultGranularity => s_defaultGranularity;
        internal static int DefaultLogCapacity => s_defaultLogCapacity;

        internal static ValueSnapshotMode SnapshotModeDefault => s_snapshotModeDefault;
        internal static int CollectionFullThresholdDefault => s_collectionFullThresholdDefault;
        internal static int CollectionSliceHeadDefault => s_collectionSliceHeadDefault;
        internal static int CollectionSliceTailDefault => s_collectionSliceTailDefault;
        internal static int SnapshotByteBudgetPerInstanceDef => s_snapshotByteBudgetPerInstanceDefault;

        public readonly struct CallerInfo
        {
            public CallerInfo(int id, string? label, string member, string file, int line)
            { Id = id; Label = label; Member = member; File = file; Line = line; }
            public int Id { get; }
            public string? Label { get; }
            public string Member { get; }
            public string File { get; }
            public int Line { get; }
        }

        internal static bool TryGetCallerInfo(int callerId, out CallerInfo info)
        {
            if (callerId <= 0) { info = default; return false; }
            lock (s_callerLock)
            {
                if (callerId < s_callerInfos.Count)
                {
                    info = s_callerInfos[callerId];
                    return true;
                }
            }
            info = default;
            return false;
        }
#else
        // -------- NO-OP build (ACCESS_TRACK not defined) --------
        private sealed class NoopScope : IDisposable { public void Dispose() { } }
        private static readonly IDisposable s_noopScope = new NoopScope();

        public static int CurrentCallerId => 0;
        internal static int EnumerateActiveCallers(Span<int> buffer) { return 0; }
        public static IDisposable PushScope(string? label = null,
            [CallerMemberName] string? member = null,
            [CallerFilePath] string? file = null,
            [CallerLineNumber] int line = 0) => s_noopScope;

        public static void Configure(AccessMode _, AccessGranularity __, int ___, bool ____=true, bool _____=true, bool ______=true, bool _______=true, bool ________=true) { }
        public static void ConfigureSnapshots(ValueSnapshotMode _=ValueSnapshotMode.ScalarsAndStrings|ValueSnapshotMode.Collections, int __=64, int ___=32, int ____=32, int _____=262_144) { }

        internal static void RaiseConfigurationChanged() { }
        internal static int  ConfigurationVersion => 0;
        internal static AccessMemberFlags EnabledFeatures => AccessMemberFlags.None;
        internal static bool IsTrackingEnabled => false;
        internal static bool CountsEnabled => false;
        internal static bool LastEnabled => false;
        internal static bool CallersEnabled => false;
        internal static bool LogEnabled => false;

        internal static AccessMode        DefaultMode        => AccessMode.None;
        internal static AccessGranularity DefaultGranularity => AccessGranularity.Bits;
        internal static int               DefaultLogCapacity => 0;

        internal static ValueSnapshotMode SnapshotModeDefault => ValueSnapshotMode.None;
        internal static int CollectionFullThresholdDefault   => 64;
        internal static int CollectionSliceHeadDefault       => 32;
        internal static int CollectionSliceTailDefault       => 32;
        internal static int SnapshotByteBudgetPerInstanceDef => 0;

        public readonly struct CallerInfo
        {
            public int Id => 0;
            public string? Label => null;
            public string Member => string.Empty;
            public string File => string.Empty;
            public int Line => 0;
        }
        internal static bool TryGetCallerInfo(int callerId, out CallerInfo info) { info = default; return false; }
#endif
    }
}
